                                  HOW IT WORKS?
                                  ~~~~~~~~~~~~~
                           (understanding plugin virus)

      There are plugin called PENTRY, which means PE entrypoint.
      It contains:
      - virus entry point (in the PE file)
      - JMP to original entrypoint
      And between them there are code to call LOADER:

   ---begin PENTRY.PGN---
   event                   macro   EventName
                           mov     eax, EventName
                           call    ebp
                           endm

   VirusEntryPointRVA:     ...
                           call    $+5     ; EBP <-- LOADER.HandleEvent
                           pop     ebp
                           add     ebp, $-1-LOADER.HandleEvent
                           ...
                           event   EV_PENTRY_START_IN_PE   ; notify all pgns
                           ...
                           jmp     OriginalEntryPointRVA
   ---end PENTRY.PGN---

      Task of the LOADER's HandleEvent subroutine
      (whose address is always in EBP)
      is to call ALL plugins' HandleEvents one by one,
      until event will be handled (until CF will be cleared).

      But, lets return to our plugins. So, by means of LOADER all
      plugins are called with EAX==EV_PENTRY_START_IN_PE.

      This event (EV_PENTRY_START_IN_PE) is handled by TSR plugin,
      which calls own ring-0 code by means of RING0 plugin.
      TSR's ring-0 code allocates memory, copies virus there and calls
      EV_TSR_IN_NEW_ADDR event.

      And EV_TSR_IN_NEW_ADDR event is handled by IFSHAN plugin, which
      sets own IFS handler and calls IFSCALL plugin on each IFS call.

      IFSCALL plugin builds filename (via IFSMGR.UniToBCSPath) and
      calls EV_IFSCALL_GOT_FILENAME event.

      EXTMAN plugin (extension manager) hooks this event, takes extension
      and calls EV_EXTMAN_GOT_EXEDLL event.

      Plugins INFMAN0 and INFMAN3 (r0/r3 INFECTION MANAGER) both hooks
      EV_EXTMAN_GOT_EXEDLL event.
      Then they open file, read it into memory, and call INFECT1 plugin.

      Kinda all.
                               ADDITIONAL PLUGINS.

      PERPROC (PER PROCess) plugin (on EV_PENTRY_START_IN_PE event)
      calls EV_PERPROC_START event within the new thread, and this event
      is hooked by RECSERCH (recursive search) plugin, and each filename
      will be passed to EXTMAN.

      ...

                             HOW TO ADD NEW FEATURES

      Before and after file infection, INFMAN0/3 plugins both called
      EV_INFMANx_BEFORE_VIRUS, EV_INFMANx_BEFORE_FILE and EV_INFMANx_AFTER_FILE
      events.

      UNCALL plugin hooks one of these events and restores changed VxDcalls
      (FF 15 xxxxxxxx --> CD 20 ...).

      Such hooks may be inserted anywhere, but you task is to know where
      they will be required.
      EV_INFMANx_BEFORE_VIRUS - for polymorphic
      EV_INFMANx_BEFORE_FILE  - file unpacker
      EV_INFMANx_AFTER_FILE   - INFECTED file packer

      EV_TSR_IN0_ONSTART - AV VxD killer

      and so on

                                  POSSIBILITIES

      Permutation (RPME) may be applied to any plugin, if it uses only code
      without fixed offsets.

      Any two (and more) plugins may be automatically merged into one,
      using RPME too.
      As it seems, after such action this "big" plugin will be impossible
      to split, but, who knows?...

                                      OTHER

      MEMORY plugin
      events: EV_MEMORY_MALLOC, EV_MEMORY_MFREE
      action: depending on ring0/ring3, call
              KERNEL32.GlobalAlloc/Free or VMM32.PageAllocate/Free.

      K32MAN (KERNEL32 manager) plugin
      events: EV_K32MAN_GET_PROC_ADDRESS
      action: get address of any kernel's subroutine

      If some event must be handled by more than one plugin,
      all handlers must keep registers unchanged and set CF (stc).

      If event handler wanna return CF to caller (bypass loader),
      it must do LEA ESP,[ESP+8] before RETN.

                                       ...
