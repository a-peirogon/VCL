   Note:   This file was first confidentially spread to various virus writers,
           and I finally came to the conclusion that since the nature of GRACE
           will be very generic, av'er cannot take it into account beforehand.
           Therefore it's completely safe to spread this, since most scanners
           still rely on some sort of string scanning, and av'er don't like going
           through thousands of old virus strings if they don't need to.


   GRACE
   =====

   At the moment I'm making plans on writing a virus generator. A virus
   generator on itself is not a novel idea. We have seen different
   approaches from a menu interface (VCL) to modular code with
   configuration files (G2). To avoid making another clone of one of these,
   I have decided to take a complete different approach. The program I'm
   planning to make is not as much as a virus generator, but more of a kind
   of "meta-assembly" language which can be used for virus exploits. The
   language can be extended by external C source code, which gets loaded
   and compiled by the generator during runtime. The virus code is being
   generated from a template file, which contains mixed meta and assembly
   code, of which parts can or can not be included, which is decided by a
   configuration file for that template (a la PS-MPC).

   You see that this is a mighty big project, and it will sure take me a
   lot of time to finish it, granted if I succeed at all. I have called
   this project GRACE (Generic Random Assembly Construction Engine). To let
   GRACE to be of use to you, I need your help. I want you to exchange
   ideas with me how the meta language should look like, what possibilities
   you want in the language, etc.

   Opcodes
   =======

   GRACE will feature an extended opcode set for generating random
   instructions. This can be mixed through the assembler code. Here are a
   few examples of what kind of extended opcodes I mean:

           opcode                          could generate

           ZERO <reg>                      MOV <reg>,0
                                           or
                                           SUB <reg>,<reg>
                                           or
                                           CLC
                                           SBB <reg>,<reg>
                                           or
                                           XOR <reg>,<reg>
                                           or
                                           AND <reg>,0

           LOAD <reg>,<reg>|<mem>|<imm>|   MOV <reg>,<rval>
                      <mem+reg> = <rval>   or
                                           ZERO <reg>
                                           ADD <reg>,<rval>
                                           or
                                           ZERO <reg>
                                           OR <reg>,<rval>
                                           or
                                           ZERO <reg>
                                           XOR <reg>,<rval>
                                           or
                                           ZERO <reg>
                                           CLC
                                           ADC <reg>,<rval>

           INCR <reg>|<mem+reg>|           INC <rval>
                <mem> = <rval>             or
                                           ADD <rval>,1
                                           or
                                           SUB <rval>,-1

           DECR <reg>|<mem+reg>|           DEC <rval>
                <mem> = <rval>             or
                                           SUB <rval>,1
                                           or
                                           ADD <rval>,-1

   You see the idea here, be creative, thing of nice possible constructs
   how to move registers, compare things, do branches, whatever! As you
   see, the opcodes can be recursed, so this leaves room for maximum
   flexibility.

   Example idea of how the meta code would look like with these two
   new opcodes:

           open_file:              load ax,3d02h           ; open file
                                   load dx,9eh             ; dta :-)
                                   int 21h
                                   jc error
                                   load ax,4202h           ; end of file
                                   zero cx
                                   zero dx
                                   int 21h

   Or a simple dencryption loop, which now turns out to be nicely
   polymorphically generated:

                                   load cx,virus_bytes
                                   load si,encrypted_code
   decrypt:                        xor byte ptr [si],bvalue
                                   incr si
                                   decr cx
                                   jnz decrypt

   Register tracking
   =================

   If I can do some sort of register tracking, I can see which registers
   are free for generating trash functions for between the code, but I
   cannot predict what registers get filled with important values after
   calling an interrupt. How should I track the registers? I thought the
   simplest approach would be using statements for reserving, freeing and
   tracking registers. For example:

           load ax,3d02h
           load dx,offset filename
           int 21h
           jc error
           RESERVE AX              ; protects file handle
           some trash code generation opcodes that you have thought of :-)
           FREE AX                 ; frees file handle
           load bx,4202h
           xchg ax,bx
           RESERVE AX,BX           ; protects file handle


   Should I try to do some register tracking? It is not so easy to do. What
   I can do is let the generator output warning messages that a register
   that is reserved is being manipulated, or let GRACE generate push and
   pop sequences to save registers? That would not be safe if there is a
   branch that jumps out of the RESERVE and FREE statements. Comments
   please!

   Random Line Ordering
   ====================

   To be truly of use, it should be possible to let lines of code get
   swapped, or in case a meta opcode is used, get mixed if possible. How
   should I define blocks of lines that can be swapped? I was thinking
   about this:

                           BEGIN MIX
                           load si,encrypted_file
                           load cx,virus_bytes
                           END MIX
           decrypt:        xor byte ptr [si],bval
                           incr si
                           decr cx
                           jnz decrypt

   or to lseek to the end of the file:

                           BEGIN MIX
                           load ax,4202h
                           zero cx
                           zero dx
                           END MIX

   Beware: you cannot mix incr si/decr cx from the 1st example, as the
   branch depends on the result on the operation on cx, which gets
   destroyed of si gets modified after it.

   Random Block Ordering
   =====================

   I have absolutely no idea how I'll do this, I had an idea about defining
   blocks of code with name and level, so blocks can be nested, or should I
   autodetect levels, so I can simply use brackets ({}) for defining
   blocks? That would make it VERY nice.

   {
   open_file:      load ax,3d02h
                   int 21h
                   jc error
                   xchg ax,bx
   error:          ret
   }

   {
   close_file:     load ah,3eh
                   int 21h
                   ret
   }

   check_type:     cmp word ptr [exe_id],'MZ'
                   je exefile
                   cmp word ptr [exe_id],'ZM'
                   je exefile
                   jmp comfile
   {
     {
     com_file:     etc;
     }
     {
     exe_file:     etc;
     }
   }

   This makes it very cryptic and you easily can get problems with
   branching out of range, so please give me some comments on this one!

   Random Register Selector
   ========================

   For some matters (especially encryption loops) it would be nice if you
   could load a random register in a symbol, which you could use in your
   assembler statements, like a random definition from a c-like
   preprocessor. Ofcourse it should work with statements like for example
   RESERVE and FREE. Look at this sample:

                   BEGIN MIX
                   EVO = random("SI","DI","BX")
                   RESERVE EVO
                   load EVO,encrypted_virus_offset
                   COUNTER = random("AX","BX","CX","DX","SI","DI","BP")
                   load COUNTER,virus_bytes
                   RESERVE COUNTER
                   END MIX
   decrypt:        xor byte ptr [EVO],bval
                   incr EVO
                   decr COUNTER
                   jnz decrypt
                   FREE EVO,COUNTER

   Conditionals
   ============

   To make GRACE work with configuration files, the meta language should
   support some conditionals that can evaluate strings that have been read
   from the configuration file. I can't use the normal IF, since that is a
   reserved TASM word. Should I use IFOPT and ENDIFOPT? Or should I create
   C-like IF constructs? I can recognize them simply with grammar, since
   C's IF uses () and TASM doesn't.

   if (tsr == "Y") || (tsr == "Yes")
           hey you see that? If I want to do this approach, I should
           provide some string comparison and manipulation functions... You
           know what I want to ask from you...


   The end of the story, the beginning of my biggest project.

   If you have any ideas or want to contact me on this project, feel free
   to send email to: rajaat@itookmyprozac.com

   If there is enough interest, I shall see if I can make some sort of
   mailing list to keep people informed, or keep up a homepage of the
   progress and discussions.
