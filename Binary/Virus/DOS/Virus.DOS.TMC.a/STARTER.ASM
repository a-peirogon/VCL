        jumps
code    segment para public use16 'CODE'
        assume  cs:code, ds:code
        org     100h

JMPS    EQU     0FFFFh          ;pravdepodobnost na rozdelenie kodu

        include macros.inc


;  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿ ÚÄÄÄÄÄÄÄÄÄÄ
;                     ÚÙÚÙ
;      ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
start:
        mov     ds:out_block_ofs, offset out_block_table
        mov     ds:data_relo_ofs, offset data_relo_table
        mov     ds:jmp_relo_ofs, offset jmp_relo_table

        mov     si, offset src_startup
        mov     bx, offset free
        call    compile
        mov     si, offset src_vir
        call    compile
        call    link
        mov     word ptr cs:[free + 2], offset free
        jmp     free

                ;³                    ³;
                ;³      ANALYZER      ³;
                ;³                    ³;

;³ Input:  SI - source
;³         BX - output
;³ Output: BX - end of code

compile:
        cld
        mov     di, offset in_block_table
        xor     ax, ax

next_in_block:
        add     si, ax
        lodsb
        or      al, al
        jz      end_in_block
        cmp     al, M_CODE
        jae     code_cmd
        cmp     al, MAX_CODE_SIZE
        jbe     next_in_block
        sub     al, MAX_CODE_SIZE
        jmp     next_in_block

code_cmd:
        cmp     al, M_STOP
        jnz     no_stop
        mov     al, 0
        jmp     next_in_block

no_stop:
        cmp     al, M_BLOCK
        jnz     no_block
        mov     ax, si
        dec     ax
        stosw
        mov     ax, 0FFFFh
        stosw
        mov     ax, 2
        jmp     next_in_block

no_block:                               ;M_RELO & M_J*
        mov     al, 2
        jmp     next_in_block

end_in_block:
        lea     ax, [di + (-(offset in_block_table))]
        shr     ax, 1
        shr     ax, 1
        mov     cs:num_of_blocks, ax
        xor     ax, ax
        stosw

                ;³                    ³;
                ;³      COMPILER      ³;
                ;³                    ³;

        mov     di, offset in_block_table
        mov     si, [di]
        jmp     first_no_find

next_block:
        mov     bp, cs:num_of_blocks
        call    rnd_max
        shl     ax, 1
        shl     ax, 1
        add     ax, offset in_block_table
        mov     di, ax

next_search_block:
        add     di, 4
        mov     si, [di]
        or      si, si
        jnz     no_last_block
        mov     di, offset in_block_table
        mov     si, [di]

no_last_block:
        cmp     byte ptr ds:[si], M_STOP
        jnz     no_stoped
        cmp     di, ax
        jnz     next_search_block
        jmp     no_next_block

no_stoped:
first_no_find:
        cmp     word ptr ds:[di+2], 0FFFFh
        jz      no_jmp_constr

        push    di
        mov     di, [di+2]
        mov     al, 0e9h
        stosb
        mov     ax, bx
        dec     ax
        dec     ax
        sub     ax, di
        stosw
        pop     di

no_jmp_constr:
next_inst:
        lodsb
        cmp     al, M_STOP
        jz      no_next_inst

        cmp     al, MAX_CODE_SIZE
        ja      no_break

        push    ax
        mov     bp, JMPS
        call    rnd_max
        or      ax, ax
        pop     ax
        jz      no_last_but_end

no_break:
        cmp     al, M_STOP
        jz      no_next_inst
        cmp     al, M_CODE
        jae     code_cmd1
        cmp     al, MAX_CODE_SIZE
        jbe     no_sub_size_data
        sub     al, MAX_CODE_SIZE

no_sub_size_data:
        xor     cx, cx
        mov     cl, al
        push    di
        mov     di, bx
        rep     movsb
        mov     bx, di
        pop     di
        jmp     next_inst

code_cmd1:
        cmp     al, M_RELO
        jnz     no_relo1

        push    di
        mov     di, data_relo_ofs
        mov     ax, bx
        dec     ax
        dec     ax
        stosw
        lodsw
        stosw
        mov     data_relo_ofs, di
        pop     di
        jmp     next_inst

no_relo1:
        cmp     al, M_BLOCK
        jnz     no_block1

        push    di
        mov     di, out_block_ofs
        mov     ax, bx
        stosw
        lodsw
        stosw
        mov     out_block_ofs, di
        cmp     ax, src_src
        jnz     no_put_src

        push    si
        mov     di, bx
        mov     si, offset src
        mov     cx, offset src_end - offset src
        rep     movsb
        mov     bx, di
        pop     si

no_put_src:
        pop     di
        lodsb
        jmp     no_break

no_block1:                              ;M_J*
        push    ax di
        mov     di, jmp_relo_ofs
        mov     ax, bx
        stosw
        lodsw
        stosw
        mov     jmp_relo_ofs, di
        pop     di ax
        mov     [bx], al
        add     bx, 3
        cmp     al, M_J_COND
        jb      next_inst
        inc     bx
        inc     bx
        jmp     next_inst

no_last_but_end:
        mov     [di+2], bx
        add     bx, 3

no_next_inst:
        dec     si
        mov     [di], si
        jmp     next_block

no_next_block:
        ret
        
                ;³                      ³;
                ;³    JUMP RELOCATOR    ³;
                ;³                      ³;

link:
        mov     si, offset jmp_relo_table
        mov     cx, jmp_relo_ofs
        sub     cx, si 
        shr     cx, 1
        shr     cx, 1

next_jmp_relo:
        lodsw
        push    ax
        lodsw
        push    cx si

        mov     si, offset out_block_table
        mov     cx, out_block_ofs
        sub     cx, si
        shr     cx, 1
        shr     cx, 1

next_jmp_in_out:
        cmp     ax, [si + 2]
        jz      jmp_found
        add     si, 4
        loop    next_jmp_in_out

        int 3
        mov     bp, 0DEEDh

        push    cs
        pop     ds
        mov     dx, offset jump_not_found
        mov     ah, 9
        int     21h
        mov     ah, 4ch
        int     21h

jmp_found:
        mov     dx, [si]
        pop     si cx
        pop     bx
        mov     al, [bx]
        cmp     al, M_J_COND
        jb      jmp1

        sub     byte ptr [bx], 0F0h - 070h
        inc     bx
        push    dx
        sub     dx, bx
        dec     dx
        cmp     dx, 127
        jg      over_jmp
        cmp     dx, -128
        jl      over_jmp
        mov     [bx], dl
        inc     bx
        mov     word ptr [bx], 09090h
        mov     byte ptr [bx+2], 090h
        pop     dx
        jmp     next_j_relo

over_jmp:
        pop     dx
        dec     bx
        xor     byte ptr [bx], 1
        inc     bx
        mov     byte ptr [bx], 3
        inc     bx
        mov     al, 0E9h

jmp1:
        mov     byte ptr [bx], al
        inc     bx
        sub     dx, bx
        dec     dx
        dec     dx
        mov     [bx], dx

next_j_relo:
        loop    next_jmp_relo

                ;³                      ³;
                ;³    DATA RELOCATOR    ³;
                ;³                      ³;

        mov     si, offset data_relo_table
        mov     cx, data_relo_ofs
        sub     cx, si 
        shr     cx, 1
        shr     cx, 1

next_data_relo:
        lodsw
        push    ax
        lodsw
        push    cx si

        mov     si, offset out_block_table
        mov     cx, out_block_ofs
        sub     cx, si
        shr     cx, 1
        shr     cx, 1

next_data_in_out:
        cmp     ax, [si + 2]
        jz      found
        add     si, 4
        loop    next_data_in_out

        int 3
        mov     bp, 0DEADh

        push    cs
        pop     ds
        mov     dx, offset data_not_found
        mov     ah, 9
        int     21h
        mov     ah, 4ch
        int     21h

found:
        mov     ax, [si]
        pop     si cx
        pop     bx
        sub     ax, offset free
        mov     [bx], ax
        loop    next_data_relo

        ret


rnd:
        push    cx
        in      al, 40h
        mov     ah, al
        mov     cl, al
        in      al, 40h
        ror     ax,  cl
        xor     ax, cs:last_rnd
        mov     cs:last_rnd, ax
        pop     cx
        ret

last_rnd        dw      0DEADh

rnd_max:
        or      bp, bp
        jz      rnd_max_0
        push    dx
        call    rnd
;        mov     ax, 1
        xor     dx, dx
        div     bp
        xchg    ax, dx
        pop     dx
        ret

rnd_max_0:
        xor     ax, ax
        ret

num_of_blocks   dw      0
out_block_ofs   dw      0
data_relo_ofs   dw      0
jmp_relo_ofs    dw      0

data_not_found  db      'Error in link data', 13, 10, '$'
jump_not_found  db      'Error in link jump', 13, 10, '$'

        include src\main.inc

in_block_table:
        dd      100h dup(?)
out_block_table:
        dd      100h dup(?)
data_relo_table:
        dd      100h dup(?)
jmp_relo_table:
        dd      100h dup(?)

free:

code    ends
        end     start
