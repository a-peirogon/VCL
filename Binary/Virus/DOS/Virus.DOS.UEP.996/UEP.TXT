

		   Unknown Entry Point Infecting Engine
		   ────────────────────────────────────

  Введение
  ────────

Исследуя этапы развития компьютерных вирусов можно проследить что
всегда на первом плане были разработки по эффективному распространению
и борьбе против антивирусов, в достаточной мере друг с другом перекликающиеся

Если на раннем этапе основной проблемой было обнаружение вируса по маске,
то с появлением продвинутых Mutation Engine эта проблема была в большей мере
решена .

В настоящее время основную опасность для вируса представляет
Эмулятор Кода . Как бы вы в своей Mutation не извратились эмулятору
стоит лишь добраться до Декриптора ,а дальше все как по маслу

Многочисленные антиэвристические приемы с каждой версией Херистика
исправляются и вирус внесенный в базу прикажет долго жить


  Суть Метода
  ───────────

Основной проблемой является то что управление в программе вирусу
передается сразу же после загрузки (Исправленная точка входа) и
эмулятор приступает к анализу непосредственно кодов вируса .

Вообще концепция перехватывания управления у программы в самом начале,
считалась основополагающей аксиомой, даже не требующей оспаривания

Суть метода в том что передача управления в вирус осуществляется не в
самом начале ,а в произвольный момент времени
Основная цель метода в том чтобы Херистик анализировал основные коды
реальной программы и не добрался бы до передачи управления в вирус
Если это выполнится ,то он просто незаметит вируса в программе !

То есть если вирус даже внесен в базу он будет дальше преспокойно
распространяться.Естественно вирус обязан быть полиморфным -
Кого е@$т чего мы там наворотили,если его можно выцепить по маске


  Возможная реализация
  ────────────────────

Мы должны вставить в тело преграммы переход на вирус в произвольном месте

Конечно передача управления в вирус должна быть межсегментной -
это либо Jmp far Seg:Offs ,либо Call far Seg:Offs .
Наиболее приемлемым является использование call far - из стека можно взять
адрес вызова да и она чаще встречается в программах (см.Ниже),а для
jmp far пришлось бы хранить в теле адрес Jmp'a .

Вообще реализовать это можно многими способами -

Например непосредственно в теле в произвольном месте заменить несколько
байт на переход в вирус - недостатки очевидны - непопадание на границу
кода грозит полным крахом

Наиболее приемлемо - это поиск уже существующего вызова в программе с
заменой его на вызов вируса:

Например:
1)	  Просто ищем в теле прграммы байт 9Ah - код Call Far
	  и заменяем на выход в вирус - Проблема та же -
	  непопадание на границу кода:

	  mov	al,9Ah <--Найденный байт ,но в программе
	  ...		  это отнюдь не Far Call

2) Наиболее эффективным и достаточно безопасным явлается поиск Call Far
через таблицу сегменных адресов в заголовке - по адресу из Header'a
находим элемент и смотрим если на $-3 стоит байт 9Ah ,то с достаточной
степенью вероятности можно утверждать что эот Far Call

	 $-3		 $
	 9Ah,Ofs,Ofs,Relocation

Но вполне возможно такое:    mov   dl,9Ah
			     nop  <-- любая другая однобайтовая команда
			     mov   ax,Relocation
			     mov   ds,ax

И это опять ни какой не Far Call

3) Наиболее безопасным ,но менее эффективным является такой метод:
   В теле программы ищем стандартную C/Pascal дальнюю процедуру
   Потом ищем на нее Релокейшн

 ES:LineAddr	 push	bp		   .
		 mov	bp,sp		   .
		 .			   .
		 .			   Call Far Seg:Offs  <──┐
		 .			   преобразованный в сегментный адрес
		 pop	bp
		 retf	[imm8]

   Далее заменяем адрес на нашу точку входа и дописываем вирус в файл
   Старый адрес надо естественно сохранить


  Проблемы и о чем надо помнить
  ─────────────────────────────

Вообще со здравой точки зрения прерывание естественного хода программы
является варварством . Чтоб как то компенсировать наши злодеяния мы должны
для дальнейшей правильной работы программы сохранить исходное состояние,
а после того как вирус все сделал его нужно восстановить и дальше продолжить
ход программы - Call Far RealSeg:RealOffs

При сохранении состояния невозможно учесть все ,так как неизвестно какой
процесс мы прерываем . Минимум - сохранение всех регистров

Также не известно что программа может наворотить до передачи управления вирусу

  Данная реализация
  ─────────────────

 Unknown Entry Point реализован как ангина - то есть

 OpenFile , Call UEPinfect , SetRealTime , CloseFile

 Ангина не устанавливает идентификатор зараженности - установить самому

 UEP.ASM  -  Первоначально мною был написан UEP третьим способом ,
с записью в файл стандартным Appending'ом
Но он показал себя крайне не жизнеспособным из за стандартного заражения
Многим программам оказалось в кайф затирать память выше себя вместе с вирусом

 UEP_V2.ASM  -	Процедуры поиска и заражения Far Proc не изменились
Кардинально изменен метод заражения - Вирус записывается между Header'ом
и программой .

      Корректировка Reloc элементов в заголовке и в теле программы
      основана на предположении что адреса Reloc Элементов
      в Header'e линейно возрастают.Если это условие не выполняется
      файл будет скорректирован неправильно и будет неработоспособным

Эту версию UEP я оставил по причине изящности этого алгоритма(по моему мнению)

 UEP_V3.ASM  -	Процедуры поиска и заражения Far Proc не изменились
Изменен способ корректировки Reloc элементов на стандартный

 DUMB_UEP.ASM  -  Нерезидентный Бета тестер для всех версий UEP .
Наполовину состоит из выдранных из моего первого виря DUMB.COM кусков,
написал я его за 10 минут так что смотреть там особо не на что


  Результаты тестов
  ─────────────────

Было протестировано около 30'и файлов с UEP_v2 , UEP_v3 .

UEP_v2: оказались работоспобными файлы с линейным возрастанием эл-тов в Header'e
UEP_v3: Все файлы оказались работоспособными

Проехавшись по Бета тОстеру AVP 3.0 и DRWEB'ом 4.00 ,оба пернули чтА EXE.Virus
Из 30'и файлов AVP обнаружил тОстер в двух ,а WEB ни в одном !!!

  Замечания
  ─────────

  Требует i386 как минимум - писать под 8086 за&#@ло уже давно

 За реализацию прошу строго не судить - я не вирмак, а так , плюшками балуюсь

 Привет всем вирмейкерам.
 И Пусть вирусная болезнь DOS перейдет в хроническую стадию ... :)

				       Новосибирск
				       Июнь '98
				       NSTU.[СерЖ]
