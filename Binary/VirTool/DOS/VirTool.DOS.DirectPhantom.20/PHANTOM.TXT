
                Direct Phantom
                ──────────────
          A includable Simulated Polymorphic Generator
          ────────────────────────────────────────────


 Mutation Engine. Ну вот и я решил попробов ть себя в этой обл сти.
 Уж не зн ю к к получилось, но дум ю н  Уровне. Только не зн ю н  к ком:

 [ Использов ние в р сшифровщике вз моз меняемых инструкций и "перемешив ние"
   инструкций между собой без изменения  лгоритм  шифров ния,  т кже р сшифровщик
   может использов ть р зличные  лгоритмы шифров ния вирусного код .]
   (C) к жется Д нилов  ?

 Direct Phantom - это подключ емый генер тор,моделирующий
 полиморфные р сшифровщики. В этой версии DPH 1.0 длинн  декриптор 
 в рьируется от 50 до 100 б йт без мусор . Алгоритм шифров ния
 сост вляется из 13 ком нд н  RND(8...16) позиций - от 0.8*10^9 до 6.6*10^17
 комбин ций ком нд

 Вызов
 ─────

 Нужно з полнить структуру

 (1)
 TARGETPLACE   : SEG:OFFS - место генерения декриптор 
 DEST_CODE     :  дрес шифруемой обл сти,SEG декриптор 
 COUNTER       : длинн  обл сти
 LENDECRYPTOR  : длинн  декриптор  = 0
 RELOFFS       : дополнительное смещение

 (2)
 CALL PHANTOM      - генер ция декриптор 

 Созд ет декриптор в ук з нном месте
 Если DEST_CODE=FFFFh, то после генер ции DEST_CODE = TARGETOFFS+LENDECRYPTOR

 CALL JuNK_DOIT    - шифров ние обл сти,освобождение стек 


 Моделиров ние
 ─────────────

 При генер ции не используется ник ких сж тых м сок - нет принципи льно р зных
 ч стей ,поэтому р зные декрипторы в общем должны р ссм трив ться к к
 декрипторы одного тип :

 ────────────────────────────────────────────────────────────────────────────
 (1)
 InitUsedRegisters:
 BASE       = 1000h  В произвольном порядке,
 KEY        = RND    с р зными регистр ми,
 COUNTER    = 3Dh    и р зными способ ми
 SEGBASE    = ES,DS

 mov    bx,0974F  ; BASE    mov    al,068     ; KEY
 push   cs    ; DSBASE  mov    bp,A014    ; BASE
 pop    ds          mov    bx,cs      ; DSBASE
 mov    si,cs     ; ESBASE  mov    ds,bx
 mov    es,si           mov    dx,0003D   ; COUNTER
 mov    al,038    ; KEY     push   cs     ; ESBASE
                pop    es

 (2)
 LoadByteFromCode:  (Present/Abscent)

 З грузк  б йт  из криптуемого код  в TMP_REG,
 если криптов ние непосредственно в п мять,то ничего нет

 mov    ch,es:[bx+78B1]     ------//------

 (3)
 Arithm&Shift[De]Coding:

 Кодиров ние б йт   рифметич скими и логическими ком нд ми в REG/MEM
 От 8 до 16 комм нд

 П р ллельно в стеке созд ется EncryptionPart состоящий из
 зерк льных комм нд в обр тном порядке
 При з кодиров нии используется созд нный декриптор,но с вызовом EncryptPart

 rol    ch,64           add    ds:[bp][06FEC],00C ; A014+6FEC=1000h
 add    ch,al           add    es:[bp][06FEC],dh
 sub    ah,2E           add    ds:[bp][06FEC],094
 inc    ch          sub    es:[bp][06FEC],06B
 add    ch,FC           add    ds:[bp][06FEC],0A2
 sub    ch,al           inc    es:[bp][06FEC]
 sub    ch,1C           sub    es:[bp][06FEC],dl  ; С счетчиком
 neg    ch          sub    ds:[bp][06FEC],al  ; С ключем
 rol    ch,1            add    es:[bp][06FEC],al
                neg    es:[bp][06FEC]
                not    es:[bp][06FEC]
                inc    ds:[bp][06FEC]
                rol    ds:[bp][06FEC],024
                add    es:[bp][06FEC],066
                rol    es:[bp][06FEC],1

 (4)
 SaveByteFromCode:  (Present/Abscent)

 Сохр нение б йт  в криптуемый код из TMP_REG,
 если криптов ние непосредственно в п мять,то ничего нет

 mov    es:[bx+78B1],ch     ------//------

 (5)
 ChangeCnt,Base&TestLimit

 Продвижение Б зы  -  ADD/SUB,SUB/ADD,INC

 Уменьшение счетчик  цикл   -  DEC
 (если т ковой существует)

 Проверк  предел   -  CMP or None
 Результ т в ZF
 После проверки предел  не присутствует мусор

 sub    bx,4C           inc    bp
 add    bx,4D           dec    dx
 cmp    bx,978C

 (5a)
 ChangeKey (не ре лизов но)
 Изменение ключ  всеми доступными способ ми

 (6)
 JumpIfNotAll

 Цикл по призн ку ZF  -  JNE Rel8 , JNE Rel16
 ────────────────────────────────────────────────────────────────────────────

 HISTORY
 ───────

 Версия 1.0 beta

 + Не н йдено ошибок. У-рр-  !!!
 + Возможность использов ния DEST_CODE = FFFFh
 - Нет мусор  - уже н пис н,но неоптимизен,TRCHAIN = RET
 - Нет б зиров ния PHANTOM (и не будет)
 - Нет  нтиэвристики (и не будет)

 Версия 2.0

 + Сдел н генер тор мусор  включ ющий в себя весь к кой только можно мусор
   с любыми режим ми  дрес ции (см. TRCOMM.TXT ). Круче SMEG !
   Включ ет мусорные подпрогр ммы и вызовы их. Все CALL'ы  дресуются н з д.


 - Имеется генер ция словного мусор   дресующегося в п мять тип  mov ax,[bx]
   Отсюд  возможн  экзотическ я ошибк  "з вор чив ние сегмент "
   Это когд  BX=0FFFFh,и при mov ax,[bx] вылет ет Exeption 12:Invalid opcode
   Вообще сн ч л  я дум л что т кой глюк будет встреч ться кр йне редко,
   но к моему огорчению результ ты тестов пок з ли обр тное - 1/15.
   Видимо придется ост вить только б йтовую  дрес цию в п мять.А ж ль.

 - Кр йне принципи льн я ошибк .
   Мусорные CALL'ы формируются из 4 offset'ной очереди н  предшествующие SUB'ы
   в любом месте прогр ммы.Но слежение з  регистр ми осуществляется линейно
   по ходу формиров ния декриптор .
   Может возникнуть ситу ция когд  SUB'рутин  мусором изменяет нужный регитср,
   когд  в том месте откуд  он  вызыв л сь этого уже дел ть нельзя.
   Но когд  генерил сь процедур  этот регистр был еще свободным для мусор 

 Версия 2.1

 + Испр влены CALL'ы :
   Теперь  дрес ция CALL'ов сдел н  только н  впередстоящие SUB'рутины.
   То есть в SUB' х нужные регистры уже учтены.
   Для пользов ния FREEREG сдел н MaskCALLRequest - з прещ ет генер цию CALL'ов
 + Возможны вложенные CALL'ы : в одном экземпляре у меня н блюлось 8 вложений.
 - Лишняя сотня б йтов . Итого DirectPhantom v2.1 = 2045 б йт.
