
			NPE32  v. 1.00 (c) necr0mancer
			------------------------------
Представляю вам мое первое творение из области полиморфиков.NPE32 - это
полиморфный движок , криптующий данные и создающий расшифровщик под эти
данные (например,данные вируса).

В декрипторе используются все регистры общенго назначения,кроме esp
(т.к юзается алгоритм push/pop) и около 10 комманд (ADD,SUB,INC,DEC,XOR ...)
Помимо этого генерируется мусор (порядка 9 комманд).
Принцип работы расшифровщика таков (глянь-ка Каспер):

		....
		call d
	d:
		pop _random_delta_reg
		sub _random_delta_reg,xxxxx_d
		...
		lea _random_reg32,[_random_delta_reg+xxxxx] ;xxxxx-смещение
			                                    ;зашифрованого кода
		xchg _one_some_rand_reg,esp
		....
		mov _index_reg,crypted_code_size
		....
		pop reg1
		...
		pop reg2
		...
		pop regN

		......					    ;преобразуем код
		push regN
		...
		...
		...

		jmp kakayato_huynya 			    ;loop-им
		...

		xchg _one_some_rand_reg,esp
		...

xxxxx:		mov eax,12345678h			    ;собственно код
		ret

Понятно,что это дело рандомно (количество использованных регистров,сами регитры)
и между коммандами вставляются мусорные инструкции.

ОПИСАНИЕ РАБОТЫ:
~~~~~~~~~~~~~~~		
На входе движок получает следующего вида параметры(привожу описание ф-ции):

stdcall
int NPE_main(
               DWORD   *offset data                    //поинтер на нужный код
               DWORD   *offset bufer                   //поинтер на буфер
               DWORD   count_bytes                     //размер кода
               DWORD   seed                            //seed
               DWORD   flags                           //флаги
            );

Буфер используется в процессе его работы (конкретно движок жрет 3 kb ;)) так ,что
следуе выделять больше памяти , чем надо на 3-4 кб.
При первом запуске ,необходимо поместить в параметр seed рандомное число,
для инициализации ГСЧ (используестя довольно стандартный метод).Далее на этот 
параметр можно забить и юзать NULL (0).
Работа npe управляется флагами , формат их таков:


         биты:
        ┌─────────┬───────────────────────────────────────┐
        │  0..6   │ используемые регистры                 │
        ├─────────┼───────────────────────────────────────┤
        │  7      │ простой антидебаг на завершении       │
        ├─────────┼───────────────────────────────────────┤
        │  8..11  │ используемые комманды (10)            │
        ├─────────┼───────────────────────────────────────┤
        │  11..16 │ используемый мусор (9)                │
        └─────────┴───────────────────────────────────────┘
Прим.
   	Использованных регистро должно быть минимум 3.

 	  Regs32 (биты 0..6):
        ┌─────┬───┬───┬───┬───┬───┬───┬───┐
        │ бит │ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │
        ├─────┼───┼───┼───┼───┼───┼───┼───┤
        │ reg │EAX│EBX│EDX│ECX│ESI│EDI│EBP│
        └─────┴───┴───┴───┴───┴───┴───┴───┘

Применение флагов полезно в случае наличия желания заставить авера дизасмить 
вирус,возможно и сам движок.Фокус заключается в комманде CPUID,которая как 
известно уникальна для каждого компьютера.Поэтому при одинаковых флагах будут 
юзаться одни и теже комманды и регистры (но это не значит ,что оди будут в том
же порядке). Следовательно метод в 1000 самплов не покатит.Диагноз-дизасмить 
(или реверсировать по ГСЧ.По-моему проще дизасмить =)

В процессе работы движок создает криптор и криптует им данные.Затем на основе
него уже создается декриптор и дается мусор.

На выходе движка в eax имеем размер сгенереного декриптора+размер данных.
cf=1 ,если произошла ошибка,иначе cf=0.

НОТЕ:
~~~~
Итак ,при использовании движка в так называемом multi-layer mode был подмечен 
глючок по всей видимости связаный с мульти-декриптором большим в размере ,чем 
3 килобайта.Я не могу найти пока линию в сорце с ошибкой :(

P.S.

Ни в коем случае не применяйте его в вирусах!!!Это же противозаконно!И вообще
я рекомендую применять его ТОЛЬКО (!) для криптования tetris'овой секции .debug.:)


							 (C) necr0mancer 2001
                            			  necr0mancer2001@hotmail.com